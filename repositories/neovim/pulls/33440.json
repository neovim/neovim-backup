{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/33440/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33440/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/33440"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/33440"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33440/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/f3c812f9c79556eb8ce8c13f0548457627012dd8"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6037,
            "forks_count": 6037,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1913,
            "open_issues_count": 1913,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-04-21T23:49:28Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 318183,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 88840,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-04-22T02:39:42Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 88840,
            "watchers_count": 88840,
            "web_commit_signoff_required": false
        },
        "sha": "65170e8dad908b15d14b5d68be3ee1a26642ad8b",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "<!--\r\n  Thank you for contributing to Neovim!\r\n  If this is your first time, check out https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md#pull-requests-prs\r\n  for our PR guidelines.\r\n-->\r\nCloses https://github.com/neovim/neovim/issues/32920.\r\n\r\n### Cheeky previews\r\n`'background'` style (the default)\r\n<img width=\"283\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7e6f3f2d-5c10-42e8-a7f7-1d19fa2b113b\" />\r\n\r\n`'foreground'` style\r\n<img width=\"265\" alt=\"image\" src=\"https://github.com/user-attachments/assets/417edf28-3663-47c5-9222-789c2e5b6292\" />\r\n\r\n`'virtual'` style (similar to VS C*de's [inline square](https://code.visualstudio.com/docs/languages/css#_syntax-coloring-color-preview))\r\n<img width=\"318\" alt=\"image\" src=\"https://github.com/user-attachments/assets/2ac7d22e-2ac4-4a62-a75f-df63cdef5f81\" />\r\n\r\nPending items:\r\n- [x] Add tests.\r\n- ~[ ] Refactor common logic with #32138~ I think it will be better to move this to a later refactor PR.\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874060"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874060"
                }
            },
            "author_association": "MEMBER",
            "body": "does this function can be public ðŸ¤” then  https://github.com/neovim/neovim/pull/32138 can reuse it in generate_kind..",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-13T02:35:32Z",
            "diff_hunk": "@@ -0,0 +1,84 @@\n+local document_color_ns = vim.api.nvim_create_namespace('nvim.lsp.document_color')\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874060",
            "id": 2040874060,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55pURM",
            "original_commit_id": "adfadbee422f4da2c1b8a6949e04da90988a0348",
            "original_line": 53,
            "original_position": 12,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2762518633,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874060/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-13T02:35:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874060",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874584"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874584"
                }
            },
            "author_association": "MEMBER",
            "body": "Sure! Let me finish the implementation first and then we can refactor it to make some of these utilities public :)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-13T02:40:41Z",
            "diff_hunk": "@@ -0,0 +1,84 @@\n+local document_color_ns = vim.api.nvim_create_namespace('nvim.lsp.document_color')\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874584",
            "id": 2040874584,
            "in_reply_to_id": 2040874060,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55pUZY",
            "original_commit_id": "adfadbee422f4da2c1b8a6949e04da90988a0348",
            "original_line": 53,
            "original_position": 12,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2762519065,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874584/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-13T02:40:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874584",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874729"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874729"
                }
            },
            "author_association": "MEMBER",
            "body": "thank you ",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-13T02:41:17Z",
            "diff_hunk": "@@ -0,0 +1,84 @@\n+local document_color_ns = vim.api.nvim_create_namespace('nvim.lsp.document_color')\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2040874729",
            "id": 2040874729,
            "in_reply_to_id": 2040874060,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55pUbp",
            "original_commit_id": "adfadbee422f4da2c1b8a6949e04da90988a0348",
            "original_line": 53,
            "original_position": 12,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2762519182,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874729/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-13T02:41:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2040874729",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2041301649"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2041301649"
                }
            },
            "author_association": "MEMBER",
            "body": "@justinmk LMK what you think of this API.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-14T02:04:28Z",
            "diff_hunk": "@@ -2131,6 +2131,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       â€¢ {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.document_color                        *lsp-document_color*\n+\n+enable({enable}, {filter})                   *vim.lsp.document_color.enable()*",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2041301649",
            "id": 2041301649,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55q8qR",
            "original_commit_id": "6aaf4a9ab8a222bf30070939bbadcac3021293fa",
            "original_line": 2137,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2762965029,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2041301649/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-14T02:04:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2041301649",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045358090"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045358090"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\nfunction M._on_document_color(err, result, ctx)\n```\n\n`private` doesn't have a proper meaning here. The only convention we have for marking something private within the `vim.*` namespace is to prefix with `_`.\n\nAlternatively you can change `@private` to `@nodoc` which is our own thing.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T19:51:10Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045358090",
            "id": 2045358090,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556bAK",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 194,
            "original_position": 116,
            "original_start_line": 115,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045358090/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-15T20:09:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045358090",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045367466"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045367466"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n  local color_ranges = {}\n  for _, res in ipairs(result) do\n      local range = {\n        res.range.start.line,\n        res.range.start.character,\n        res.range['end'].line,\n        res.range['end'].character,\n      }\n      table.insert(color_ranges, { hl_group = get_hl_group(res.color), range = range })\n  end\n```\n\nThis really is a light suggestion but this is -3 LOC, portable, and more readable IMO.\n\n`vim.iter` has a place, but I don't think anything is gained when using it for one off maps.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T19:55:39Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045367466",
            "id": 2045367466,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556dSq",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 152,
            "original_position": 152,
            "original_start_line": 140,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045367466/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-15T20:09:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045367466",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045387511"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045387511"
                }
            },
            "author_association": "MEMBER",
            "body": "Should mention the default.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T20:03:38Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()\n+  bufstate.hl_infos[client_id] = color_ranges\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @class lsp.document_color.enable.Filter\n+--- @inlinedoc\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045387511",
            "id": 2045387511,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556iL3",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 190,
            "original_position": 190,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045387511/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-15T20:09:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045387511",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045391858"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045391858"
                }
            },
            "author_association": "MEMBER",
            "body": "Is it possible to not unconditionally attach to every LSP enabled buffer? Shouldn't this only be created when `enable` is called?",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T20:06:02Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()\n+  bufstate.hl_infos[client_id] = color_ranges\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @class lsp.document_color.enable.Filter\n+--- @inlinedoc\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable\n+--- @param filter? lsp.document_color.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('LspNotify', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    local bufnr = args.buf\n+    local method = args.data.method --- @type string\n+\n+    if\n+      (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+      and bufstates[bufnr].enabled\n+    then\n+      buf_refresh(bufnr, { client_id = args.data.client_id })\n+    end\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspAttach', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    api.nvim_buf_attach(args.buf, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045391858",
            "id": 2045391858,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556jPy",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 272,
            "original_position": 240,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045391858/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-15T20:09:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045391858",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045393096"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045393096"
                }
            },
            "author_association": "MEMBER",
            "body": "Same here.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T20:06:41Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()\n+  bufstate.hl_infos[client_id] = color_ranges\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @class lsp.document_color.enable.Filter\n+--- @inlinedoc\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable\n+--- @param filter? lsp.document_color.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('LspNotify', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    local bufnr = args.buf\n+    local method = args.data.method --- @type string\n+\n+    if\n+      (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+      and bufstates[bufnr].enabled\n+    then\n+      buf_refresh(bufnr, { client_id = args.data.client_id })\n+    end\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspAttach', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    api.nvim_buf_attach(args.buf, false, {\n+      on_reload = function(_, bufnr)\n+        buf_clear(bufnr)\n+        if bufstates[bufnr].enabled then\n+          buf_refresh(bufnr)\n+        end\n+      end,\n+      on_detach = function(_, bufnr)\n+        buf_disable(bufnr)\n+      end,\n+    })\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspDetach', {",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045393096",
            "id": 2045393096,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556jjI",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 286,
            "original_position": 254,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045393096/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-15T20:10:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045393096",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045396683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045396683"
                }
            },
            "author_association": "MEMBER",
            "body": "If you're using non-ephemeral marks in a decor provider, then you need to clear the namespace at the beginning of `on_win`. Alternatively you can make these marks ephemeral.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T20:08:54Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()\n+  bufstate.hl_infos[client_id] = color_ranges\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @class lsp.document_color.enable.Filter\n+--- @inlinedoc\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable\n+--- @param filter? lsp.document_color.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('LspNotify', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    local bufnr = args.buf\n+    local method = args.data.method --- @type string\n+\n+    if\n+      (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+      and bufstates[bufnr].enabled\n+    then\n+      buf_refresh(bufnr, { client_id = args.data.client_id })\n+    end\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspAttach', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    api.nvim_buf_attach(args.buf, false, {\n+      on_reload = function(_, bufnr)\n+        buf_clear(bufnr)\n+        if bufstates[bufnr].enabled then\n+          buf_refresh(bufnr)\n+        end\n+      end,\n+      on_detach = function(_, bufnr)\n+        buf_disable(bufnr)\n+      end,\n+    })\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspDetach', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+    if not vim.iter(clients):any(function(c)\n+      return c.id ~= args.data.client_id\n+    end) then\n+      -- There are no clients left in the buffer that support document color, so turn it off.\n+      buf_disable(args.buf)\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045396683",
            "id": 2045396683,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM556kbL",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 293,
            "original_position": 283,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769627577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045396683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-15T20:09:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045396683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045595636"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045595636"
                }
            },
            "author_association": "MEMBER",
            "body": "I was following what we do with inlay hints:\r\nhttps://github.com/neovim/neovim/blob/5333d6371bfa2fe048e5d99e0e843657b3b0e33f/runtime/lua/vim/lsp/inlay_hint.lua#L39-L40\r\n\r\nBut okay, I'll change it to `@nodoc` then.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T21:53:44Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045595636",
            "id": 2045595636,
            "in_reply_to_id": 2045358090,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM557U_0",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 194,
            "original_position": 116,
            "original_start_line": 115,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769993393,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045595636/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-15T21:53:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045595636",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045597162"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045597162"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this is a personal preference. Unless there are strong arguments against using `vim.iter` here I'll stick to my current approach.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T21:55:20Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045597162",
            "id": 2045597162,
            "in_reply_to_id": 2045367466,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM557VXq",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 152,
            "original_position": 152,
            "original_start_line": 140,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2769995497,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045597162/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-15T21:55:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045597162",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045608832"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045608832"
                }
            },
            "author_association": "MEMBER",
            "body": "The rules kinda changed since then, sorry! (emmyluals is more strict about this than luals, and we're looking to change in the not so distant future, so it makes sense for new annotations to be forward looking.)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-15T22:07:25Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045608832",
            "id": 2045608832,
            "in_reply_to_id": 2045358090,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM557YOA",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 194,
            "original_position": 116,
            "original_start_line": 115,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770015042,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045608832/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-15T22:07:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045608832",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045764860"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045764860"
                }
            },
            "author_association": "MEMBER",
            "body": "The argument is that, with everything else being equal, simpler is always better, and unnecessary abstraction should be avoided. If there is personal preference, I would hope there are reasons for that.\n\nI discussed most of my gripes with `vim.iter` in #28941 . The callback signature is different depending if the input is a \"list\" (a table with contiguous integer keys beginning from 1), which I consider a critical design flaw. E.g. if you have a table of buffer number to any value, `vim.iter` won't be predictable. To make matters worse it also contains unavoidable logic for detecting lists.\n\nUnfortunately `vim.iter` was added fairly late in a dev cycle, before I even had a chance to properly look at it, so we are kind of stuck with it until #28941 is resolved. Until then I'm going to continue to advocate that`vim.iter` should only be used in situations where it has a clear benefit. And without good reason, it should never be used as a drop in alternative for `pairs`/`ipairs` which are much more accessible and easier to understand.\n\nSorry for the rant. What I consider flawed API's being unnecessarily used, crossed with hand waves of \"personal preference\" really does trigger me. And just to be clear, you can keep this as is, I just hope one day you will come around to my general POV.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T00:23:06Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045764860",
            "id": 2045764860,
            "in_reply_to_id": 2045367466,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM557-T8",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 152,
            "original_position": 152,
            "original_start_line": 140,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770266909,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045764860/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-16T00:23:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045764860",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045770046"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045770046"
                }
            },
            "author_association": "MEMBER",
            "body": "Even with LuaLS's definition of `@private` this is wrong. There are quite a lot of places where people have added `@private` in various modules and I plan to fix them.\n\nWe need to lobby for a new annotation that is like private, but is scoped for the whole workspace, then the diagnostics will strictly only be shown in plugin code.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T00:27:44Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045770046",
            "id": 2045770046,
            "in_reply_to_id": 2045358090,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM557_k-",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 194,
            "original_position": 116,
            "original_start_line": 115,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770274868,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045770046/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-16T00:27:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045770046",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045894982"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045894982"
                }
            },
            "author_association": "MEMBER",
            "body": "Don't be sorry! Thanks for sharing, I now better understand why you dislike `vim.iter`. I didn't mean my \"it's personal preference\" comment to sound aggressive, I personally find this kind of stream-like coding to be much nicer to follow and elegant overall. Arguing that `pairs`/`ipairs` are much clearer feels to me like a subjective argument.\r\n\r\nThis doesn't bother me as much as it bothers you, so I'll drop the `vim.iter` usage. That being said I'm not a fan of this kind of coding \"conventions\" that we're not consistently enforcing (either with a linter or with documented guidelines), but I don't want to begin a painful debate over something that isn't what this PR is about.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T02:35:35Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045894982",
            "id": 2045894982,
            "in_reply_to_id": 2045367466,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM558eFG",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 152,
            "original_position": 152,
            "original_start_line": 140,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770484987,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045894982/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-16T02:35:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045894982",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045898238"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045898238"
                }
            },
            "author_association": "MEMBER",
            "body": "Quoting @gpanders and @clason from our Matrix conversation:\r\n> thinking ahead, we will probably want to go ahead and add some kind of function option so that users can make whatever UI they want (like @ribru17 did)\r\n> perhaps pass the buffer number, position of the text (start row+col and end row+col), and the \"resolved\" hex color, and then the function creates whatever UI element it wants. we could still add some \"common\" ones as defaults too of course (similar model to what we do for diagnostics)\r\n\r\n> I think `background`, `foreground`, and `virtual swatch` would be reasonable (low complexity) ootb options",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T02:40:00Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045898238",
            "id": 2045898238,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM558e3-",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770490506,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045898238/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-16T02:40:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045898238",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2045911661"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045911661"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmm I borrowed the logic from [`inlay_hint`](https://github.com/neovim/neovim/blob/1de276bbcd8f1b3c5ef1d0bd6d4e112cae119337/runtime/lua/vim/lsp/inlay_hint.lua#L267) but yes you're right we can probably improve this.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T02:58:00Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()\n+  bufstate.hl_infos[client_id] = color_ranges\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @class lsp.document_color.enable.Filter\n+--- @inlinedoc\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable\n+--- @param filter? lsp.document_color.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('LspNotify', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    local bufnr = args.buf\n+    local method = args.data.method --- @type string\n+\n+    if\n+      (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+      and bufstates[bufnr].enabled\n+    then\n+      buf_refresh(bufnr, { client_id = args.data.client_id })\n+    end\n+  end,\n+})\n+\n+api.nvim_create_autocmd('LspAttach', {\n+  group = document_color_augroup,\n+  callback = function(args)\n+    api.nvim_buf_attach(args.buf, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2045911661",
            "id": 2045911661,
            "in_reply_to_id": 2045391858,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM558iJt",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 272,
            "original_position": 240,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2770511220,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045911661/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-16T02:58:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2045911661",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2046484058"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2046484058"
                }
            },
            "author_association": "MEMBER",
            "body": "> Arguing that pairs/ipairs are much clearer feels to me like a subjective argument.\r\n\r\nSorry, when I said \"more readable\", I should have said \"easier to understand\". `pairs`/`ipairs` are a part of Lua's **_tiny_** standard library, and it's basically impossible to learn Lua without knowing both of these. `vim.iter` is a custom, much more elaborate interface, and thus has more friction to the general reader. To me, this is more objective.\r\n\r\n> That being said I'm not a fan of this kind of coding \"conventions\" that we're not consistently enforcing (either with a linter or with documented guidelines), but I don't want to begin a painful debate over something that isn't what this PR is about.\r\n\r\nI don't think this is about convention, but more one implementation having several benefits over another. \r\n\r\nWe can't automate and document everything, that just isn't feasible or productive, and there needs to be forums for conventions to be established.\r\n\r\nMany review comments have some level of subjectivity. If you argue hard enough, you could say all my comments in this PR are subjective. If it is highly objective, then it is likely to be automatable with low enough effort (spelling mistakes, syntax errors).",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-16T09:18:43Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @private\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local color_ranges = vim\n+    .iter(result)\n+    --- @param res lsp.ColorInformation\n+    :map(function(res)\n+      local range = {\n+        res.range.start.line,\n+        res.range.start.character,\n+        res.range['end'].line,\n+        res.range['end'].character,\n+      }\n+      return { hl_group = get_hl_group(res.color), range = range }\n+    end)\n+    :totable()",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2046484058",
            "id": 2046484058,
            "in_reply_to_id": 2045367466,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55-t5a",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 152,
            "original_position": 152,
            "original_start_line": 140,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2771790817,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2046484058/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-16T09:18:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2046484058",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2049795136"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2049795136"
                }
            },
            "author_association": "MEMBER",
            "body": "Okay I've added this :)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-18T00:39:37Z",
            "diff_hunk": "@@ -0,0 +1,296 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hl_group: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @param r integer\n+--- @param g integer\n+--- @param b integer\n+local function get_contrast_color(r, g, b)\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hl_group(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+  local r, g, b = color.red, color.green, color.blue --- @type integer, integer, integer\n+\n+  local hex = ('#%02x%02x%02x'):format(r, g, b)\n+  local hl_name = 'LspDocumentColor' .. hex:sub(2)\n+\n+  if not color_cache[hl_name] then\n+    api.nvim_set_hl(0, hl_name, { bg = hex, fg = get_contrast_color(r, g, b) })",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2049795136",
            "id": 2049795136,
            "in_reply_to_id": 2045898238,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56LWRA",
            "original_commit_id": "30947ce6db7261cb8a92aea711201792b3552667",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2777178439,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2049795136/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-18T00:39:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2049795136",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2050289768"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050289768"
                }
            },
            "author_association": "MEMBER",
            "body": "Highlight groups can be cleared after they are created. The common use case is usually `:colorscheme` command, but can happen after a manual `:hi clear` and intentional `vim.api.nvim_set_hl(0, 'LspDocumentColor_000000_background', {})` (which is not reasonable to support, but still can happen).\r\n\r\nThere are several ways around it:\r\n- `vim.fn.hlexists(hl_name) == 0`. Very fast, but might have issues with fast events (needs checking).\r\n- `next(vim.api.nvim_get_hl(0, { name = hl_name })) == nil`. Equally fast, not sure about side effects. Kind of cryptic.\r\n- Clearing `color_cache` in autocommand for `ColorScheme` event. Not 100% solution, but covers most use cases.\r\n\r\nFirst two approaches add constant (bigger than `color_cache[hl_name]`, yet very small) overhead: ~0.3 microseconds compared to ~0.1 microseconds of `color_cache[hl_name]`. Even so, I'd say `nvim_get_hl()` is the best overall approach here (if works).",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-18T07:46:09Z",
            "diff_hunk": "@@ -0,0 +1,341 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2050289768",
            "id": 2050289768,
            "line": 84,
            "node_id": "PRRC_kwDOAPphoM56NPBo",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 84,
            "original_position": 83,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 84,
            "pull_request_review_id": 2777988978,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050289768/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-18T07:49:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050289768",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2050636623"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050636623"
                }
            },
            "author_association": "MEMBER",
            "body": "In general for these kinds of features which are gated on support for a particular LSP capability (in this case, `textDocument/documentColor`) I think it'd be nice to include an example snippet that shows how to enable this feature conditionally. Or if not a full snippet, at least mentioning here in the docs which capability this feature maps to.\r\n\r\nMaybe something like:\r\n\r\n```suggestion\r\n    Enables document highlighting from the given language client in the given\r\n    buffer. Requires the `textDocument/documentColor` capability.\r\n```",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-18T13:35:37Z",
            "diff_hunk": "@@ -2131,6 +2131,43 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       â€¢ {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.document_color                        *lsp-document_color*\n+\n+enable({enable}, {filter}, {opts})           *vim.lsp.document_color.enable()*\n+    Enables document highlighting from the given language client in the given\n+    buffer.",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2050636623",
            "id": 2050636623,
            "line": 2163,
            "node_id": "PRRC_kwDOAPphoM56OjtP",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 2163,
            "original_position": 9,
            "original_start_line": 2138,
            "path": "runtime/doc/lsp.txt",
            "position": 9,
            "pull_request_review_id": 2778596914,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050636623/reactions"
            },
            "side": "RIGHT",
            "start_line": 2162,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-18T13:35:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2050636623",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2051580222"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051580222"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmm I think I'll go with just reacting to the `ColorScheme` event ([like `mini.hipatterns` does](https://github.com/echasnovski/mini.hipatterns/blob/e5083df391171dc9d8172645606f8496d9443374/lua/mini/hipatterns.lua#L707) ðŸ˜‰)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-19T21:08:44Z",
            "diff_hunk": "@@ -0,0 +1,341 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2051580222",
            "id": 2051580222,
            "in_reply_to_id": 2050289768,
            "line": 84,
            "node_id": "PRRC_kwDOAPphoM56SKE-",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 84,
            "original_position": 83,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 84,
            "pull_request_review_id": 2780092737,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051580222/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-19T21:08:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051580222",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2051655224"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051655224"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah, this works, but mostly because it is also a convenient way to reload buffers. Although, after writing the original comment, I did start to think that using `vim.api.nvim_get_hl()` in 'mini.hipatterns' instead of custom cache might be worth it.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-20T07:20:14Z",
            "diff_hunk": "@@ -0,0 +1,341 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2051655224",
            "id": 2051655224,
            "in_reply_to_id": 2050289768,
            "line": 84,
            "node_id": "PRRC_kwDOAPphoM56ScY4",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 84,
            "original_position": 83,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 84,
            "pull_request_review_id": 2780170368,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051655224/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-20T07:20:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051655224",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2051723303"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051723303"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I'm not a maintainer, but I don't think \"foreground\" style is necessary. Because it can be confused with normal Nvim syntax highlighting, and if foreground color is too similar to background color, then ...",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-20T13:20:12Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2051723303",
            "id": 2051723303,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56StAn",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2780244153,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051723303/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-20T13:20:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051723303",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2051762199"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051762199"
                }
            },
            "author_association": "MEMBER",
            "body": "Okay, I'll switch it over.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-20T16:38:14Z",
            "diff_hunk": "@@ -0,0 +1,341 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2051762199",
            "id": 2051762199,
            "in_reply_to_id": 2050289768,
            "line": 84,
            "node_id": "PRRC_kwDOAPphoM56S2gX",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 84,
            "original_position": 83,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 84,
            "pull_request_review_id": 2780285262,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051762199/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-20T16:38:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051762199",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2051780044"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051780044"
                }
            },
            "author_association": "MEMBER",
            "body": "> Okay, I'll switch it over.\r\n\r\nSorry for not being clear. That comment was mostly \"thinking out loud\". Using `ColorScheme` event definitely works and should be enough here (the only good reason to call `:hi clear` is inside a color scheme file).",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-20T18:10:38Z",
            "diff_hunk": "@@ -0,0 +1,341 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2051780044",
            "id": 2051780044,
            "in_reply_to_id": 2050289768,
            "line": 84,
            "node_id": "PRRC_kwDOAPphoM56S63M",
            "original_commit_id": "be9403ec2ef2390aef087150ac4fb62c168ec612",
            "original_line": 84,
            "original_position": 83,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 84,
            "pull_request_review_id": 2780303790,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051780044/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-20T18:10:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2051780044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052290900"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052290900"
                }
            },
            "author_association": "MEMBER",
            "body": "Then don't use it. This style 1. is supported by other colorizers, 2. has almost zero cost, and 3. is not the default.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T11:33:08Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052290900",
            "id": 2052290900,
            "in_reply_to_id": 2051723303,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56U3lU",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781086069,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052290900/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T11:33:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052290900",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052295760"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052295760"
                }
            },
            "author_association": "MEMBER",
            "body": "Question: Do we want to make the swatch configurable? (I.e., allowing users to provide a their own glyph: square vs. round; larger square; etc.) We could make any value of `style` that is not `fg/bg` taken verbatim as `virt_text` here; that would avoid introducing another option and require minimal changes to the current code.\r\n\r\nSuggestion: Add a comment here with the unicode representation of this string, since Github doesn't show anything... \r\n\r\nNit: Is this the largest box character we can assume is widely available?",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T11:39:26Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052295760",
            "id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56U4xQ",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781093863,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052295760/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T12:04:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052295760",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052310478"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052310478"
                }
            },
            "author_association": "MEMBER",
            "body": "> Nit: Is this the largest box character we can assume is widely available?\r\n\r\nThis is how this character *with extra space to the right* looks in Kitty and Ghostty:\r\n\r\n![screenshot_2025-04-21_14:54:22](https://github.com/user-attachments/assets/ef551588-7cb9-421f-baaf-d1c9c3a2adf6)\r\n\r\nSo if taking this \"overflow\" view into account, this is a good choice. If not, then there is a U+2588 (FULL BLOCK). With extra space it looks like this:\r\n\r\n![screenshot_2025-04-21_14:58:11](https://github.com/user-attachments/assets/5aca63ed-8ddb-4b37-be5b-88f7f13b0721)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T11:59:03Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052310478",
            "id": 2052310478,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56U8XO",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781116658,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052310478/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T11:59:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052310478",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052312468"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052312468"
                }
            },
            "author_association": "MEMBER",
            "body": "Thanks! I think the current swatch is fine but would suggest adding padding to the left as well.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T12:01:48Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052312468",
            "id": 2052312468,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56U82U",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781120047,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052312468/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T12:01:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052312468",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052330158"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052330158"
                }
            },
            "author_association": "MEMBER",
            "body": "My personal preference is only a single space to the right is good. Having it also to the left might add too much width and make it look too stretched, even when it is not needed. Yes, in these screenshots squares do look cramped, but in most usages (when there is a space or `'` to the left) it should be fine.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T12:26:01Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052330158",
            "id": 2052330158,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56VBKu",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781150442,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052330158/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T12:26:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052330158",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052435075"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052435075"
                }
            },
            "author_association": "MEMBER",
            "body": "ðŸ‘ this matches the pattern from `vim.lsp.inlay_hint`.\r\n\r\nMaybe in the future we might think about a `vim.lsp.enable({features})` interface instead of these per-feature modules, but each of these modules (inlay_hint, document_color) is non-trivial, so it's understandable that they have their own modules, I suppose...",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:10:53Z",
            "diff_hunk": "@@ -2131,6 +2131,35 @@ stop({bufnr}, {client_id})                    *vim.lsp.semantic_tokens.stop()*\n       â€¢ {client_id}  (`integer`) The ID of the |vim.lsp.Client|\n \n \n+==============================================================================\n+Lua module: vim.lsp.document_color                        *lsp-document_color*\n+\n+enable({enable}, {filter})                   *vim.lsp.document_color.enable()*",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052435075",
            "id": 2052435075,
            "in_reply_to_id": 2041301649,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56VayD",
            "original_commit_id": "6aaf4a9ab8a222bf30070939bbadcac3021293fa",
            "original_line": 2137,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2781323420,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052435075/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T14:10:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052435075",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052436511"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052436511"
                }
            },
            "author_association": "MEMBER",
            "body": "Another case for https://github.com/neovim/neovim/issues/31453 @ofseed ?",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:11:25Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052436511",
            "id": 2052436511,
            "line": 130,
            "node_id": "PRRC_kwDOAPphoM56VbIf",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 130,
            "original_position": 129,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 130,
            "pull_request_review_id": 2781325507,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052436511/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T14:11:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052436511",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052439909"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052439909"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    desc = 'Enable document_color when LSP client attaches',\r\n```",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:12:48Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052439909",
            "id": 2052439909,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56Vb9l",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 150,
            "original_position": 150,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781330821,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052439909/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T14:12:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052439909",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052440821"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052440821"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    desc = 'Disable document_color if all supporting clients detach',\r\n```",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:13:15Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052440821",
            "id": 2052440821,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56VcL1",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781332285,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052440821/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T14:13:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052440821",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052444417"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052444417"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  desc = 'Refresh LSP document_color',\r\n```",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:14:01Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052444417",
            "id": 2052444417,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56VdEB",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 323,
            "original_position": 323,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2781337003,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052444417/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T14:14:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052444417",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2052451341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052451341"
                }
            },
            "author_association": "MEMBER",
            "body": "(out of scope) sure seems like we have boilerplate for enable() functionality that could live in lsp._util",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T14:17:37Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2052451341",
            "id": 2052451341,
            "line": 305,
            "node_id": "PRRC_kwDOAPphoM56VewN",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 305,
            "original_position": 304,
            "original_start_line": 300,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 305,
            "pull_request_review_id": 2781347544,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052451341/reactions"
            },
            "side": "RIGHT",
            "start_line": 301,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-21T14:17:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2052451341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053023616"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053023616"
                }
            },
            "author_association": "MEMBER",
            "body": "+1 to @echasnovski's comment about being in favor of having a single space to the right.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T21:34:37Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053023616",
            "id": 2053023616,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56XqeA",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2782289461,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053023616/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T21:34:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053023616",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053025363"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053025363"
                }
            },
            "author_association": "MEMBER",
            "body": "> We could make any value of style that is not fg/bg taken verbatim as `virt_text` here\r\n\r\nOhhh I like this idea. I'll do that.\r\n\r\n@clason the current swatch is `\\uf0c8`",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T21:36:52Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053025363",
            "id": 2053025363,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56Xq5T",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2782292362,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053025363/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T21:36:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053025363",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053029432"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053029432"
                }
            },
            "author_association": "MEMBER",
            "body": "Would be good to quote this in a comment right before the default value, or in the documentation.\r\n\r\n(Thinking about it, it might be good to keep `virtual` as an alias for `\\uf0c8`.)",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T21:41:37Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053029432",
            "id": 2053029432,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56Xr44",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2782298574,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053029432/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T21:43:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053029432",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053062952"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053062952"
                }
            },
            "author_association": "MEMBER",
            "body": "> Would be good to quote this in a comment right before the default value, or in the documentation.\r\n> \r\n> (Thinking about it, it might be good to keep `virtual` as an alias for `\\uf0c8`.)\r\n\r\nâœ… ",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T22:26:24Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document colors on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Hook up to buffer events when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document colors if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.document_color.enable(not vim.lsp.document_color.is_enabled())\n+--- ```\n+---\n+--- @param enable? boolean True to enable, false to disable. Defaults to true.\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @param opts? vim.lsp.document_color.enable.Opts\n+function M.enable(enable, filter, opts)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+  M._opts = vim.tbl_extend('keep', opts or {}, M._opts)\n+\n+  if filter.bufnr == nil then\n+    global_state.enabled = enable\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      if api.nvim_buf_is_loaded(bufnr) then\n+        if enable then\n+          buf_enable(bufnr)\n+        else\n+          buf_disable(bufnr)\n+        end\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  else\n+    local bufnr = vim._resolve_bufnr(filter.bufnr)\n+    if enable then\n+      buf_enable(bufnr)\n+    else\n+      buf_disable(bufnr)\n+    end\n+  end\n+end\n+\n+api.nvim_create_autocmd('ColorScheme', {\n+  pattern = '*',\n+  group = document_color_augroup,\n+  desc = 'Refresh document colors',\n+  callback = function()\n+    color_cache = {}\n+\n+    for _, bufnr in ipairs(api.nvim_list_bufs()) do\n+      buf_clear(bufnr)\n+      if api.nvim_buf_is_loaded(bufnr) and bufstates[bufnr].enabled then\n+        buf_refresh(bufnr)\n+      else\n+        bufstates[bufnr] = nil\n+      end\n+    end\n+  end,\n+})\n+\n+api.nvim_set_decoration_provider(document_color_ns, {\n+  on_win = function(_, _, bufnr)\n+    local bufstate = rawget(bufstates, bufnr) --- @type vim.lsp.document_color.BufState\n+\n+    if\n+      not bufstate\n+      or not bufstate.hl_infos\n+      or bufstate.buf_version ~= util.buf_versions[bufnr]\n+      or bufstate.applied_version == bufstate.buf_version\n+    then\n+      return\n+    end\n+\n+    api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+\n+    local style = M._opts.style\n+\n+    for _, client_hls in pairs(bufstate.hl_infos) do\n+      for _, hl in ipairs(client_hls) do\n+        if type(style) == 'function' then\n+          style(bufnr, hl.range, hl.hex_code)\n+        elseif style == 'virtual' then\n+          api.nvim_buf_set_extmark(bufnr, document_color_ns, hl.range[1], hl.range[2], {\n+            virt_text = { { 'ïƒˆ ', hl.hl_group } },",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053062952",
            "id": 2053062952,
            "in_reply_to_id": 2052295760,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM56X0Eo",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 361,
            "original_position": 361,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": null,
            "pull_request_review_id": 2782348463,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053062952/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T22:26:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053062952",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053108876"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053108876"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "For `enabled`, it might be better to make it a vim variable (`vim.g`, `vim.b`), so that we can more easily refactor the new `vim.lsp.enable()`.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-21T23:38:03Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053108876",
            "id": 2053108876,
            "in_reply_to_id": 2052436511,
            "line": 130,
            "node_id": "PRRC_kwDOAPphoM56X_SM",
            "original_commit_id": "960524ae41c0b053f9b92de51cea4a03d1470377",
            "original_line": 130,
            "original_position": 129,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 130,
            "pull_request_review_id": 2782417690,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053108876/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-21T23:38:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053108876",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053139096"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053139096"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Since these autocmds are buffer-local, it seems that they will not be triggered on new buffers, because `vim.lsp.document.enable(true)` only call `buf_enable(bufnr)` on existing buffers when it is called.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-22T00:19:43Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053139096",
            "id": 2053139096,
            "line": 132,
            "node_id": "PRRC_kwDOAPphoM56YGqY",
            "original_commit_id": "57efb41b60edea7a1d1c02c558efbaa01ef92d53",
            "original_line": 132,
            "original_position": 131,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 132,
            "pull_request_review_id": 2782460446,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053139096/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-22T00:19:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053139096",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053144875"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053144875"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This example might imply that document color should only be enabled on a buffer with a supported client, but that's not necessary indeed. Formerly I have a similar PR for `folding_range` for that, see https://github.com/neovim/neovim/pull/32896. Based on my experience observing reddit and github searches, this surprisingly has a large impact.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-22T00:29:35Z",
            "diff_hunk": "@@ -0,0 +1,379 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights\n+\n+--- @type table<integer, vim.lsp.document_color.BufState>\n+local bufstates = vim.defaulttable(function(_)\n+  return setmetatable({}, {\n+    __index = global_state,\n+    __newindex = function(state, key, value)\n+      if global_state[key] == value then\n+        rawset(state, key, nil)\n+      else\n+        rawset(state, key, value)\n+      end\n+    end,\n+  })\n+end)\n+\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Opts\n+---\n+--- Highlight style. It can be one of the pre-defined styles or a function that receives the buffer handle,\n+--- the range (start line, start col, end line, end col) and the resolved hex color.\n+--- Defaults to 'background'.\n+--- @field style? 'foreground'|'background'|'virtual'|fun(bufnr: integer, range: Range4, hex_code: string)\n+\n+-- Default options.\n+--- @type vim.lsp.document_color.enable.Opts\n+M._opts = { style = 'background' }\n+\n+--- @param color string\n+local function get_contrast_color(color)\n+  local r_s, g_s, b_s = color:match('^#(%x%x)(%x%x)(%x%x)$')\n+  local r, g, b = tonumber(r_s, 16), tonumber(g_s, 16), tonumber(b_s, 16)\n+\n+  local luminance = 0.298912 * r + 0.586611 * g + 0.114478 * b\n+  local is_bright_color = luminance > 127\n+  return is_bright_color and '#000000' or '#ffffff'\n+end\n+\n+--- Returns the hex string representing the given LSP color.\n+--- @param color lsp.Color\n+--- @return string\n+local function get_hex_code(color)\n+  -- The RGB values in lsp.Color are in the [0-1] range, but we want them to be in the [0-255] range instead.\n+  --- @param n number\n+  color = vim.tbl_map(function(n)\n+    return math.floor((n * 255) + 0.5)\n+  end, color)\n+\n+  return ('#%02x%02x%02x'):format(color.red, color.green, color.blue):lower()\n+end\n+\n+--- Cache of the highlight groups that we've already created.\n+--- @type table<string, true>\n+local color_cache = {}\n+\n+--- Gets or creates the highlight group for the given LSP color information.\n+---\n+--- @param hex_code string\n+--- @param style 'foreground'|'background'|'virtual'\n+--- @return string\n+local function get_hl_group(hex_code, style)\n+  local hl_name = ('LspDocumentColor_%s_%s'):format(hex_code:sub(2), style)\n+\n+  if not color_cache[hl_name] then\n+    if style == 'foreground' or style == 'virtual' then\n+      api.nvim_set_hl(0, hl_name, { fg = hex_code })\n+    elseif style == 'background' then\n+      api.nvim_set_hl(0, hl_name, { bg = hex_code, fg = get_contrast_color(hex_code) })\n+    end\n+\n+    color_cache[hl_name] = true\n+  end\n+\n+  return hl_name\n+end\n+\n+--- @param bufnr integer\n+local function buf_clear(bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_ids = vim.tbl_keys((bufstate or {}).hl_infos) --- @type integer[]\n+\n+  for _, id in ipairs(client_ids) do\n+    bufstate.hl_infos[id] = {}\n+  end\n+\n+  api.nvim_buf_clear_namespace(bufnr, document_color_ns, 0, -1)\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- @param bufnr integer\n+--- @param opts? vim.lsp.util._refresh.Opts\n+local function buf_refresh(bufnr, opts)\n+  opts = opts or {}\n+  opts.bufnr = bufnr\n+\n+  util._refresh(ms.textDocument_documentColor, opts)\n+end\n+\n+--- @param bufnr integer\n+local function buf_disable(bufnr)\n+  buf_clear(bufnr)\n+\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = false\n+end\n+\n+--- @param bufnr integer\n+local function buf_enable(bufnr)\n+  bufstates[bufnr] = nil\n+  bufstates[bufnr].enabled = true\n+\n+  api.nvim_create_autocmd('LspNotify', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Refresh document_color on document changes',\n+    callback = function(args)\n+      local method = args.data.method --- @type string\n+\n+      if\n+        (method == ms.textDocument_didChange or method == ms.textDocument_didOpen)\n+        and bufstates[args.buf].enabled\n+      then\n+        buf_refresh(args.buf, { client_id = args.data.client_id })\n+      end\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspAttach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Enable document_color when LSP client attaches',\n+    callback = function(args)\n+      api.nvim_buf_attach(args.buf, false, {\n+        on_reload = function(_, buf)\n+          buf_clear(buf)\n+          if bufstates[buf].enabled then\n+            buf_refresh(buf)\n+          end\n+        end,\n+        on_detach = function(_, buf)\n+          buf_disable(buf)\n+        end,\n+      })\n+    end,\n+  })\n+\n+  api.nvim_create_autocmd('LspDetach', {\n+    buffer = bufnr,\n+    group = document_color_augroup,\n+    desc = 'Disable document_color if all supporting clients detach',\n+    callback = function(args)\n+      local clients = lsp.get_clients({ bufnr = args.buf, method = ms.textDocument_documentColor })\n+\n+      if\n+        not vim.iter(clients):any(function(c)\n+          return c.id ~= args.data.client_id\n+        end)\n+      then\n+        -- There are no clients left in the buffer that support document color, so turn it off.\n+        buf_disable(args.buf)\n+      end\n+    end,\n+  })\n+\n+  buf_refresh(bufnr)\n+end\n+\n+--- |lsp-handler| for the `textDocument/documentColor` method.\n+---\n+--- @param err? lsp.ResponseError\n+--- @param result? lsp.ColorInformation[]\n+--- @param ctx lsp.HandlerContext\n+--- @nodoc\n+function M.on_document_color(err, result, ctx)\n+  if err then\n+    lsp.log.error('document_color', err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = bufstates[bufnr]\n+  local client_id = ctx.client_id\n+\n+  if\n+    util.buf_versions[bufnr] ~= ctx.version\n+    or not result\n+    or not api.nvim_buf_is_loaded(bufnr)\n+    or not bufstate.enabled\n+  then\n+    return\n+  end\n+\n+  if not bufstate.hl_infos or not bufstate.buf_version then\n+    bufstate.hl_infos = {}\n+    bufstate.buf_version = ctx.version\n+  end\n+\n+  local hl_infos = {}\n+  for _, res in ipairs(result) do\n+    local range = {\n+      res.range.start.line,\n+      res.range.start.character,\n+      res.range['end'].line,\n+      res.range['end'].character,\n+    }\n+    local hex_code = get_hex_code(res.color)\n+    local hl_info = { range = range, hex_code = hex_code }\n+\n+    if type(M._opts.style) == 'string' then\n+      hl_info.hl_group = get_hl_group(hex_code, M._opts.style --[[@as string]])\n+    end\n+\n+    table.insert(hl_infos, hl_info)\n+  end\n+  bufstate.hl_infos[client_id] = hl_infos\n+\n+  bufstate.buf_version = ctx.version\n+  api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+end\n+\n+--- Query whether document colors are enabled in the filtered scope.\n+---\n+--- @param filter? vim.lsp.document_color.enable.Filter\n+--- @return boolean\n+function M.is_enabled(filter)\n+  vim.validate('filter', filter, 'table', true)\n+\n+  filter = filter or {}\n+  local bufnr = filter.bufnr\n+\n+  if bufnr == nil then\n+    return global_state.enabled\n+  else\n+    return bufstates[vim._resolve_bufnr(bufnr)].enabled\n+  end\n+end\n+\n+--- Optional filters |kwargs|, or `nil` for all.\n+--- @inlinedoc\n+--- @class vim.lsp.document_color.enable.Filter\n+---\n+--- Buffer number, or 0 for current buffer, or nil for all.\n+--- @field bufnr? integer\n+\n+--- Enables document highlighting from the given language client in the given buffer.\n+---\n+--- You can enable document highlighting from a supporting client as follows:\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspAttach', {\n+---   callback = function(args)\n+---     local client = vim.lsp.get_client_by_id(args.data.client_id)\n+---\n+---     if client:supports_method('textDocument/documentColor')\n+---       vim.lsp.document_color.enable(true, { bufnr = args.buf })\n+---     end\n+---   end\n+--- })\n+--- ```\n+---",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053144875",
            "id": 2053144875,
            "line": 279,
            "node_id": "PRRC_kwDOAPphoM56YIEr",
            "original_commit_id": "57efb41b60edea7a1d1c02c558efbaa01ef92d53",
            "original_line": 279,
            "original_position": 278,
            "original_start_line": 267,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 279,
            "pull_request_review_id": 2782468240,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053144875/reactions"
            },
            "side": "RIGHT",
            "start_line": 268,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-22T00:29:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053144875",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053154553"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053154553"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "There is a vulnerability; after the first client responds, `buf_version` and `applied_version` will be updated to sync. Considering we want multiple client support, this should not be expected, because the synced `applied_version` and `buf_version` will avoid the `decoration_provider` setting extmarks. This means only the first client's response will be shown on the buffer\r\n\r\nWe may have to track `applied_version` separately for every client.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-22T00:47:31Z",
            "diff_hunk": "@@ -0,0 +1,382 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053154553",
            "id": 2053154553,
            "line": 20,
            "node_id": "PRRC_kwDOAPphoM56YKb5",
            "original_commit_id": "64a610788aa7dd43dceb6f316d637f45d67180bc",
            "original_line": 20,
            "original_position": 20,
            "original_start_line": 18,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 20,
            "pull_request_review_id": 2782482055,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053154553/reactions"
            },
            "side": "RIGHT",
            "start_line": 18,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-22T00:53:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053154553",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33440#discussion_r2053159509"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33440"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053159509"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> We may have to track `applied_version` separately for every client.\r\n\r\nOut of topic, I'm planning to refactor `inlay_hint.lua` to this pattern.",
            "commit_id": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
            "created_at": "2025-04-22T00:56:10Z",
            "diff_hunk": "@@ -0,0 +1,382 @@\n+local api = vim.api\n+local lsp = vim.lsp\n+local util = lsp.util\n+local ms = lsp.protocol.Methods\n+\n+local document_color_ns = api.nvim_create_namespace('nvim.lsp.document_color')\n+local document_color_augroup = api.nvim_create_augroup('nvim.lsp.document_color', {})\n+\n+local M = {}\n+\n+--- @alias vim.lsp.document_color.HighlightInfo { hex_code: string, hl_group?: string, range: Range4 }\n+\n+--- @class (private) vim.lsp.document_color.GlobalState\n+--- @field enabled boolean\n+local global_state = { enabled = false }\n+\n+--- @class (private) vim.lsp.document_color.BufState : vim.lsp.document_color.GlobalState\n+--- @field buf_version? integer Buffer version for which the color ranges correspond to.\n+--- @field applied_version? integer Last buffer version for which we applied color ranges.\n+--- @field hl_infos? table<integer, vim.lsp.document_color.HighlightInfo[]> client_id -> processed color highlights",
            "html_url": "https://github.com/neovim/neovim/pull/33440#discussion_r2053159509",
            "id": 2053159509,
            "in_reply_to_id": 2053154553,
            "line": 20,
            "node_id": "PRRC_kwDOAPphoM56YLpV",
            "original_commit_id": "64a610788aa7dd43dceb6f316d637f45d67180bc",
            "original_line": 20,
            "original_position": 20,
            "original_start_line": 18,
            "path": "runtime/lua/vim/lsp/document_color.lua",
            "position": 20,
            "pull_request_review_id": 2782489510,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053159509/reactions"
            },
            "side": "RIGHT",
            "start_line": 18,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-22T00:56:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2053159509",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "NONE",
            "body": "can the ui here be customized? i.e. [inlay color blocks](https://github.com/bennypowers/document-color.nvim/blob/9ecc30d188c5a223e3d498377d93a6a893315c48/lua/document-color.lua#L60-L63)?",
            "created_at": "2025-04-15T18:21:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/33440#issuecomment-2807099044",
            "id": 2807099044,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/33440",
            "node_id": "IC_kwDOAPphoM6nUO6k",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2807099044/reactions"
            },
            "updated_at": "2025-04-21T11:31:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2807099044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1466420?v=4",
                "events_url": "https://api.github.com/users/bennypowers/events{/privacy}",
                "followers_url": "https://api.github.com/users/bennypowers/followers",
                "following_url": "https://api.github.com/users/bennypowers/following{/other_user}",
                "gists_url": "https://api.github.com/users/bennypowers/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bennypowers",
                "id": 1466420,
                "login": "bennypowers",
                "node_id": "MDQ6VXNlcjE0NjY0MjA=",
                "organizations_url": "https://api.github.com/users/bennypowers/orgs",
                "received_events_url": "https://api.github.com/users/bennypowers/received_events",
                "repos_url": "https://api.github.com/users/bennypowers/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bennypowers/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bennypowers/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bennypowers",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/33440/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/33440/commits",
    "created_at": "2025-04-12T20:56:30Z",
    "diff_url": "https://github.com/neovim/neovim/pull/33440.diff",
    "draft": false,
    "head": {
        "label": "MariaSolOs:document-color",
        "ref": "document-color",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/MariaSolOs/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/MariaSolOs/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/MariaSolOs/neovim/branches{/branch}",
            "clone_url": "https://github.com/MariaSolOs/neovim.git",
            "collaborators_url": "https://api.github.com/repos/MariaSolOs/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/MariaSolOs/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/MariaSolOs/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/MariaSolOs/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/MariaSolOs/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/MariaSolOs/neovim/contributors",
            "created_at": "2023-08-05T17:10:58Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/MariaSolOs/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/MariaSolOs/neovim/downloads",
            "events_url": "https://api.github.com/repos/MariaSolOs/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/MariaSolOs/neovim/forks",
            "full_name": "MariaSolOs/neovim",
            "git_commits_url": "https://api.github.com/repos/MariaSolOs/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/MariaSolOs/neovim/git/tags{/sha}",
            "git_url": "git://github.com/MariaSolOs/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/MariaSolOs/neovim/hooks",
            "html_url": "https://github.com/MariaSolOs/neovim",
            "id": 675070403,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/MariaSolOs/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/MariaSolOs/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/MariaSolOs/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/MariaSolOs/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/MariaSolOs/neovim/merges",
            "milestones_url": "https://api.github.com/repos/MariaSolOs/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOKDzBww",
            "notifications_url": "https://api.github.com/repos/MariaSolOs/neovim/notifications{?since,all,participating}",
            "open_issues": 1,
            "open_issues_count": 1,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/MariaSolOs/neovim/pulls{/number}",
            "pushed_at": "2025-04-22T02:41:28Z",
            "releases_url": "https://api.github.com/repos/MariaSolOs/neovim/releases{/id}",
            "size": 309537,
            "ssh_url": "git@github.com:MariaSolOs/neovim.git",
            "stargazers_count": 2,
            "stargazers_url": "https://api.github.com/repos/MariaSolOs/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/MariaSolOs/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/MariaSolOs/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/MariaSolOs/neovim/subscription",
            "svn_url": "https://github.com/MariaSolOs/neovim",
            "tags_url": "https://api.github.com/repos/MariaSolOs/neovim/tags",
            "teams_url": "https://api.github.com/repos/MariaSolOs/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/MariaSolOs/neovim/git/trees{/sha}",
            "updated_at": "2025-04-20T08:40:37Z",
            "url": "https://api.github.com/repos/MariaSolOs/neovim",
            "visibility": "public",
            "watchers": 2,
            "watchers_count": 2,
            "web_commit_signoff_required": false
        },
        "sha": "f3c812f9c79556eb8ce8c13f0548457627012dd8",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/33440",
    "id": 2455615747,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/33440",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": false,
    "merge_commit_sha": "f0c016d6f4f5873ba45e257356b0a08fbe69a14c",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6SXbkD",
    "number": 33440,
    "patch_url": "https://github.com/neovim/neovim/pull/33440.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
            "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
            "followers_url": "https://api.github.com/users/mfussenegger/followers",
            "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
            "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/mfussenegger",
            "id": 38700,
            "login": "mfussenegger",
            "node_id": "MDQ6VXNlcjM4NzAw",
            "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
            "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
            "repos_url": "https://api.github.com/users/mfussenegger/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/mfussenegger",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/33440/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/f3c812f9c79556eb8ce8c13f0548457627012dd8",
    "title": "feat(lsp): support `textDocument/documentColor`",
    "updated_at": "2025-04-22T02:41:30Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/33440",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
        "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
        "followers_url": "https://api.github.com/users/MariaSolOs/followers",
        "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
        "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/MariaSolOs",
        "id": 62502207,
        "login": "MariaSolOs",
        "node_id": "MDQ6VXNlcjYyNTAyMjA3",
        "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
        "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
        "repos_url": "https://api.github.com/users/MariaSolOs/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/MariaSolOs",
        "user_view_type": "public"
    }
}