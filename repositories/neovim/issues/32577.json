{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "body": "### Problem\n\nI caught this error when testing #32142 \n\n![Image](https://github.com/user-attachments/assets/abddd563-b1c3-4ded-9852-00d7bd6a6d28)\n\n```\nError in decoration provider nvim.treesitter.highlighter.line:\nError executing lua: ...ev/share/nvim/runtime/lua/vim/treesitter/highlighter.lua:334: Invalid 'col': out of range\nstack traceback:\n        [C]: in function 'nvim_buf_set_extmark'\n        ...ev/share/nvim/runtime/lua/vim/treesitter/highlighter.lua:334: in function 'fn'\n        ...ev/share/nvim/runtime/lua/vim/treesitter/highlighter.lua:212: in function 'for_each_highlight_state'\n        ...ev/share/nvim/runtime/lua/vim/treesitter/highlighter.lua:286: in function 'on_line_impl'\n        ...ev/share/nvim/runtime/lua/vim/treesitter/highlighter.lua:364: in function <...ev/share/nvim/runtime/lua/vim/t\nreesitter/highlighter.lua:358>\n```\n\nbut it can be reproduced on the current master 5cead869fb6ddc57594c0dc7e6e575f9427630c8 with only vim.lsp.completion changed.\n\n\n### Steps to reproduce\n\n<details>\n\n<summary>completion.lua from https://github.com/neovim/neovim/pull/32142/commits/b76773f8a6e1a201240187acc56ff8af4a4aadef</summary>\n\n```lua\nlocal M = {}\n\nlocal api = vim.api\nlocal lsp = vim.lsp\nlocal protocol = lsp.protocol\nlocal ms = protocol.Methods\n\nlocal rtt_ms = 50\nlocal ns_to_ms = 0.000001\n\n--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n\n-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n--- @nodoc\n--- @class lsp.ItemDefaults\n--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n--- @field insertTextFormat lsp.InsertTextFormat?\n--- @field insertTextMode lsp.InsertTextMode?\n--- @field data any\n\n--- @nodoc\n--- @class vim.lsp.completion.BufHandle\n--- @field clients table<integer, vim.lsp.Client>\n--- @field triggers table<string, vim.lsp.Client[]>\n--- @field convert? fun(item: lsp.CompletionItem): table\n\n--- @type table<integer, vim.lsp.completion.BufHandle>\nlocal buf_handles = {}\n\n--- @nodoc\n--- @class vim.lsp.completion.Context\nlocal Context = {\n  cursor = nil, --- @type [integer, integer]?\n  last_request_time = nil, --- @type integer?\n  pending_requests = {}, --- @type function[]\n  isIncomplete = false,\n}\n\n--- @nodoc\nfunction Context:cancel_pending()\n  for _, cancel in ipairs(self.pending_requests) do\n    cancel()\n  end\n\n  self.pending_requests = {}\nend\n\n--- @nodoc\nfunction Context:reset()\n  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n  self.isIncomplete = false\n  self.last_request_time = nil\n  self:cancel_pending()\nend\n\n--- @type uv.uv_timer_t?\nlocal completion_timer = nil\n\n--- @return uv.uv_timer_t\nlocal function new_timer()\n  return assert(vim.uv.new_timer())\nend\n\nlocal function reset_timer()\n  if completion_timer then\n    completion_timer:stop()\n    completion_timer:close()\n  end\n\n  completion_timer = nil\nend\n\n--- @param window integer\n--- @param warmup integer\n--- @return fun(sample: number): number\nlocal function exp_avg(window, warmup)\n  local count = 0\n  local sum = 0\n  local value = 0\n\n  return function(sample)\n    if count < warmup then\n      count = count + 1\n      sum = sum + sample\n      value = sum / count\n    else\n      local factor = 2.0 / (window + 1)\n      value = value * (1 - factor) + sample * factor\n    end\n    return value\n  end\nend\nlocal compute_new_average = exp_avg(10, 10)\n\n--- @return number\nlocal function next_debounce()\n  if not Context.last_request_time then\n    return rtt_ms\n  end\n\n  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n  return math.max((ms_since_request - rtt_ms) * -1, 0)\nend\n\n--- @param input string Unparsed snippet\n--- @return string # Parsed snippet if successful, else returns its input\nlocal function parse_snippet(input)\n  local ok, parsed = pcall(function()\n    return lsp._snippet_grammar.parse(input)\n  end)\n  return ok and tostring(parsed) or input\nend\n\n--- @param item lsp.CompletionItem\nlocal function apply_snippet(item)\n  if item.textEdit then\n    vim.snippet.expand(item.textEdit.newText)\n  elseif item.insertText then\n    vim.snippet.expand(item.insertText)\n  end\nend\n\n--- Returns text that should be inserted when a selecting completion item. The\n--- precedence is as follows: textEdit.newText > insertText > label\n---\n--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n---\n--- @param item lsp.CompletionItem\n--- @param prefix string\n--- @param match fun(text: string, prefix: string):boolean\n--- @return string\nlocal function get_completion_word(item, prefix, match)\n  if item.insertTextFormat == protocol.InsertTextFormat.Snippet then\n    if item.textEdit then\n      -- Use label instead of text if text has different starting characters.\n      -- label is used as abbr (=displayed), but word is used for filtering\n      -- This is required for things like postfix completion.\n      -- E.g. in lua:\n      --\n      --    local f = {}\n      --    f@|\n      --      ‚ñ≤\n      --      ‚îî‚îÄ cursor\n      --\n      --    item.textEdit.newText: table.insert(f, $0)\n      --    label: insert\n      --\n      -- Typing `i` would remove the candidate because newText starts with `t`.\n      local text = parse_snippet(item.insertText or item.textEdit.newText)\n      local word = #text < #item.label and vim.fn.matchstr(text, '\\\\k*') or item.label\n      if item.filterText and not match(word, prefix) then\n        return item.filterText\n      else\n        return word\n      end\n    elseif item.insertText and item.insertText ~= '' then\n      return parse_snippet(item.insertText)\n    else\n      return item.label\n    end\n  elseif item.textEdit then\n    local word = item.textEdit.newText\n    word = word:match('^(%S*)') or word\n    if item.filterText and not match(word, prefix) then\n      return item.filterText\n    end\n    return word\n  elseif item.insertText and item.insertText ~= '' then\n    return item.insertText\n  end\n  return item.label\nend\n\n--- Applies the given defaults to the completion item, modifying it in place.\n---\n--- @param item lsp.CompletionItem\n--- @param defaults lsp.ItemDefaults?\nlocal function apply_defaults(item, defaults)\n  if not defaults then\n    return\n  end\n\n  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n  item.data = item.data or defaults.data\n  if defaults.editRange then\n    local textEdit = item.textEdit or {}\n    item.textEdit = textEdit\n    textEdit.newText = textEdit.newText or item.textEditText or item.insertText or item.label\n    if defaults.editRange.start then\n      textEdit.range = textEdit.range or defaults.editRange\n    elseif defaults.editRange.insert then\n      textEdit.insert = defaults.editRange.insert\n      textEdit.replace = defaults.editRange.replace\n    end\n  end\nend\n\n--- @param result vim.lsp.CompletionResult\n--- @return lsp.CompletionItem[]\nlocal function get_items(result)\n  if result.items then\n    -- When we have a list, apply the defaults and return an array of items.\n    for _, item in ipairs(result.items) do\n      ---@diagnostic disable-next-line: param-type-mismatch\n      apply_defaults(item, result.itemDefaults)\n    end\n    return result.items\n  else\n    -- Else just return the items as they are.\n    return result\n  end\nend\n\n---@param item lsp.CompletionItem\n---@return string\nlocal function get_doc(item)\n  local doc = item.documentation\n  if not doc then\n    return ''\n  end\n  if type(doc) == 'string' then\n    return doc\n  end\n  if type(doc) == 'table' and type(doc.value) == 'string' then\n    return doc.value\n  end\n\n  vim.notify('invalid documentation value: ' .. vim.inspect(doc), vim.log.levels.WARN)\n  return ''\nend\n\n---@param value string\n---@param prefix string\n---@return boolean\nlocal function match_item_by_value(value, prefix)\n  if prefix == '' then\n    return true\n  end\n  if vim.o.completeopt:find('fuzzy') ~= nil then\n    return next(vim.fn.matchfuzzy({ value }, prefix)) ~= nil\n  end\n\n  if vim.o.ignorecase and (not vim.o.smartcase or not prefix:find('%u')) then\n    return vim.startswith(value:lower(), prefix:lower())\n  end\n  return vim.startswith(value, prefix)\nend\n\n--- Turns the result of a `textDocument/completion` request into vim-compatible\n--- |complete-items|.\n---\n--- @private\n--- @param result vim.lsp.CompletionResult Result of `textDocument/completion`\n--- @param prefix string prefix to filter the completion items\n--- @param client_id integer? Client ID\n--- @return table[]\n--- @see complete-items\nfunction M._lsp_to_complete_items(result, prefix, client_id)\n  local items = get_items(result)\n  if vim.tbl_isempty(items) then\n    return {}\n  end\n\n  ---@type fun(item: lsp.CompletionItem):boolean\n  local matches\n  if not prefix:find('%w') then\n    matches = function(_)\n      return true\n    end\n  else\n    ---@param item lsp.CompletionItem\n    matches = function(item)\n      if item.filterText then\n        return match_item_by_value(item.filterText, prefix)\n      end\n\n      if item.textEdit then\n        -- server took care of filtering\n        return true\n      end\n\n      return match_item_by_value(item.label, prefix)\n    end\n  end\n\n  local candidates = {}\n  local bufnr = api.nvim_get_current_buf()\n  local user_convert = vim.tbl_get(buf_handles, bufnr, 'convert')\n  for _, item in ipairs(items) do\n    if matches(item) then\n      local word = get_completion_word(item, prefix, match_item_by_value)\n      local hl_group = ''\n      if\n        item.deprecated\n        or vim.list_contains((item.tags or {}), protocol.CompletionTag.Deprecated)\n      then\n        hl_group = 'DiagnosticDeprecated'\n      end\n      local completion_item = {\n        word = word,\n        abbr = item.label,\n        kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n        menu = item.detail or '',\n        info = get_doc(item),\n        icase = 1,\n        dup = 1,\n        empty = 1,\n        abbr_hlgroup = hl_group,\n        user_data = {\n          nvim = {\n            lsp = {\n              completion_item = item,\n              client_id = client_id,\n            },\n          },\n        },\n      }\n      if user_convert then\n        completion_item = vim.tbl_extend('keep', user_convert(item), completion_item)\n      end\n      table.insert(candidates, completion_item)\n    end\n  end\n  ---@diagnostic disable-next-line: no-unknown\n  table.sort(candidates, function(a, b)\n    ---@type lsp.CompletionItem\n    local itema = a.user_data.nvim.lsp.completion_item\n    ---@type lsp.CompletionItem\n    local itemb = b.user_data.nvim.lsp.completion_item\n    return (itema.sortText or itema.label) < (itemb.sortText or itemb.label)\n  end)\n\n  return candidates\nend\n\n--- @param lnum integer 0-indexed\n--- @param line string\n--- @param items lsp.CompletionItem[]\n--- @param encoding string\n--- @return integer?\nlocal function adjust_start_col(lnum, line, items, encoding)\n  local min_start_char = nil\n  for _, item in pairs(items) do\n    if item.textEdit and item.textEdit.range.start.line == lnum then\n      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n        return nil\n      end\n      min_start_char = item.textEdit.range.start.character\n    end\n  end\n  if min_start_char then\n    return vim.str_byteindex(line, encoding, min_start_char, false)\n  else\n    return nil\n  end\nend\n\n--- @private\n--- @param line string line content\n--- @param lnum integer 0-indexed line number\n--- @param cursor_col integer\n--- @param client_id integer client ID\n--- @param client_start_boundary integer 0-indexed word boundary\n--- @param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n--- @param result vim.lsp.CompletionResult\n--- @param encoding string\n--- @return table[] matches\n--- @return integer? server_start_boundary\nfunction M._convert_results(\n  line,\n  lnum,\n  cursor_col,\n  client_id,\n  client_start_boundary,\n  server_start_boundary,\n  result,\n  encoding\n)\n  -- Completion response items may be relative to a position different than `client_start_boundary`.\n  -- Concrete example, with lua-language-server:\n  --\n  -- require('plenary.asy|\n  --         ‚ñ≤       ‚ñ≤   ‚ñ≤\n  --         ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ cursor_pos:                     20\n  --         ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ client_start_boundary:          17\n  --         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ textEdit.range.start.character: 9\n  --                                 .newText = 'plenary.async'\n  --                  ^^^\n  --                  prefix (We'd remove everything not starting with `asy`,\n  --                  so we'd eliminate the `plenary.async` result\n  --\n  -- `adjust_start_col` is used to prefer the language server boundary.\n  --\n  local candidates = get_items(result)\n  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n  if server_start_boundary == nil then\n    server_start_boundary = curstartbyte\n  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n    server_start_boundary = client_start_boundary\n  end\n  local prefix = line:sub(\n    Context.cursor and Context.cursor[2] + 1 or (server_start_boundary or client_start_boundary) + 1,\n    cursor_col\n  )\n  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n  return matches, server_start_boundary\nend\n\n--- @param clients table<integer, vim.lsp.Client> # keys != client_id\n--- @param bufnr integer\n--- @param win integer\n--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n--- @return function # Cancellation function\nlocal function request(clients, bufnr, win, callback)\n  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n  local request_ids = {} --- @type table<integer, integer>\n  local remaining_requests = vim.tbl_count(clients)\n\n  for _, client in pairs(clients) do\n    local client_id = client.id\n    local params = lsp.util.make_position_params(win, client.offset_encoding)\n    local ok, request_id = client:request(ms.textDocument_completion, params, function(err, result)\n      responses[client_id] = { err = err, result = result }\n      remaining_requests = remaining_requests - 1\n      if remaining_requests == 0 then\n        callback(responses)\n      end\n    end, bufnr)\n\n    if ok then\n      request_ids[client_id] = request_id\n    end\n  end\n\n  return function()\n    for client_id, request_id in pairs(request_ids) do\n      local client = lsp.get_client_by_id(client_id)\n      if client then\n        client:cancel_request(request_id)\n      end\n    end\n  end\nend\n\nlocal function trigger(bufnr, clients)\n  reset_timer()\n  Context:cancel_pending()\n\n  if tonumber(vim.fn.pumvisible()) == 1 and not Context.isIncomplete then\n    return\n  end\n\n  local win = api.nvim_get_current_win()\n  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(win)) --- @type integer, integer\n  local line = api.nvim_get_current_line()\n  local line_to_cursor = line:sub(1, cursor_col)\n  local word_boundary = vim.fn.match(line_to_cursor, '\\\\k*$')\n  local start_time = vim.uv.hrtime()\n  Context.last_request_time = start_time\n\n  local cancel_request = request(clients, bufnr, win, function(responses)\n    local end_time = vim.uv.hrtime()\n    rtt_ms = compute_new_average((end_time - start_time) * ns_to_ms)\n\n    Context.pending_requests = {}\n    Context.isIncomplete = false\n\n    local row_changed = api.nvim_win_get_cursor(win)[1] ~= cursor_row\n    local mode = api.nvim_get_mode().mode\n    if row_changed or not (mode == 'i' or mode == 'ic') then\n      return\n    end\n\n    local matches = {}\n    local server_start_boundary --- @type integer?\n    for client_id, response in pairs(responses) do\n      if response.err then\n        vim.notify_once(response.err.message, vim.log.levels.WARN)\n      end\n\n      local result = response.result\n      if result then\n        Context.isIncomplete = Context.isIncomplete or result.isIncomplete\n        local client = lsp.get_client_by_id(client_id)\n        local encoding = client and client.offset_encoding or 'utf-16'\n        local client_matches\n        client_matches, server_start_boundary = M._convert_results(\n          line,\n          cursor_row - 1,\n          cursor_col,\n          client_id,\n          word_boundary,\n          nil,\n          result,\n          encoding\n        )\n        vim.list_extend(matches, client_matches)\n      end\n    end\n    if #matches == 0 then\n      return\n    end\n    local start_col = (server_start_boundary or word_boundary) + 1\n    Context.cursor = { cursor_row, start_col }\n    vim.fn.complete(start_col, matches)\n  end)\n\n  table.insert(Context.pending_requests, cancel_request)\nend\n\n--- @param handle vim.lsp.completion.BufHandle\nlocal function on_insert_char_pre(handle)\n  if tonumber(vim.fn.pumvisible()) == 1 then\n    if Context.isIncomplete then\n      reset_timer()\n\n      local debounce_ms = next_debounce()\n      if debounce_ms == 0 then\n        vim.schedule(M.trigger)\n      else\n        completion_timer = new_timer()\n        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n      end\n    end\n\n    return\n  end\n\n  local char = api.nvim_get_vvar('char')\n  local matched_clients = handle.triggers[char]\n  if not completion_timer and matched_clients then\n    completion_timer = assert(vim.uv.new_timer())\n    completion_timer:start(25, 0, function()\n      reset_timer()\n      vim.schedule(function()\n        trigger(api.nvim_get_current_buf(), matched_clients)\n      end)\n    end)\n  end\nend\n\nlocal function on_insert_leave()\n  reset_timer()\n  Context.cursor = nil\n  Context:reset()\nend\n\nlocal function on_complete_done()\n  local completed_item = api.nvim_get_vvar('completed_item')\n  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n    Context:reset()\n    return\n  end\n\n  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n  cursor_row = cursor_row - 1\n  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n  if not completion_item or not client_id then\n    Context:reset()\n    return\n  end\n\n  local bufnr = api.nvim_get_current_buf()\n  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n\n  Context:reset()\n\n  local client = lsp.get_client_by_id(client_id)\n  if not client then\n    return\n  end\n\n  local position_encoding = client.offset_encoding or 'utf-16'\n  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n\n  local function clear_word()\n    if not expand_snippet and not completion_item.textEdit then\n      return nil\n    end\n\n    -- Remove the already inserted word.\n    api.nvim_buf_set_text(\n      bufnr,\n      Context.cursor[1] - 1,\n      Context.cursor[2] - 1,\n      cursor_row,\n      cursor_col,\n      { '' }\n    )\n  end\n\n  local function apply_snippet_and_command()\n    if expand_snippet then\n      apply_snippet(completion_item)\n    end\n\n    local command = completion_item.command\n    if command then\n      client:exec_cmd(command, { bufnr = bufnr })\n    end\n  end\n\n  if completion_item.additionalTextEdits and next(completion_item.additionalTextEdits) then\n    clear_word()\n    lsp.util.apply_text_edits(completion_item.additionalTextEdits, bufnr, position_encoding)\n    apply_snippet_and_command()\n  elseif resolve_provider and type(completion_item) == 'table' then\n    local changedtick = vim.b[bufnr].changedtick\n\n    --- @param result lsp.CompletionItem\n    client:request(ms.completionItem_resolve, completion_item, function(err, result)\n      if changedtick ~= vim.b[bufnr].changedtick then\n        return\n      end\n\n      clear_word()\n      if err then\n        vim.notify_once(err.message, vim.log.levels.WARN)\n      elseif result then\n        if result.additionalTextEdits then\n          lsp.util.apply_text_edits(result.additionalTextEdits, bufnr, position_encoding)\n        end\n        if result.command then\n          completion_item.command = result.command\n        end\n      end\n      apply_snippet_and_command()\n    end, bufnr)\n  elseif\n    completion_item.textEdit\n    and completion_item.insertTextFormat ~= lsp.protocol.InsertTextFormat.Snippet\n  then\n    clear_word()\n    ---@diagnostic disable-next-line: assign-type-mismatch\n    lsp.util.apply_text_edits({ completion_item.textEdit }, bufnr, position_encoding)\n    api.nvim_win_set_cursor(0, {\n      cursor_row + 1,\n      Context.cursor[2] + vim.fn.strdisplaywidth(completion_item.textEdit.newText),\n    })\n  else\n    clear_word()\n    apply_snippet_and_command()\n  end\nend\n\n---@param bufnr integer\n---@return string\nlocal function get_augroup(bufnr)\n  return string.format('nvim.lsp.completion_%d', bufnr)\nend\n\n--- @class vim.lsp.completion.BufferOpts\n--- @field autotrigger? boolean  Default: false When true, completion triggers automatically based on the server's `triggerCharacters`.\n--- @field convert? fun(item: lsp.CompletionItem): table Transforms an LSP CompletionItem to |complete-items|.\n\n---@param client_id integer\n---@param bufnr integer\n---@param opts vim.lsp.completion.BufferOpts\nlocal function enable_completions(client_id, bufnr, opts)\n  local buf_handle = buf_handles[bufnr]\n  if not buf_handle then\n    buf_handle = { clients = {}, triggers = {}, convert = opts.convert }\n    buf_handles[bufnr] = buf_handle\n\n    -- Attach to buffer events.\n    api.nvim_buf_attach(bufnr, false, {\n      on_detach = function(_, buf)\n        buf_handles[buf] = nil\n      end,\n      on_reload = function(_, buf)\n        M.enable(true, client_id, buf, opts)\n      end,\n    })\n\n    -- Set up autocommands.\n    local group = api.nvim_create_augroup(get_augroup(bufnr), { clear = true })\n    api.nvim_create_autocmd('CompleteDone', {\n      group = group,\n      buffer = bufnr,\n      callback = function()\n        local e = api.nvim_get_vvar('event')\n        if e.reason and e.reason == 'accept' then\n          on_complete_done()\n        end\n        if e.complete_type ~= 'omni' and e.reason == 'cancel' then\n          Context.cursor = nil\n        end\n      end,\n    })\n    if opts.autotrigger then\n      api.nvim_create_autocmd('InsertCharPre', {\n        group = group,\n        buffer = bufnr,\n        callback = function()\n          on_insert_char_pre(buf_handles[bufnr])\n        end,\n      })\n      api.nvim_create_autocmd('InsertLeave', {\n        group = group,\n        buffer = bufnr,\n        callback = on_insert_leave,\n      })\n    end\n  end\n\n  if not buf_handle.clients[client_id] then\n    local client = lsp.get_client_by_id(client_id)\n    assert(client, 'invalid client ID')\n\n    -- Add the new client to the buffer's clients.\n    buf_handle.clients[client_id] = client\n\n    -- Add the new client to the clients that should be triggered by its trigger characters.\n    --- @type string[]\n    local triggers = vim.tbl_get(\n      client.server_capabilities,\n      'completionProvider',\n      'triggerCharacters'\n    ) or {}\n    for _, char in ipairs(triggers) do\n      local clients_for_trigger = buf_handle.triggers[char]\n      if not clients_for_trigger then\n        clients_for_trigger = {}\n        buf_handle.triggers[char] = clients_for_trigger\n      end\n      local client_exists = vim.iter(clients_for_trigger):any(function(c)\n        return c.id == client_id\n      end)\n      if not client_exists then\n        table.insert(clients_for_trigger, client)\n      end\n    end\n  end\nend\n\n--- @param client_id integer\n--- @param bufnr integer\nlocal function disable_completions(client_id, bufnr)\n  local handle = buf_handles[bufnr]\n  if not handle then\n    return\n  end\n\n  handle.clients[client_id] = nil\n  if not next(handle.clients) then\n    buf_handles[bufnr] = nil\n    api.nvim_del_augroup_by_name(get_augroup(bufnr))\n  else\n    for char, clients in pairs(handle.triggers) do\n      --- @param c vim.lsp.Client\n      handle.triggers[char] = vim.tbl_filter(function(c)\n        return c.id ~= client_id\n      end, clients)\n    end\n  end\nend\n\n--- Enables or disables completions from the given language client in the given buffer.\n---\n--- @param enable boolean True to enable, false to disable\n--- @param client_id integer Client ID\n--- @param bufnr integer Buffer handle, or 0 for the current buffer\n--- @param opts? vim.lsp.completion.BufferOpts\nfunction M.enable(enable, client_id, bufnr, opts)\n  bufnr = vim._resolve_bufnr(bufnr)\n\n  if enable then\n    enable_completions(client_id, bufnr, opts or {})\n  else\n    disable_completions(client_id, bufnr)\n  end\nend\n\n--- Trigger LSP completion in the current buffer.\nfunction M.trigger()\n  local bufnr = api.nvim_get_current_buf()\n  local clients = (buf_handles[bufnr] or {}).clients or {}\n  trigger(bufnr, clients)\nend\n\n--- Implements 'omnifunc' compatible LSP completion.\n---\n--- @see |complete-functions|\n--- @see |complete-items|\n--- @see |CompleteDone|\n---\n--- @param findstart integer 0 or 1, decides behavior\n--- @param base integer findstart=0, text to match against\n---\n--- @return integer|table Decided by {findstart}:\n--- - findstart=0: column where the completion starts, or -2 or -3\n--- - findstart=1: list of matches (actually just calls |complete()|)\nfunction M._omnifunc(findstart, base)\n  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n  assert(base) -- silence luals\n  local bufnr = api.nvim_get_current_buf()\n  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n  local remaining = #clients\n  if remaining == 0 then\n    return findstart == 1 and -1 or {}\n  end\n\n  trigger(bufnr, clients)\n\n  -- Return -2 to signal that we should continue completion so that we can\n  -- async complete.\n  return -2\nend\n\nreturn M\n```\n</details>\n\n<details>\n\n<summary>init.lua</summary>\n\n```lua\nlocal function createServer(opts)\n  opts = opts or {}\n  local server = {}\n  server.messages = {}\n\n  function server.cmd(dispatchers)\n    local closing = false\n    local handlers = opts.handlers or {}\n    local srv = {}\n\n    function srv.request(method, params, callback)\n      table.insert(server.messages, {\n        method = method,\n        params = params,\n      })\n      local handler = handlers[method]\n      if handler then\n        handler(method, params, callback)\n      elseif method == 'initialize' then\n        callback(nil, {\n          capabilities = opts.capabilities or {},\n        })\n      elseif method == 'shutdown' then\n        callback(nil, nil)\n      end\n      local request_id = #server.messages\n      return true, request_id\n    end\n\n    function srv.notify(method, params)\n      table.insert(server.messages, {\n        method = method,\n        params = params,\n      })\n      if method == 'exit' then\n        dispatchers.on_exit(0, 15)\n      end\n    end\n\n    function srv.is_closing()\n      return closing\n    end\n\n    function srv.terminate()\n      closing = true\n    end\n\n    return srv\n  end\n\n  return server\nend\n\nlocal completionResultPhpactor = {\n  isIncomplete = false,\n  items = {\n    {\n      additionalTextEdits = {{\n        newText = 'use ReturnTypeWillChange;\\n',\n        range = {\n          ['end'] = {\n            character = 0,\n            line = 1\n          },\n          start = {\n            character = 0,\n            line = 1\n          }\n        },\n      }},\n      label = 'return',\n      insertText = 'return $1;$0',\n      kind = vim.lsp.protocol.CompletionItemKind.Keyword,\n      insertTextFormat = vim.lsp.protocol.InsertTextFormat.Snippet,\n      detail = 'return ...',\n      sortText = '-255-return ',\n    },\n  },\n}\n\nlocal fun = table.concat({\n  '${1|public,private,protected|} static function ${2:name}($3): ${4:void}',\n  '{$0',\n  '}',\n}, '\\n')\n\nlocal textEdit = {\n  range = {\n    start = {line = 0, character = 0},\n    ['end'] = {line = 0, character = 2},\n  },\n  newText = fun,\n}\n\nlocal completionResultNullLs = {\n  isIncomplete = false,\n  items = {\n    {\n      label = '/**',\n      insertText = '/** ${1:hello} */',\n      insertTextFormat = 2,\n      kind = 15,\n      detail = 'Snippet with non-word label',\n    },\n    {\n      label = 'f',\n      insertText = fun,\n      insertTextFormat = 2,\n      kind = 15,\n      detail = 'Multiline snippet',\n    },\n    {\n      label = 'fu',\n      kind = vim.lsp.protocol.CompletionItemKind.Snippet,\n      insertTextFormat = vim.lsp.protocol.InsertTextFormat.Snippet,\n      detail = 'Multiline with textEdit',\n      insertText = insertText,\n      textEdit = textEdit,\n    }\n  },\n}\n\nlocal function createServerWithCompletionProvider(completionResult)\n  return createServer({\n    capabilities = {\n      completionProvider = {},\n    },\n    handlers = {\n      ['textDocument/completion'] = function (_, _, callback)\n        callback(nil, completionResult)\n      end,\n    },\n  })\nend\n\nlocal function startClient(name, completionResult)\n  vim.lsp.start({\n    name = name,\n    cmd = createServerWithCompletionProvider(completionResult).cmd,\n    on_attach = function (client, bufnr0)\n      vim.lsp.completion.enable(true, client.id, bufnr0, {})\n    end,\n  })\nend\n\nvim.o.completeopt = 'menuone,noselect'\nvim.fn.complete = vim.schedule_wrap(vim.fn.complete)\n\nvim.api.nvim_create_autocmd('UIEnter', {\n  callback = function ()\n    startClient('server1', completionResultNullLs)\n  end\n})\n```\n</details>\n\n- override completion.lua with the above\n- nvim --clean -u init.lua empty.lua\n- press `a<C-x><C-o><C-n><C-n><C-n>`\n\n\n### Expected behavior\n\nHighlighter is resistant to such changes.\n\n### Nvim version (nvim -v)\n\nv0.11.0-dev-1760+gb76773f8a6\n\n### Vim (not Nvim) behaves the same?\n\nn/a\n\n### Operating system/version\n\nDebian Sid\n\n### Terminal name/version\n\nalacritty\n\n### $TERM environment variable\n\nalacritty\n\n### Installation\n\nfrom repo + above completion change",
    "closed_at": "2025-02-22T12:53:19Z",
    "closed_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
        "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
        "followers_url": "https://api.github.com/users/przepompownia/followers",
        "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
        "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/przepompownia",
        "id": 11404453,
        "login": "przepompownia",
        "node_id": "MDQ6VXNlcjExNDA0NDUz",
        "organizations_url": "https://api.github.com/users/przepompownia/orgs",
        "received_events_url": "https://api.github.com/users/przepompownia/received_events",
        "repos_url": "https://api.github.com/users/przepompownia/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/przepompownia",
        "user_view_type": "public"
    },
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "this should be already fixed by https://github.com/neovim/neovim/commit/59b672fda2c98185a7d8b7740453635b8a40f2ff. ",
            "created_at": "2025-02-22T12:02:15Z",
            "html_url": "https://github.com/neovim/neovim/issues/32577#issuecomment-2676168071",
            "id": 2676168071,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/32577",
            "node_id": "IC_kwDOAPphoM6fgxWH",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676168071/reactions"
            },
            "updated_at": "2025-02-22T12:02:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676168071",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> this should be already fixed by [59b672f](https://github.com/neovim/neovim/commit/59b672fda2c98185a7d8b7740453635b8a40f2ff).\n\nNot necessary as it turns out for me (because having the current master here).",
            "created_at": "2025-02-22T12:05:04Z",
            "html_url": "https://github.com/neovim/neovim/issues/32577#issuecomment-2676169251",
            "id": 2676169251,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/32577",
            "node_id": "IC_kwDOAPphoM6fgxoj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676169251/reactions"
            },
            "updated_at": "2025-02-22T12:05:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676169251",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
                "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
                "followers_url": "https://api.github.com/users/przepompownia/followers",
                "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
                "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/przepompownia",
                "id": 11404453,
                "login": "przepompownia",
                "node_id": "MDQ6VXNlcjExNDA0NDUz",
                "organizations_url": "https://api.github.com/users/przepompownia/orgs",
                "received_events_url": "https://api.github.com/users/przepompownia/received_events",
                "repos_url": "https://api.github.com/users/przepompownia/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/przepompownia",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Cannot reproduce",
            "created_at": "2025-02-22T12:06:49Z",
            "html_url": "https://github.com/neovim/neovim/issues/32577#issuecomment-2676170382",
            "id": 2676170382,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/32577",
            "node_id": "IC_kwDOAPphoM6fgx6O",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676170382/reactions"
            },
            "updated_at": "2025-02-22T12:06:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676170382",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I also can't reproduce",
            "created_at": "2025-02-22T12:10:30Z",
            "html_url": "https://github.com/neovim/neovim/issues/32577#issuecomment-2676171720",
            "id": 2676171720,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/32577",
            "node_id": "IC_kwDOAPphoM6fgyPI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676171720/reactions"
            },
            "updated_at": "2025-02-22T12:10:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676171720",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "After re-creating these conditions, I can say that I too üòÅ Sorry for the unnecessary distraction (and thanks for the fix mentioned above)!.",
            "created_at": "2025-02-22T12:53:19Z",
            "html_url": "https://github.com/neovim/neovim/issues/32577#issuecomment-2676186134",
            "id": 2676186134,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/32577",
            "node_id": "IC_kwDOAPphoM6fg1wW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676186134/reactions"
            },
            "updated_at": "2025-02-22T12:53:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2676186134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
                "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
                "followers_url": "https://api.github.com/users/przepompownia/followers",
                "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
                "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/przepompownia",
                "id": 11404453,
                "login": "przepompownia",
                "node_id": "MDQ6VXNlcjExNDA0NDUz",
                "organizations_url": "https://api.github.com/users/przepompownia/orgs",
                "received_events_url": "https://api.github.com/users/przepompownia/received_events",
                "repos_url": "https://api.github.com/users/przepompownia/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/przepompownia",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 5,
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/32577/comments",
    "created_at": "2025-02-22T11:52:33Z",
    "events_url": "https://api.github.com/repos/neovim/neovim/issues/32577/events",
    "html_url": "https://github.com/neovim/neovim/issues/32577",
    "id": 2870691994,
    "labels": [],
    "labels_url": "https://api.github.com/repos/neovim/neovim/issues/32577/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "I_kwDOAPphoM6rG0ia",
    "number": 32577,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/neovim/neovim/issues/32577/reactions"
    },
    "repository_url": "https://api.github.com/repos/neovim/neovim",
    "state": "closed",
    "state_reason": "completed",
    "sub_issues_summary": {
        "completed": 0,
        "percent_completed": 0,
        "total": 0
    },
    "timeline_url": "https://api.github.com/repos/neovim/neovim/issues/32577/timeline",
    "title": "treesitter highlighter `Invalid 'col': out of range` revealed on lsp completion changes",
    "updated_at": "2025-02-22T12:55:07Z",
    "url": "https://api.github.com/repos/neovim/neovim/issues/32577",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
        "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
        "followers_url": "https://api.github.com/users/przepompownia/followers",
        "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
        "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/przepompownia",
        "id": 11404453,
        "login": "przepompownia",
        "node_id": "MDQ6VXNlcjExNDA0NDUz",
        "organizations_url": "https://api.github.com/users/przepompownia/orgs",
        "received_events_url": "https://api.github.com/users/przepompownia/received_events",
        "repos_url": "https://api.github.com/users/przepompownia/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/przepompownia",
        "user_view_type": "public"
    }
}