{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "### Problem\n\nrunning nvim --embed with or without headless causes it to terminate either immediately or after any writing. I've been trying to figure out how to embed neovim for the last 3 days and everything I have tried from using lua, python, and C++ has failed to work. With only --headless nvim will stay running.\n\nThe docs say that --embed is identical to --cmd \"call stdioopen({'rpc': v:true})\" but\n\n```\nstd::wstring cmd = LR\"(nvim.exe --headless --cmd \\\"call stdioopen({'rpc': v:true})\\\")\";\nbool success = CreateProcessW(NULL, const_cast<wchar_t*>(cmd.c_str()), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);\n```\n\ndoes not fail on writing while\n\n```\n    std::wstring cmd = LR\"(nvim.exe --embed --headless )\";\n    bool success = CreateProcessW(NULL, const_cast<wchar_t*>(cmd.c_str()), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);\n```\n\nterminates immediately(but success is true). [https://neovim.io/doc/user/starting.html#--embed]\n\n\n\n### Steps to reproduce\n\nTry to use --embed mode. Seems to fail regardless. Usually writing anything to the pipe will cause it to terminate. Again, if the docs are right then there is something wrong with nvim --embed since it is behaving differently than expected.\n\nIf I do call it with nvim.exe --cmd \\\"call stdioopen({'rpc': v:true})\\ without headless then it opens up and immediately closes. If I run it inside nvim then I get E905: Couldn't open stdio channel: channel was already open.\n\nIf I run nvim.exe --embed --headless -cmd \"call stdioopen({'rpc': v:true}) nvim runs and any keyboard input then terminates it(sorta similar to the behavior before).\n\nEither way, the docs are either wrong or there is a bug with embed.\nI'll try to do some further testing to see if everything now starts working but I've been chasing this rabbit for quite some time.\n\n### Expected behavior\n\nFor it to work. I've been trying everything and assumed everything but nvim. Something isn't working. It shouldn't be this difficult. Given that the docs claim that embed is equivalent to sending the cmd and using it instead gives different results suggests there is a bug with --embed. I haven't tested it but I can say that calling nvim_ui_attach doesn't terminate nvim like it was(or anything I'd try to pass to nvim with --embed). \n\n\n\n### Nvim version (nvim -v)\n\nv0.12.0-dev-1387+gf67306cc67\n\n### Vim (not Nvim) behaves the same?\n\nvim doesn't have --embed\n\n### Operating system/version\n\nWin11 24H2\n\n### Terminal name/version\n\nwindows terminal\n\n### $TERM environment variable\n\nnone\n\n### Installation\n\nmanual",
    "closed_at": "2025-11-19T04:39:11Z",
    "closed_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
        "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
        "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
        "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
        "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/Universal-Invariant",
        "id": 202556375,
        "login": "Universal-Invariant",
        "node_id": "U_kgDODBLD1w",
        "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
        "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
        "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/Universal-Invariant",
        "user_view_type": "public"
    },
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "You can't write \"anything\" to the pipe. You need to write valid msgpack RPC.\n\n> Given that the docs claim that embed is equivalent to sending the cmd and using it instead gives different results suggests there is a bug with --embed.\n\nI cannot understand this sentence. Where does the docs claim what?",
            "created_at": "2025-11-18T00:53:19Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3544565612",
            "id": 3544565612,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TRcds",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544565612/reactions"
            },
            "updated_at": "2025-11-18T00:58:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544565612",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> You can't write \"anything\" to the pipe. You need to write valid msgpack RPC.\n> \n> > Given that the docs claim that embed is equivalent to sending the cmd and using it instead gives different results suggests there is a bug with --embed.\n> \n> I cannot understand this sentence. Where does the docs claim what?\n\nObviously. I do not mean write anything arbitrarily.\n\nI posted the link to the docs where they claim that --embed is equivalent to which I explained in what I wrote. They are not behaving equivalently. I explained it all. I've tried so many different things and they all fail. I've tried 4 different msgpack libraries. 2 from lua and 2 from C++ + some custom basic stuff and hard coding data.\n\nI've tried: \n\ntype ui_attach_request.bin | nvim.exe --headless --cmd \"call stdioopen({'rpc': v:true})\"\n\nthe bin is msg pack data.\n\nEverything fails. In this case the above also fails. It contains: 94 00 01 ae 6e 76 69 6d 5f 75 69 5f 61 74 74 61 63 68 93 50 18 81 a3 72 67 62\n\n\nwhich is suppose to be a hard coded msg pack:\n\nlocal correct_hex = \"96\" ..      -- array of 6 items\n                    \"00\" ..      -- type: 0 (request)\n                    \"01\" ..      -- msg_id: 1\n                    \"da000f\" ..  -- str16 length 15\n                    \"6e76696d5f75695f617474616368\" .. -- \"nvim_ui_attach\"\n                    \"48\" ..      -- width: 80\n                    \"18\" ..      -- height: 24\n                    \"81\" ..      -- map of 1 item\n                    \"a3726762\" .. -- \"rgb\" (fixstr3 + \"rgb\")\n                    \"c3\"         -- true\n\nI've tried many other things. I went down the ui_attach route because that was mentioned in some docs as necessary but I couldn't get anything to work. Because it simply terminates it's very difficult to know what is going on. I assumed it was the msgpacking which is why I tried 4 different versions. In many cases though nvim just exits immediately when using --embed so it is impossible to figure out. I tried different things with CreateProcess including using lua's popen which worked much better but still had similar issues. I could at least use it to echo text at some point.\n\nhttps://neovim.io/doc/user/channel.html\n\nhttps://browse.dgit.debian.org/neovim.git/tree/runtime/doc/msgpack_rpc.txt?id=baa981ea214ebaf606df443b2928ee93a7e6f7b9\n\nWhich seems to have some outdated information and invalid code.\n\n\"nvim_ui_attach({width}, {height}, {options})[nvim_ui_attach()](https://neovim.io/doc/user/api.html#nvim_ui_attach())\nActivates UI events on the channel.\nEntry point of all UI clients. Allows [--embed](https://neovim.io/doc/user/starting.html#--embed) to continue startup. Implies that the client is ready to show the UI. Adds the client to the list of UIs. [nvim_list_uis()](https://neovim.io/doc/user/api.html#nvim_list_uis())\"\n\nMaybe this doesn't work with headless and that is why attach fails? \n\ntype ui_attach_request.bin | nvim.exe --embed sorta works as it outputs: 94 01 01 c0 c0 but then it terminates immediately.\n\nI tried python with pynvim and that worked but I can't use python but it was using tcp rather than embed.\n\nI haven't checked but maybe nvim can or is outputting some debug information to some log file?\n\n",
            "created_at": "2025-11-18T01:43:17Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3544664589",
            "id": 3544664589,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TR0oN",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544664589/reactions"
            },
            "updated_at": "2025-11-18T01:43:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544664589",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
                "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
                "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
                "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
                "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Universal-Invariant",
                "id": 202556375,
                "login": "Universal-Invariant",
                "node_id": "U_kgDODBLD1w",
                "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
                "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
                "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Universal-Invariant",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Sorry your experience is bad, but we can narrow down the issue and perhaps improve docs if needed. It may help if you can provide a minimal C/C++ code sample that we can try out (though possibly this is a Windows-specific issue, but [Neovim-qt](https://github.com/equalsraf/neovim-qt/blob/76cc138555e36d1b79fde141bc369024383a438e/src/neovimconnector.cpp#L269) is a C++ client which calls `nvim --embed`, and it definitely works on Windows...)\n\nI am guessing that something somewhere is writing invalid msgpack to the channel.\n\n> The docs say that --embed is identical to --cmd \"call stdioopen({'rpc': v:true})\" but\n\nNot to be pedantic, but \"equivalent\" does not mean \"identical\". That line is an attempt to show a (very similar, but not identical) analogy.\n\n> Maybe this doesn't work with headless and that is why attach fails?\n\n`:help --embed` does mention that `--headless`, by definition, does not wait for a UI (nvim_ui_attach).\n\n> I haven't checked but maybe nvim can or is outputting some debug information to some log file?\n\nYes, `:edit $NVIM_LOG_FILE` shows the default path. And Nvim builds with very verbose logging if you used the default build settings.\n\n",
            "created_at": "2025-11-18T02:05:16Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3544700057",
            "id": 3544700057,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TR9SZ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544700057/reactions"
            },
            "updated_at": "2025-11-18T02:05:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544700057",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Sorry your experience is bad, but we can narrow down the issue and perhaps improve docs if needed. It may help if you can provide a minimal C/C++ code sample that we can try out (though possibly this is a Windows-specific issue, but [Neovim-qt](https://github.com/equalsraf/neovim-qt/blob/76cc138555e36d1b79fde141bc369024383a438e/src/neovimconnector.cpp#L269) is a C++ client which calls `nvim --embed`, and it definitely works on Windows...)\n> \n> I am guessing that something somewhere is writing invalid msgpack to the channel.\n> \n\nThis is what I thought which is why I tried many different packages but everyone one exhibit the same issue. This should be a very simple process of simply writing to the input pipe and using the proper protocol. There seems to be no good examples of exactly how to do this or the examples are so simple that it suggests it is a simple process.\n\n> > The docs say that --embed is identical to --cmd \"call stdioopen({'rpc': v:true})\" but\n> \n> Not to be pedantic, but \"equivalent\" does not mean \"identical\". That line is an attempt to show a (very similar, but not identical) analogy. I assume by \"equivalent\" it means that --embed is rewritten to that command. Obviously they are not identical but their effect should be identical. If not then they are not equivalent. Not to be more pedantic but identity is equivalent to equivalence(univalent axiom): https://en.wikipedia.org/wiki/Homotopy_type_theory#The_univalence_axiom.\n> \n> > Maybe this doesn't work with headless and that is why attach fails?\n> \n> `:help --embed` does mention that `--headless`, by definition, does not wait for a UI (nvim_ui_attach).\n> \n\nYes, and this is generally why when using headless the process persists rather than terminates immediately. But without --embed there is no way to pipe rpc data to it.\n\n> > I haven't checked but maybe nvim can or is outputting some debug information to some log file?\n> \n> Yes, `:edit $NVIM_LOG_FILE` shows the default path. And Nvim builds with very verbose logging if you used the default build settings.\n\n\nThis is one C++ file I used for testing just trying to get it to work:\n\n```\n// simple_test.cpp\n#include <windows.h>\n#include <iostream>\n\nint main() {\n    // Create the msgpack binary data for nvim_ui_attach\n    char msgpack_data[] = {\n        char(0x96),               // array of 6 items\n        char(0x00),               // type: 0 (request)\n        char(0x01),               // msg_id: 1\n        char(0xda), char(0x00), char(0x0f),   // str16 with length 15\n        'n', 'v', 'i', 'm', '_', 'u', 'i', '_', 'a', 't', 't', 'a', 'c', 'h', // \"nvim_ui_attach\"\n        char(0x48),               // width: 80\n        char(0x18),               // height: 24\n        char(0x81),               // map of 1 item\n        char(0xa3),               // fixstr of length 3\n        'r', 'g', 'b',            // \"rgb\"\n        char(0xc3)                // true\n    };\n\n    SECURITY_ATTRIBUTES sa;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;\n    sa.lpSecurityDescriptor = NULL;\n\n    HANDLE stdin_read, stdin_write;\n    CreatePipe(&stdin_read, &stdin_write, &sa, 0);\n    SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0);\n\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.hStdInput = stdin_read;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n\n    ZeroMemory(&pi, sizeof(pi));\n\n    std::wstring cmd = LR\"(nvim.exe -V16 --embed --headless\\\")\";\n//   std::wstring cmd = LR\"(nvim.exe -V16 --embed --headless --cmd \\\"stdioopen({'rpc': v:true})\\\")\";\n    bool success = CreateProcessW(NULL, const_cast<wchar_t*>(cmd.c_str()), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);\n\n    if (success) {\n        std::cout << \"Nvim started successfully\" << std::endl;\n\n        // Write msgpack data to nvim's stdin\n        DWORD bytes_written;\n        WriteFile(stdin_write, msgpack_data, sizeof(msgpack_data), &bytes_written, NULL);\n        std::cout << \"Wrote \" << bytes_written << \" bytes to nvim\" << std::endl;\n\n        // Don't close stdin immediately - let nvim process the message\n        Sleep(10000); // Wait 10 seconds\n\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n    }\n    else {\n        std::cout << \"Failed to start nvim\" << std::endl;\n    }\n\n    CloseHandle(stdin_read);\n    CloseHandle(stdin_write);\n\n    return 0;\n}\n\n// original function I was using to run start nvim with the commands originally starting with --embed but then trying other things.\nbool start_nvim_process(NeovimInstance* instance, const wchar_t* nvim_path) {\n    SECURITY_ATTRIBUTES sa;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;\n    sa.lpSecurityDescriptor = NULL;\n\n    CreatePipe(&instance->stdin_read, &instance->stdin_write, &sa, 0);\n    CreatePipe(&instance->stdout_read, &instance->stdout_write, &sa, 0);\n    CreatePipe(&instance->stderr_read, &instance->stderr_write, &sa, 0);\n\n    SetHandleInformation(instance->stdin_write, HANDLE_FLAG_INHERIT, 0);\n    SetHandleInformation(instance->stdout_read, HANDLE_FLAG_INHERIT, 0);\n    SetHandleInformation(instance->stderr_read, HANDLE_FLAG_INHERIT, 0);\n\n    STARTUPINFOW si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.hStdInput = instance->stdin_read;\n    si.hStdOutput = instance->stdout_write;\n    si.hStdError = instance->stderr_write;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n\n    ZeroMemory(&pi, sizeof(pi));\n\n    // Use stdioopen instead of --embed\n    auto cmd = std::wstring(nvim_path) + L\" --headless --cmd \\\"call stdioopen({'rpc': v:true})\\\"\";\n    bool success = CreateProcessW(NULL,\n        const_cast<wchar_t*>(cmd.c_str()),\n        NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);\n\n    if (success) {\n        instance->nvim_process = pi.hProcess;\n        CloseHandle(pi.hThread);\n        return true;\n    }\n    return false;\n}\n\n```\n\nI've tried various arguments but basically nothing works.  With embed the nvim terminates immediately. With headless it will persist for a while then terminate due to sleep(). I've had more complex code which handles read, write, and error pipes and does far more work but this is what I tried to simplify to just to figure out if it will respond at all. Using cmd rather than embed persists too. Given that I always seem to have the same issues, that is by using --embed nvim will immediately terminate, to me suggests a common central problem. Either something else needs to be done or there is something with embed.\n\nI've tried using pure command line stuff as I mentioned. Still fails. \n\n\nhttps://neovim.io/doc/user/channel.html#channel-intro\n\nThis says if --headless is used then standard pipes can be used.\n\n\"Nvim uses stdin/stdout to interact with the user over the terminal interface (TUI). If Nvim is [--headless](https://neovim.io/doc/user/starting.html#--headless) the TUI is not started and stdin/stdout can be used as a channel. See also [--embed](https://neovim.io/doc/user/starting.html#--embed).\"\n\nIt doesn't say the pipes are automatically setup so maybe that is the issue.\n\nIn any case, it is just unclear exactly what the process needs to be to get nvim to respond to input commands. Because I haven't found anything definitive I can't be sure if I'm making a mistake in my own code or not initializing things properly or if it is with nvim itself(unlikely given that others are doing it successfully but I almost always see the use of listen rather than embed).\n\n\nFor example, it says:\n\nCall stdioopen() during startup to open the stdio channel as channel-id 1. Nvim's stderr is always available as v:stderr, a write-only bytes channel.\n\nBut the other parts of the docs suggest that --embed does this for us. But even if passing the -cmd that does it there are still issues. It is very possible it is an issue with msgpack that I've glossed over. Just very hard to tell at this point since I've tried so much stuff. When I tried the python example with pynvim it worked fine and as expected. I didn't investigate with python any more since I can't use it.\n\nusing \n\n```\ntype ui_attach_request.bin | nvim.exe --embed \n```\n\ndoes give an output that looks like a msgpack structure that I mentioned earlier.\n\nbut \n\n```\ntype ui_attach_request.bin | nvim.exe --embed --headless\n```\n\nfails to give the same output. \n\nTomorrow I'll try to settle down and go back through it once more to figure out what is going on. Maybe then you guys can have a suggestion or see what is obviously wrong here. I do think the docs likely need to give a clear example to use embed mode.  Maybe using headless with it is wrong but I've tried just about every combination possible which is why at this point I really don't know what is going on\n\n\n\n\n\n\n\nI get no log information.",
            "created_at": "2025-11-18T03:00:14Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3544808270",
            "id": 3544808270,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TSXtO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544808270/reactions"
            },
            "updated_at": "2025-11-18T03:00:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544808270",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
                "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
                "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
                "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
                "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Universal-Invariant",
                "id": 202556375,
                "login": "Universal-Invariant",
                "node_id": "U_kgDODBLD1w",
                "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
                "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
                "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Universal-Invariant",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Here is a lua file that does work that gets the api info:\n\n```\n-- get_api_info.lua\n-- Creates msgpack data for nvim_get_api_info RPC call and writes it to a file\n\nprint(\"Creating msgpack data for nvim_get_api_info...\")\n\n-- Simple msgpack packer functions (inline for this test)\nfunction pack_int(value)\n    if value >= 0 and value <= 127 then\n        return string.char(value)\n    elseif value >= -32 and value <= -1 then\n        return string.char(256 + value)\n    elseif value >= -128 and value <= 127 then\n        return string.char(0xd0, value < 0 and (256 + value) or value)\n    elseif value >= -32768 and value <= 32767 then\n        local val = value < 0 and (65536 + value) or value\n        return string.char(0xd1, math.floor(val / 256), val % 256)\n    else\n        local val = value < 0 and (4294967296 + value) or value\n        return string.char(0xd2, math.floor(val / 16777216) % 256, math.floor(val / 65536) % 256, math.floor(val / 256) % 256, val % 256)\n    end\nend\n\nfunction pack_str(str)\n    local len = string.len(str)\n    if len < 32 then\n        return string.char(0xa0 + len) .. str\n    else\n        return string.char(0xda, math.floor(len / 256) % 256, len % 256) .. str\n    end\nend\n\nfunction pack_array(items)\n    local len = #items\n    local result\n    if len < 16 then\n        result = string.char(0x90 + len)\n    else\n        result = string.char(0xdc, math.floor(len / 256) % 256, len % 256)\n    end\n    for _, item in ipairs(items) do\n        result = result .. item\n    end\n    return result\nend\n\n-- Create the RPC request: [0, msg_id, method_name, args_array]\nlocal msg_id = 1\nlocal method_name = \"nvim_get_api_info\"\nlocal args_array = pack_array({}) -- get_api_info takes no arguments\n\nlocal full_request = pack_array({\n    pack_int(0),                    -- type: request (0)\n    pack_int(msg_id),               -- msg_id\n    pack_str(method_name),          -- method name\n    args_array                      -- args (empty array)\n})\n\n-- Write the msgpack data to a file\nlocal filename = \"get_api_info_request.bin\"\nlocal file = io.open(filename, \"wb\")\nif file then\n    file:write(full_request)\n    file:close()\n    print(string.format(\"Msgpack data for 'nvim_get_api_info' written to '%s'\", filename))\n    print(string.format(\"File size: %d bytes\", string.len(full_request)))\n    print(\"\\nYou can now pipe this to nvim using stdioopen:\")\n    print(string.format('type %s | nvim.exe --headless --cmd \"call stdioopen({\\'rpc\\': v:true})\"', filename))\nelse\n    print(\"Error: Could not create file \" .. filename)\nend\n```\n\nIt also works with just --embed and other combinations. So the main issue seems to be related to nvim_ui_attach as I used similar code for it and it failed.\n\nHere is a similar one for ui_attach:\n\n```\n-- attach_ui.lua\n-- Creates msgpack data for nvim_ui_attach RPC call and writes it to a file\n\nprint(\"Creating msgpack data for nvim_ui_attach...\")\n\n-- Simple msgpack packer functions (inline for this test)\nfunction pack_int(value)\n    if value >= 0 and value <= 127 then\n        return string.char(value)\n    elseif value >= -32 and value <= -1 then\n        return string.char(256 + value)\n    elseif value >= -128 and value <= 127 then\n        return string.char(0xd0, value < 0 and (256 + value) or value)\n    elseif value >= -32768 and value <= 32767 then\n        local val = value < 0 and (65536 + value) or value\n        return string.char(0xd1, math.floor(val / 256), val % 256)\n    else\n        local val = value < 0 and (4294967296 + value) or value\n        return string.char(0xd2, math.floor(val / 16777216) % 256, math.floor(val / 65536) % 256, math.floor(val / 256) % 256, val % 256)\n    end\nend\n\nfunction pack_str(str)\n    local len = string.len(str)\n    if len < 32 then\n        return string.char(0xa0 + len) .. str\n    else\n        return string.char(0xda, math.floor(len / 256) % 256, len % 256) .. str\n    end\nend\n\nfunction pack_bool(value)\n    return value and string.char(0xc3) or string.char(0xc2)\nend\n\nfunction pack_map(items)\n    local len = #items / 2 -- Count key-value pairs\n    local result\n    if len < 16 then\n        result = string.char(0x80 + len)\n    else\n        result = string.char(0xde, math.floor(len / 256) % 256, len % 256)\n    end\n    for i = 1, #items, 2 do\n        result = result .. items[i] .. items[i+1] -- Key then Value\n    end\n    return result\nend\n\nfunction pack_array(items)\n    local len = #items\n    local result\n    if len < 16 then\n        result = string.char(0x90 + len)\n    else\n        result = string.char(0xdc, math.floor(len / 256) % 256, len % 256)\n    end\n    for _, item in ipairs(items) do\n        result = result .. item\n    end\n    return result\nend\n\n-- Create the RPC request: [0, msg_id, method_name, args_array]\nlocal msg_id = 1\nlocal method_name = \"nvim_ui_attach\"\nlocal width = 80\nlocal height = 24\nlocal options = {\n    pack_str(\"rgb\"), pack_bool(true),\n    pack_str(\"ext_linegrid\"), pack_bool(true),\n    pack_str(\"ext_hl\"), pack_bool(true),\n    pack_str(\"ext_cmdline\"), pack_bool(true),\n    pack_str(\"ext_popupmenu\"), pack_bool(true),\n    pack_str(\"ext_tabline\"), pack_bool(true),\n    pack_str(\"ext_wildmenu\"), pack_bool(true)\n}\n\nlocal args_array = pack_array({\n    pack_int(width),           -- width\n    pack_int(height),          -- height\n    pack_map(options)          -- options map\n})\n\nlocal full_request = pack_array({\n    pack_int(0),                    -- type: request (0)\n    pack_int(msg_id),               -- msg_id\n    pack_str(method_name),          -- method name\n    args_array                      -- args (the array [width, height, options_map])\n})\n\n-- Write the msgpack data to a file\nlocal filename = \"ui_attach_request.bin\"\nlocal file = io.open(filename, \"wb\")\nif file then\n    file:write(full_request)\n    file:close()\n    print(string.format(\"Msgpack data for 'nvim_ui_attach' written to '%s'\", filename))\n    print(string.format(\"File size: %d bytes\", string.len(full_request)))\n    print(\"\\nYou can now pipe this to nvim using stdioopen:\")\n    print(string.format('type %s | nvim.exe --headless --cmd \"call stdioopen({\\'rpc\\': v:true})\"', filename))\nelse\n    print(\"Error: Could not create file \" .. filename)\nend\n```\n\nIn this case it immediately returns but I have no way of knowing if the write is terminating it or not like I have done with other programs since I can put a bp on the write lines to check. ok, with headless I do not get output but just with --embed I do get \"���No such UI option: ext_hl\" which I removed and do get msgpack output. It still terminates nvim.\n\nSo I guess the issue may be that nvim is terminating with embed and with headless it doesn't output anything(I suppose because the pipes are not correctly setup or there is some interaction effect). Adding -V20 I do get a lot of output.\n\nSo at least this seems to be a start of figuring out what is going on. \n",
            "created_at": "2025-11-18T03:34:01Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3544875373",
            "id": 3544875373,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TSoFt",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544875373/reactions"
            },
            "updated_at": "2025-11-18T03:41:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3544875373",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
                "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
                "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
                "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
                "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Universal-Invariant",
                "id": 202556375,
                "login": "Universal-Invariant",
                "node_id": "U_kgDODBLD1w",
                "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
                "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
                "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Universal-Invariant",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> But without --embed there is no way to pipe rpc data to it.\n\nThere are many ways to make RPC requests without `--embed`.",
            "created_at": "2025-11-18T07:41:31Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3545959989",
            "id": 3545959989,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7TWw41",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3545959989/reactions"
            },
            "updated_at": "2025-11-18T07:41:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3545959989",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > But without --embed there is no way to pipe rpc data to it.\n> \n> There are many ways to make RPC requests without `--embed`.\n\nI'm trying to embed nvim into an app. The issue isn't how to do other things. The issue is why embed is terminating at all when proper input(or even not) is put in. Even if the input is errored why would embed terminate but not without it(such as using headless).  One can't use nvim embed if it terminates every time one tries to use it. This would suggest a bug(or fragile design), initialization issue, or it's something different than what is said in the docs and other sources.",
            "created_at": "2025-11-18T16:57:52Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3548629300",
            "id": 3548629300,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7Tg8k0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3548629300/reactions"
            },
            "updated_at": "2025-11-18T16:57:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3548629300",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
                "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
                "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
                "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
                "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Universal-Invariant",
                "id": 202556375,
                "login": "Universal-Invariant",
                "node_id": "U_kgDODBLD1w",
                "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
                "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
                "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Universal-Invariant",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Ok, after playing around with it some more it seems to be working fine. Not sure what the issue was. The only thing I really did different was write CreateProcess minimally so do much of the work inside lua with it when before I hard coded some things in the dll(e.g., I allow setting up pipes in lua rather than C). Possibly there was a bug in the code somewhere causing the strange issues.\n\nFor anyone interested. This doesn't include the luarun dll but it's basic stuff as it just exposes CreateProcess, read, write, and close among other things which are not used.\n```lua\n-- test.lua\nlocal nvim_c = require(\"luarun\") -- Adjust module name if needed\nlocal inspect = require(\"inspect\")\nlocal msgpack = require(\"msgpack\") -- Load the new msgpack library\n\n-- --- Helper function to read and decode ALL responses from the handle ---\nlocal function read_all_responses(handle, timeout_ms)\n    timeout_ms = timeout_ms or 1000 -- Default timeout in milliseconds\n    local buffer = \"\" -- Accumulate data here\n    local responses = {}\n\n    local start_time = os.clock() * 1000 -- Get start time in milliseconds\n\n    while true do\n        -- Check if data is available using peek\n        local has_data, bytes_available = nvim_c.peek_handle(handle)\n\n        if has_data and bytes_available > 0 then\n            -- Data is available, read it\n            local new_data, num_bytes = nvim_c.read_handle(handle, bytes_available) -- Read the available amount\n            if not new_data then\n                if num_bytes == 0 then\n                    print(\"  ReadFile reported EOF/Broken pipe.\")\n                    break -- Pipe closed\n                else\n                    print(\"  Error reading handle:\", num_bytes)\n                    break\n                end\n            end\n            if #new_data > 0 then\n                print(\"  Read \" .. #new_data .. \" bytes from handle. Total buffer = \" .. (#buffer + #new_data))\n                buffer = buffer .. new_data\n\n                -- Attempt to decode objects from the buffer\n                local pos = 1\n                while pos <= #buffer do\n                    local decoded_obj, next_pos_or_error = msgpack.decode_one(buffer, pos)\n                    if decoded_obj then\n                        print(\"  Successfully decoded object (type: \" .. type(decoded_obj) .. \") from buffer.\")\n                        table.insert(responses, decoded_obj)\n                        pos = next_pos_or_error -- Move position to after the decoded object\n                    else\n                        print(\"  Cannot decode object at position \" .. pos .. \" (buffer length: \" .. #buffer .. \"). Need more data.\")\n                        -- If decode_one fails, it might be because the full object isn't in the buffer yet.\n                        -- Break out of the decoding loop and go back to peeking/waiting for more data.\n                        break\n                    end\n                end\n\n                -- Remove processed data from the buffer\n                buffer = string.sub(buffer, pos)\n            end\n        elseif not has_data then\n            -- No data available right now. Check timeout.\n            local current_time = os.clock() * 1000\n            if (current_time - start_time) > timeout_ms then\n                print(\"  Timeout reached (\" .. timeout_ms .. \"ms). Stopping read.\")\n                break\n            end\n            -- Optional: Add a small sleep to prevent busy waiting if timeout is long\n            -- os.execute(\"ping -n 1 -w 10 127.0.0.1 > nul\") -- Windows sleep for 10ms\n            -- Or use a proper sleep function if available in your Lua environment\n        end\n\n        -- Add a small delay to prevent excessive CPU usage during timeout\n        -- This is a simple alternative if you don't want to implement a proper sleep\n        if not has_data then\n            local current_time = os.clock() * 1000\n            if (current_time - start_time) <= timeout_ms then\n               -- Simple busy-wait adjustment or use a proper sleep\n               -- For now, just continue the loop, the timeout check will handle it\n            end\n        end\n    end\n\n    if #buffer > 0 then\n        print(\"  Leftover data in buffer after timeout (\" .. #buffer .. \" bytes) - might be incomplete msgpack object.\")\n    end\n\n    return responses\nend\n\n\n-- --- Main Script ---\n-- Use --embed --headless to avoid waiting for nvim_ui_attach before processing requests\nlocal cmd = [[nvim.exe --embed --headless]]\ncmd = [[nvim.exe --embed]]\n\nlocal options = {\n    flags = 0,\n    inherit_handles = true,\n    pipe_stdin = true,\n    pipe_stdout = true,\n    pipe_stderr = true,\n    current_directory = \"Z:\\\\\", -- Optional\n}\n\nlocal success, info = nvim_c.create_process(cmd, options)\n\nif not success then\n    print(\"Error starting process:\", info)\n    return\nend\n\nprint(\"Process started successfully!\")\nprint(\"PID:\", info.pid)\nprint(\"Stdin Write Handle:\", info.stdin_write)\nprint(\"Stdout Read Handle:\", info.stdout_read)\nprint(\"Stderr Read Handle:\", info.stderr_read)\n\n-- --- Send nvim_get_api_info ---\nprint(\"\\n--- Sending nvim_get_api_info ---\")\nlocal api_info_request = msgpack.encode({0, 1, \"nvim_get_api_info\", {}}) -- [type=0, msg_id=1, method, params_array]\n\nlocal write_success, bytes_written = nvim_c.write_handle(info.stdin_write, api_info_request)\nif not write_success then\n    print(\"Failed to write API info request:\", bytes_written)\n    return\nend\nprint(\"Sent nvim_get_api_info request (\" .. bytes_written .. \" bytes)\")\n\n-- --- Read Response(s) to nvim_get_api_info ---\nprint(\"--- Reading API Info Response(s) ---\")\nlocal responses1 = read_all_responses(info.stdout_read)\nprint(\"Found \" .. #responses1 .. \" response(s) after API info request.\")\nif #responses1 > 0 then\n    print(\"First response (likely API info):\")\n    print(inspect(responses1[1]))\n    -- The API info is usually in responses1[1][4] (result part of [type, id, error, result])\n    if type(responses1[1]) == \"table\" and #responses1[1] == 4 and responses1[1][1] == 1 and responses1[1][2] == 1 then\n        local api_result = responses1[1][4]\n        print(\"\\n--- Raw API Result (first part) ---\")\n        print(inspect(api_result)) -- This should be the large table\n        if type(api_result) == \"table\" and type(api_result[3]) == \"table\" then\n            print(\"\\n--- API Functions (from result[3]) ---\")\n            print(inspect(api_result[3]))\n        end\n    end\nend\n\n-- --- Send nvim_ui_attach ---\nprint(\"\\n--- Sending nvim_ui_attach ---\")\nlocal ui_attach_params = {80, 24, {rgb = true, ext_linegrid = true}} -- width, height, options map\nlocal ui_attach_request = msgpack.encode({0, 2, \"nvim_ui_attach\", ui_attach_params}) -- [type=0, msg_id=2, method, params_array]\n\nlocal write_success2, bytes_written2 = nvim_c.write_handle(info.stdin_write, ui_attach_request)\nif not write_success2 then\n    print(\"Failed to write UI attach request:\", bytes_written2)\n    return\nend\nprint(\"Sent nvim_ui_attach request (\" .. bytes_written2 .. \" bytes)\")\n\n-- --- Read Response(s) to nvim_ui_attach ---\nprint(\"--- Reading UI Attach Response(s) ---\")\nlocal responses2 = read_all_responses(info.stdout_read)\nprint(\"Found \" .. #responses2 .. \" response(s) after UI attach request.\")\nif #responses2 > 0 then\n    print(\"First response (should be UI attach confirmation [1, 2, nil, nil]):\")\n    print(inspect(responses2[1]))\n    if type(responses2[1]) == \"table\" and #responses2[1] == 4 and responses2[1][1] == 1 and responses2[1][2] == 2 and responses2[1][3] == nil and responses2[1][4] == nil then\n        print(\"  UI Attach confirmed successfully!\")\n    else\n        print(\"  UI Attach response was unexpected.\")\n    end\nend\n\n-- --- Send a simple command to test further interaction ---\nprint(\"\\n--- Sending a simple command (nvim_eval '1 + 1') ---\")\nlocal eval_request = msgpack.encode({0, 3, \"nvim_eval\", {\"1 + 1\"}}) -- [type=0, msg_id=3, method, params_array]\n\nlocal write_success3, bytes_written3 = nvim_c.write_handle(info.stdin_write, eval_request)\nif not write_success3 then\n    print(\"Failed to write eval request:\", bytes_written3)\n    return\nend\nprint(\"Sent nvim_eval request (\" .. bytes_written3 .. \" bytes)\")\n\n-- --- Read Response(s) to nvim_eval ---\nprint(\"--- Reading Eval Response(s) ---\")\nlocal responses3 = read_all_responses(info.stdout_read)\nprint(\"Found \" .. #responses3 .. \" response(s) after eval request.\")\nif #responses3 > 0 then\n    print(\"First response (should be eval result [1, 3, nil, 2]):\")\n    print(inspect(responses3[1]))\n    -- Should be [1, 3, nil, 2] if successful\n    if type(responses3[1]) == \"table\" and #responses3[1] == 4 and responses3[1][1] == 1 and responses3[1][2] == 3 and responses3[1][3] == nil then\n        print(\"  Eval result:\", inspect(responses3[1][4]))\n    else\n        print(\"  Eval response was unexpected.\")\n    end\nend\n\nnvim_c.close_handle(info.stdin_write)\nnvim_c.close_handle(info.stdout_read)\nnvim_c.close_handle(info.stderr_read)\n\nprint(\"\\n--- Test Complete ---\")\n```\n\nJust for posterity, here is the C code:\n\n```C\n\n\n// Helper: Convert UTF-8 string to wide string\nstatic wchar_t* utf8_to_wide_string(lua_State* L, const char* utf8_str) {\n    if (!utf8_str) return NULL;\n    int wide_len = MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, NULL, 0);\n    if (wide_len == 0) return NULL;\n    wchar_t* wide_str = (wchar_t*)malloc(wide_len * sizeof(wchar_t));\n    if (!wide_str) {\n        luaL_error(L, \"Memory allocation failed for wide string conversion\");\n        return NULL; // Should not be reached due to luaL_error\n    }\n    MultiByteToWideChar(CP_UTF8, 0, utf8_str, -1, wide_str, wide_len);\n    return wide_str;\n}\n\n// Helper: Push error message and return nil, error\nstatic int push_error(lua_State* L, const char* msg) {\n    lua_pushnil(L);\n    lua_pushstring(L, msg);\n    return 2;\n}\n\n\n/*\n * Lua C function: create_process(command_line, [options])\n *\n * Launches a new process using the Win32 CreateProcessW function with advanced options.\n * Options table can include: current_directory, flags, inherit_handles, stdin_handle,\n * stdout_handle, stderr_handle, pipe_stdin, pipe_stdout, pipe_stderr.\n * If pipe_stdin/stdout/stderr are true, it creates pipes and returns the handles.\n *\n * Arguments:\n * 1. command_line (string): The command line to execute.\n * 2. options (table, optional): Configuration table.\n *    - current_directory (string): Starting directory for the process.\n *    - flags (number): dwCreationFlags for CreateProcess.\n *    - inherit_handles (boolean): Whether child inherits handles.\n *    - stdin_handle (number): HANDLE value for stdin (as lightuserdata).\n *    - stdout_handle (number): HANDLE value for stdout (as lightuserdata).\n *    - stderr_handle (number): HANDLE value for stderr (as lightuserdata).\n *    - pipe_stdin (boolean): Create a pipe for stdin.\n *    - pipe_stdout (boolean): Create a pipe for stdout.\n *    - pipe_stderr (boolean): Create a pipe for stderr.\n *\n * Returns:\n * 1. success (boolean): true if the process was created, false otherwise.\n * 2. info (table or string): On success, a table containing {pid, hProcess, hThread, stdin_write, stdout_read, stderr_read}.\n *                            On failure, an error message string.\n */\nstatic int l_create_process(lua_State* L) {\n    const char* cmd_line_utf8 = luaL_checkstring(L, 1);\n\n    // Default options\n    const char* current_dir_utf8 = NULL;\n    DWORD flags = 0;\n    BOOL inherit_handles = FALSE;\n    HANDLE explicit_stdin = NULL;\n    HANDLE explicit_stdout = NULL;\n    HANDLE explicit_stderr = NULL;\n    BOOL pipe_stdin = FALSE;\n    BOOL pipe_stdout = FALSE;\n    BOOL pipe_stderr = FALSE;\n\n    // Parse options table if provided\n    if (lua_type(L, 2) == LUA_TTABLE) {\n        lua_getfield(L, 2, \"current_directory\");\n        if (lua_type(L, -1) == LUA_TSTRING) {\n            current_dir_utf8 = lua_tostring(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"flags\");\n        if (lua_type(L, -1) == LUA_TNUMBER) {\n            flags = (DWORD)lua_tointeger(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"inherit_handles\");\n        if (lua_type(L, -1) == LUA_TBOOLEAN) {\n            inherit_handles = lua_toboolean(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"stdin_handle\");\n        if (lua_type(L, -1) == LUA_TLIGHTUSERDATA) {\n            explicit_stdin = lua_touserdata(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"stdout_handle\");\n        if (lua_type(L, -1) == LUA_TLIGHTUSERDATA) {\n            explicit_stdout = lua_touserdata(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"stderr_handle\");\n        if (lua_type(L, -1) == LUA_TLIGHTUSERDATA) {\n            explicit_stderr = lua_touserdata(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"pipe_stdin\");\n        if (lua_type(L, -1) == LUA_TBOOLEAN) {\n            pipe_stdin = lua_toboolean(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"pipe_stdout\");\n        if (lua_type(L, -1) == LUA_TBOOLEAN) {\n            pipe_stdout = lua_toboolean(L, -1);\n        }\n        lua_pop(L, 1);\n\n        lua_getfield(L, 2, \"pipe_stderr\");\n        if (lua_type(L, -1) == LUA_TBOOLEAN) {\n            pipe_stderr = lua_toboolean(L, -1);\n        }\n        lua_pop(L, 1);\n    }\n\n    // Convert UTF-8 strings to wide strings\n    wchar_t* cmd_line_w = utf8_to_wide_string(L, cmd_line_utf8);\n    if (!cmd_line_w) {\n        return push_error(L, \"Failed to convert command line to wide string\");\n    }\n    wchar_t* current_dir_w = NULL;\n    if (current_dir_utf8) {\n        current_dir_w = utf8_to_wide_string(L, current_dir_utf8);\n        if (!current_dir_w) {\n            free(cmd_line_w);\n            return push_error(L, \"Failed to convert current directory to wide string\");\n        }\n    }\n\n    // Handle pipes if requested\n    SECURITY_ATTRIBUTES sa;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = inherit_handles; // If we want the child to inherit, it must be inheritable\n    sa.lpSecurityDescriptor = NULL;\n\n    HANDLE stdin_read = NULL, stdin_write = NULL;\n    HANDLE stdout_read = NULL, stdout_write = NULL;\n    HANDLE stderr_read = NULL, stderr_write = NULL;\n\n    // Create pipes for stdin, stdout, stderr if requested\n    if (pipe_stdin) {\n        if (!CreatePipe(&stdin_read, &stdin_write, &sa, 0)) {\n            free(cmd_line_w); free(current_dir_w);\n            return push_error(L, \"Failed to create stdin pipe\");\n        }\n        if (!inherit_handles) {\n            SetHandleInformation(stdin_read, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit read handle\n            SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit write handle\n        }\n        explicit_stdin = stdin_read; // Use the read end for the child's stdin\n    }\n    if (pipe_stdout) {\n        if (!CreatePipe(&stdout_read, &stdout_write, &sa, 0)) {\n            free(cmd_line_w); free(current_dir_w);\n            if (stdin_read) CloseHandle(stdin_read); if (stdin_write) CloseHandle(stdin_write);\n            return push_error(L, \"Failed to create stdout pipe\");\n        }\n        if (!inherit_handles) {\n            SetHandleInformation(stdout_read, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit read handle\n            SetHandleInformation(stdout_write, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit write handle\n        }\n        explicit_stdout = stdout_write; // Use the write end for the child's stdout\n    }\n    if (pipe_stderr) {\n        if (!CreatePipe(&stderr_read, &stderr_write, &sa, 0)) {\n            free(cmd_line_w); free(current_dir_w);\n            if (stdin_read) CloseHandle(stdin_read); if (stdin_write) CloseHandle(stdin_write);\n            if (stdout_read) CloseHandle(stdout_read); if (stdout_write) CloseHandle(stdout_write);\n            return push_error(L, \"Failed to create stderr pipe\");\n        }\n        if (!inherit_handles) {\n            SetHandleInformation(stderr_read, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit read handle\n            SetHandleInformation(stderr_write, HANDLE_FLAG_INHERIT, 0); // Parent does not inherit write handle\n        }\n        explicit_stderr = stderr_write; // Use the write end for the child's stderr\n    }\n\n    STARTUPINFOW si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags = STARTF_USESTDHANDLES; // Tell CreateProcess we are specifying handles\n\n    // Set the handles based on explicit options or created pipes\n    si.hStdInput = explicit_stdin ? explicit_stdin : GetStdHandle(STD_INPUT_HANDLE);\n    si.hStdOutput = explicit_stdout ? explicit_stdout : GetStdHandle(STD_OUTPUT_HANDLE);\n    si.hStdError = explicit_stderr ? explicit_stderr : GetStdHandle(STD_ERROR_HANDLE);\n\n    BOOL success = CreateProcessW(\n        NULL,             // lpApplicationName (NULL lets command line handle it)\n        cmd_line_w,       // lpCommandLine (Must be writable)\n        NULL,             // lpProcessAttributes\n        NULL,             // lpThreadAttributes\n        inherit_handles,  // bInheritHandles (based on user option)\n        flags,            // dwCreationFlags (based on user option)\n        NULL,             // lpEnvironment (use parent's)\n        current_dir_w,    // lpCurrentDirectory (based on user option)\n        &si,              // lpStartupInfo (with handles set)\n        &pi               // lpProcessInformation (output)\n    );\n\n    DWORD last_error = 0;\n    if (!success) {\n        last_error = GetLastError();\n    }\n\n    // Cleanup wide strings\n    free(cmd_line_w);\n    if (current_dir_w) free(current_dir_w);\n\n    if (!success) {\n        // Cleanup pipes if process creation failed\n        if (stdin_read) CloseHandle(stdin_read);\n        if (stdin_write) CloseHandle(stdin_write);\n        if (stdout_read) CloseHandle(stdout_read);\n        if (stdout_write) CloseHandle(stdout_write);\n        if (stderr_read) CloseHandle(stderr_read);\n        if (stderr_write) CloseHandle(stderr_write);\n\n        // Convert error code to human-readable message\n        LPSTR message_buffer = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            last_error,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n            (LPSTR)&message_buffer,\n            0,\n            NULL\n        );\n\n        char error_msg[512];\n        if (message_buffer) {\n            snprintf(error_msg, sizeof(error_msg), \"CreateProcess failed: %s (Code: %lu)\", message_buffer, last_error);\n            LocalFree(message_buffer);\n        }\n        else {\n            snprintf(error_msg, sizeof(error_msg), \"CreateProcess failed with code %lu (Could not format message).\", last_error);\n        }\n        return push_error(L, error_msg);\n    }\n\n    // Process created successfully\n    // Close handles that the *parent* doesn't need\n    if (stdin_read) CloseHandle(stdin_read);\n    if (stdout_write) CloseHandle(stdout_write);\n    if (stderr_write) CloseHandle(stderr_write);\n\n    // Create return table\n    lua_createtable(L, 0, 6); // Pre-allocate space for known keys\n\n    lua_pushinteger(L, pi.dwProcessId);\n    lua_setfield(L, -2, \"pid\");\n\n    lua_pushlightuserdata(L, pi.hProcess);\n    lua_setfield(L, -2, \"hProcess\");\n\n    lua_pushlightuserdata(L, pi.hThread);\n    lua_setfield(L, -2, \"hThread\");\n\n    // Return the handles that the *parent* might need\n    if (stdin_read) {\n        lua_pushlightuserdata(L, stdin_read);\n        lua_setfield(L, -2, \"stdin_read\");\n    }\n    if (stdin_write) {\n        lua_pushlightuserdata(L, stdin_write);\n        lua_setfield(L, -2, \"stdin_write\");\n    }\n    if (stdout_read) {\n        lua_pushlightuserdata(L, stdout_read);\n        lua_setfield(L, -2, \"stdout_read\");\n    }\n    if (stdout_write) {\n        lua_pushlightuserdata(L, stdout_write);\n        lua_setfield(L, -2, \"stdout_write\");\n    }\n    if (stderr_read) {\n        lua_pushlightuserdata(L, stderr_read);\n        lua_setfield(L, -2, \"stderr_read\");\n    }\n    if (stderr_write) {\n        lua_pushlightuserdata(L, stderr_write);\n        lua_setfield(L, -2, \"stderr_write\");\n    }\n\n    lua_pushboolean(L, 1); // Success boolean\n    lua_insert(L, -2);     // Put success boolean before the table\n    return 2;              // Return success boolean and info table\n}\n\n\n\n/*\n * Lua C function: write_handle(handle, data)\n *\n * Writes data to a Windows HANDLE using WriteFile.\n *\n * Arguments:\n * 1. handle (lightuserdata): The HANDLE to write to (e.g., from create_process).\n * 2. data (string): The data to write.\n *\n * Returns:\n * 1. success (boolean): true if the write was successful, false otherwise.\n * 2. bytes_written_or_error (number or string): Number of bytes written on success,\n *                                             Error message string on failure.\n */\nstatic int l_write_handle(lua_State* L) {\n    // 1. Get the HANDLE from lightuserdata\n    HANDLE h_write = lua_touserdata(L, 1);\n    if (!h_write || h_write == INVALID_HANDLE_VALUE) {\n        return push_error(L, \"Invalid handle provided to write_handle\");\n    }\n\n    // 2. Get the data string to write\n    size_t data_len;\n    const char* data = luaL_checklstring(L, 2, &data_len);\n\n    // 3. Perform the WriteFile operation\n    DWORD bytes_written = 0;\n    BOOL success = WriteFile(\n        h_write,            // hFile\n        data,              // lpBuffer\n        (DWORD)data_len,   // nNumberOfBytesToWrite\n        &bytes_written,    // lpNumberOfBytesWritten (output)\n        NULL               // lpOverlapped (synchronous)\n    );\n\n    if (!success) {\n        // Get the last error code\n        DWORD last_error = GetLastError();\n\n        // Convert error code to human-readable message\n        LPSTR message_buffer = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            last_error,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n            (LPSTR)&message_buffer,\n            0,\n            NULL\n        );\n\n        char error_msg[512];\n        if (message_buffer) {\n            snprintf(error_msg, sizeof(error_msg), \"WriteFile failed: %s (Code: %lu)\", message_buffer, last_error);\n            LocalFree(message_buffer);\n        }\n        else {\n            snprintf(error_msg, sizeof(error_msg), \"WriteFile failed with code %lu (Could not format message).\", last_error);\n        }\n        return push_error(L, error_msg);\n    }\n\n    // Success: Return true and the number of bytes written\n    lua_pushboolean(L, 1);\n    lua_pushinteger(L, bytes_written);\n    return 2;\n}\n\n\n\n/*\n * Lua C function: peek_handle(handle)\n *\n * Checks if data is available for reading on a Windows HANDLE using PeekNamedPipe.\n *\n * Arguments:\n * 1. handle (lightuserdata): The HANDLE (pipe) to peek.\n *\n * Returns:\n * 1. has_data (boolean): true if data is available, false otherwise.\n * 2. bytes_available (number): Number of bytes available for reading.\n */\nstatic int l_peek_handle(lua_State* L) {\n    HANDLE h_read = lua_touserdata(L, 1);\n    if (!h_read || h_read == INVALID_HANDLE_VALUE) {\n        return push_error(L, \"Invalid handle provided to peek_handle\");\n    }\n\n    DWORD bytes_available = 0;\n    DWORD bytes_left = 0; // Number of bytes remaining in buffer (not necessarily available for this peek)\n    BOOL success = PeekNamedPipe(\n        h_read,             // hNamedPipe\n        NULL,               // lpBuffer (NULL to just get info)\n        0,                  // nBufferSize (0 as buffer is NULL)\n        NULL,               // lpBytesRead (NULL as buffer is NULL)\n        &bytes_available,   // lpTotalBytesAvail (output)\n        &bytes_left         // lpBytesLeftThisMessage (output)\n    );\n\n    if (!success) {\n        DWORD last_error = GetLastError();\n        // ERROR_BROKEN_PIPE might occur if the other end closed the pipe\n        if (last_error == ERROR_BROKEN_PIPE) {\n            lua_pushboolean(L, 0);\n            lua_pushinteger(L, 0);\n            return 2;\n        }\n        // Handle other errors if necessary, but for peeking, often just return 0, 0\n        // Or return an error if desired\n        // LPSTR message_buffer = NULL; ... (format error message)\n        // return push_error(L, message_buffer_or_error_string);\n        lua_pushboolean(L, 0);\n        lua_pushinteger(L, 0);\n        return 2;\n    }\n\n    lua_pushboolean(L, bytes_available > 0);\n    lua_pushinteger(L, bytes_available);\n    return 2;\n}\n\n\n/*\n * Lua C function: read_handle(handle, max_bytes)\n *\n * Reads data from a Windows HANDLE using ReadFile.\n *\n * Arguments:\n * 1. handle (lightuserdata): The HANDLE to read from (e.g., from create_process).\n * 2. max_bytes (number, optional): Maximum number of bytes to read. Defaults to 4096.\n *\n * Returns:\n * 1. data_or_nil (string or nil): The data read on success, nil on failure or EOF.\n * 2. bytes_read_or_error (number or string): Number of bytes read on success,\n *                                            Error message string on failure.\n *                                            If EOF/No data and no error, returns nil, 0.\n */\nstatic int l_read_handle(lua_State* L) {\n    // 1. Get the HANDLE from lightuserdata\n    HANDLE h_read = lua_touserdata(L, 1);\n    if (!h_read || h_read == INVALID_HANDLE_VALUE) {\n        return push_error(L, \"Invalid handle provided to read_handle\");\n    }\n\n    // 2. Get the maximum number of bytes to read (optional)\n    DWORD max_bytes = (DWORD)luaL_optinteger(L, 2, 32768); // Default to 32KB\n\n    // 3. Allocate buffer for reading\n    char* buffer = (char*)malloc(max_bytes);\n    if (!buffer) {\n        return push_error(L, \"Failed to allocate read buffer\");\n    }\n\n    // 4. Perform the ReadFile operation\n    DWORD bytes_read = 0;\n    BOOL success = ReadFile(\n        h_read,             // hFile\n        buffer,            // lpBuffer\n        max_bytes,         // nNumberOfBytesToRead\n        &bytes_read,       // lpNumberOfBytesRead (output)\n        NULL               // lpOverlapped (synchronous)\n    );\n\n    if (!success) {\n        DWORD last_error = GetLastError();\n\n        // ERROR_BROKEN_PIPE is expected if the other end (e.g., nvim) closes the pipe\n        if (last_error == ERROR_BROKEN_PIPE) {\n            free(buffer);\n            lua_pushnil(L); // No data\n            lua_pushinteger(L, 0); // 0 bytes read\n            return 2;\n        }\n\n        // Convert error code to human-readable message\n        LPSTR message_buffer = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            last_error,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n            (LPSTR)&message_buffer,\n            0,\n            NULL\n        );\n\n        char error_msg[512];\n        if (message_buffer) {\n            snprintf(error_msg, sizeof(error_msg), \"ReadFile failed: %s (Code: %lu)\", message_buffer, last_error);\n            LocalFree(message_buffer);\n        }\n        else {\n            snprintf(error_msg, sizeof(error_msg), \"ReadFile failed with code %lu (Could not format message).\", last_error);\n        }\n        free(buffer);\n        return push_error(L, error_msg);\n    }\n\n    // Success: Return the data read and the number of bytes\n    lua_pushlstring(L, buffer, bytes_read);\n    free(buffer);\n    lua_pushinteger(L, bytes_read);\n    return 2;\n}\n\n/*\n * Lua C function: close_handle(handle)\n *\n * Closes a Windows HANDLE using CloseHandle.\n * Use this to explicitly close handles returned by create_process when done.\n *\n * Arguments:\n * 1. handle (lightuserdata): The HANDLE to close.\n *\n * Returns:\n * 1. success (boolean): true if the handle was closed (or was already invalid), false on error.\n * 2. error_message (string, optional): Error message if closing failed.\n */\nstatic int l_close_handle(lua_State* L) {\n    HANDLE h_to_close = lua_touserdata(L, 1);\n    if (!h_to_close || h_to_close == INVALID_HANDLE_VALUE) {\n        // Treat invalid handles as already \"closed\"\n        lua_pushboolean(L, 1);\n        return 1;\n    }\n\n    BOOL success = CloseHandle(h_to_close);\n\n    if (!success) {\n        DWORD last_error = GetLastError();\n\n        LPSTR message_buffer = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n            NULL,\n            last_error,\n            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n            (LPSTR)&message_buffer,\n            0,\n            NULL\n        );\n\n        char error_msg[512];\n        if (message_buffer) {\n            snprintf(error_msg, sizeof(error_msg), \"CloseHandle failed: %s (Code: %lu)\", message_buffer, last_error);\n            LocalFree(message_buffer);\n        }\n        else {\n            snprintf(error_msg, sizeof(error_msg), \"CloseHandle failed with code %lu (Could not format message).\", last_error);\n        }\n        lua_pushboolean(L, 0);\n        lua_pushstring(L, error_msg);\n        return 2;\n    }\n\n    lua_pushboolean(L, 1);\n    return 1;\n}\n\n\n```",
            "created_at": "2025-11-19T04:37:50Z",
            "html_url": "https://github.com/neovim/neovim/issues/36598#issuecomment-3550738386",
            "id": 3550738386,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36598",
            "node_id": "IC_kwDOAPphoM7To_fS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3550738386/reactions"
            },
            "updated_at": "2025-11-19T04:42:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3550738386",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
                "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
                "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
                "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
                "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Universal-Invariant",
                "id": 202556375,
                "login": "Universal-Invariant",
                "node_id": "U_kgDODBLD1w",
                "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
                "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
                "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Universal-Invariant",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 8,
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/36598/comments",
    "created_at": "2025-11-18T00:46:15Z",
    "events_url": "https://api.github.com/repos/neovim/neovim/issues/36598/events",
    "html_url": "https://github.com/neovim/neovim/issues/36598",
    "id": 3635615149,
    "issue_dependencies_summary": {
        "blocked_by": 0,
        "blocking": 0,
        "total_blocked_by": 0,
        "total_blocking": 0
    },
    "labels": [
        {
            "color": "d4c5f9",
            "default": false,
            "description": null,
            "id": 109461219,
            "name": "platform:windows",
            "node_id": "MDU6TGFiZWwxMDk0NjEyMTk=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/platform:windows"
        },
        {
            "color": "c7def8",
            "default": false,
            "description": "channels, RPC, msgpack",
            "id": 242522707,
            "name": "channels-rpc",
            "node_id": "MDU6TGFiZWwyNDI1MjI3MDc=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/channels-rpc"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": "startup, shutdown, attach, detach",
            "id": 870629450,
            "name": "lifecycle",
            "node_id": "MDU6TGFiZWw4NzA2Mjk0NTA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lifecycle"
        },
        {
            "color": "C5DEF5",
            "default": false,
            "description": "",
            "id": 6212014172,
            "name": "embedding",
            "node_id": "LA_kwDOAPphoM8AAAABckPQXA",
            "url": "https://api.github.com/repos/neovim/neovim/labels/embedding"
        }
    ],
    "labels_url": "https://api.github.com/repos/neovim/neovim/issues/36598/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "I_kwDOAPphoM7YsxWt",
    "number": 36598,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/neovim/neovim/issues/36598/reactions"
    },
    "repository_url": "https://api.github.com/repos/neovim/neovim",
    "state": "closed",
    "state_reason": "completed",
    "sub_issues_summary": {
        "completed": 0,
        "percent_completed": 0,
        "total": 0
    },
    "timeline_url": "https://api.github.com/repos/neovim/neovim/issues/36598/timeline",
    "title": "embed cause nvim to immediately terminate",
    "type": null,
    "updated_at": "2025-11-19T04:48:57Z",
    "url": "https://api.github.com/repos/neovim/neovim/issues/36598",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/202556375?v=4",
        "events_url": "https://api.github.com/users/Universal-Invariant/events{/privacy}",
        "followers_url": "https://api.github.com/users/Universal-Invariant/followers",
        "following_url": "https://api.github.com/users/Universal-Invariant/following{/other_user}",
        "gists_url": "https://api.github.com/users/Universal-Invariant/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/Universal-Invariant",
        "id": 202556375,
        "login": "Universal-Invariant",
        "node_id": "U_kgDODBLD1w",
        "organizations_url": "https://api.github.com/users/Universal-Invariant/orgs",
        "received_events_url": "https://api.github.com/users/Universal-Invariant/received_events",
        "repos_url": "https://api.github.com/users/Universal-Invariant/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/Universal-Invariant/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Universal-Invariant/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/Universal-Invariant",
        "user_view_type": "public"
    }
}