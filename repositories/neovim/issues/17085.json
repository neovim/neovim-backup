{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "body": "### Neovim version (nvim -v)\r\n\r\nNVIM v0.7.0-dev+758-g0c35fd5fc\r\n\r\n### Language server name/version\r\n\r\nclangd 13 (and trunk)\r\n\r\n### Operating system/version\r\n\r\ndebian testing\r\n\r\n### Steps to reproduce using \"nvim -u minimal_init.lua\"\r\n\r\nCreate \"blank.cc\" containing\r\n```\r\na\r\nb\r\n```\r\n\r\nThen run `env CLANGD_FLAGS=-input-mirror-file=/tmp/mirror nvim -u minimal_init.lua` and:\r\n```\r\n:lua require'lspconfig'.clangd.setup{}\r\n:e ~/blank.cc\r\nVjdia<esc>o<esc>\r\n:lua vim.lsp.buf.hover()\r\n```\r\n\r\n### Expected behavior\r\n\r\nnvim and clangd should agree on the contents of the file and the hover request should succeed (but return nothing useful as the file is not valid C++).\r\n\r\n### Actual behavior\r\n\r\n- nvim sends an invalid incremental update to the file (for the insertion of the newline)\r\n- clangd logs an error, but cannot return an error code as didChange is a notification with no response\r\n- clangd drops the file, as there's no way for a server to recover once it fails to apply an incremental update.\r\n- The hover request (and any subsequent request) fails with \"Invalid AST\", indicating clangd doesn't know about the document.\r\n\r\nThe [raw client->server LSP traffic](https://gist.github.com/sam-mccall/c22f35083fde82f258a690cf3f35ddfe) is captured in /tmp/mirror. Here's an annotated summary:\r\n\r\n```\r\n# Here's a file with two lines.\r\n# Content is \"a\\nb\\n\".\r\n{\r\n  \"method\":\"textDocument/didOpen\",\r\n  \"params\":{\"textDocument\":{\"text\":\"a\\nb\\n\",\"version\":0,\"uri\":\"blank.cc\"}}\r\n}\r\n\r\n# I'm deleting both lines, including newlines.\r\n# Afterwards, content is \"\" (no newline at eof).\r\n{\r\n  \"method\":\"textDocument/didChange\",\r\n  \"params\":{\r\n    \"contentChanges\":[{\"text\":\"\",\"rangeLength\":4,\"range\":{\r\n      \"start\":{\"line\":0,\"character\":0},\r\n      \"end\":{\"line\":2,\"character\":0}\r\n    }}],\r\n    \"textDocument\":{\"uri\":\"blank.cc\",\"version\":5}\r\n  }\r\n}\r\n\r\n# I'm inserting 'a' on the first line.\r\n# Afterwards, content is \"a\" (no newline at eof).\r\n{\r\n  \"method\":\"textDocument/didChange\",\r\n  \"params\":{\r\n    \"contentChanges\":[{\"text\":\"a\",\"rangeLength\":0,\"range\":{\r\n      \"start\":{\"line\":0,\"character\":0},\r\n      \"end\":{\"line\":0,\"character\":0}\r\n    }}],\r\n    \"textDocument\":{\"uri\":\"blank.cc\",\"version\":6}\r\n  }\r\n}\r\n\r\n# I'm inserting \"\\n\" at line 1\r\n# >>> THIS IS INVALID, ONLY LINE 0 EXISTS <<<\r\n{\r\n  \"method\":\"textDocument\\/didChange\",\r\n  \"params\":{\r\n    \"contentChanges\":[{\"text\":\"\\n\",\"range\":{\r\n      \"end\":{\"character\":0,\"line\":1},\r\n      \"start\":{\"character\":0,\"line\":1}\r\n    },\"rangeLength\":0}],\r\n    \"textDocument\":{\"uri\":\"blank.cc\",\"version\":7}\r\n  }\r\n}\r\n```\r\n\r\nI do have vague memories of the `o` command being particularly problematic for text syncing (from working on an old vim LSP client). My notes say:\r\n```\r\n  \" If you use o/c etc to enter insert mode, the event sequence is bizarre:\r\n  \" The InsertEnter comes first, then a CursorMovedI+TextChangedI.\r\n  \" However the text/position change is already visible to InsertEnter!\r\n```\r\nNot sure if this is still true with current neovim, but it seems to fit the symptoms...\r\n\r\n### Log file\r\n\r\n_No response_",
    "closed_at": "2022-03-08T18:41:20Z",
    "closed_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/13316262?v=4",
        "events_url": "https://api.github.com/users/mjlbach/events{/privacy}",
        "followers_url": "https://api.github.com/users/mjlbach/followers",
        "following_url": "https://api.github.com/users/mjlbach/following{/other_user}",
        "gists_url": "https://api.github.com/users/mjlbach/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/mjlbach",
        "id": 13316262,
        "login": "mjlbach",
        "node_id": "MDQ6VXNlcjEzMzE2MjYy",
        "organizations_url": "https://api.github.com/users/mjlbach/orgs",
        "received_events_url": "https://api.github.com/users/mjlbach/received_events",
        "repos_url": "https://api.github.com/users/mjlbach/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/mjlbach/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mjlbach/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/mjlbach",
        "user_view_type": "public"
    },
    "comment_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "Thanks, I ran into this in both incremental sync implementations (I think I implemented a workaround in v1, but I need to check). I don't have time to look into this right now, but leaving some notes. Vim's handling of newlines generally has some gotchas, like blank vs. non-blank first lines. If you save an empty buffer to disk, the file is written without a new line, if you save a single space, this is written as a newline.\r\n\r\nI think the main issue with this is when we delete all lines, we wipe all new-line characters. When we add the first new character to line 0, a, I think we technically need to postpend with a newline character such that the server side representation of the buffer matches the following. Some servers (you would know better than I about clangd) expect the server and disk representation of buffer state to match and will crash if not (*julia...*).\r\n\r\nState 1:\r\n```\r\na\\n\r\nb\\n\r\n```\r\nState 2 (empty buffer):\r\n```\r\n```\r\n\r\nState 3 (add a, note the addition of a newline character not typed but implicitly created by (neo)vim)\r\n```\r\na\\n\r\n```\r\n\r\nState 4 (o, note the)\r\n```\r\na\\n\r\n\\n\r\n```\r\n\r\nWhile this will work for now, it will be a huge pain if we switch to byte tracking...",
            "created_at": "2022-01-14T20:54:45Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-1013467161",
            "id": 1013467161,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM48aEgZ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013467161/reactions"
            },
            "updated_at": "2022-01-14T20:57:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013467161",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/13316262?v=4",
                "events_url": "https://api.github.com/users/mjlbach/events{/privacy}",
                "followers_url": "https://api.github.com/users/mjlbach/followers",
                "following_url": "https://api.github.com/users/mjlbach/following{/other_user}",
                "gists_url": "https://api.github.com/users/mjlbach/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mjlbach",
                "id": 13316262,
                "login": "mjlbach",
                "node_id": "MDQ6VXNlcjEzMzE2MjYy",
                "organizations_url": "https://api.github.com/users/mjlbach/orgs",
                "received_events_url": "https://api.github.com/users/mjlbach/received_events",
                "repos_url": "https://api.github.com/users/mjlbach/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mjlbach/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mjlbach/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mjlbach",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Some servers (you would know better than I about clangd) expect the server and disk representation of buffer state to match and will crash if not (julia...).\r\n\r\nAh, I dug up that bug. That sounds fiddly to manage if nvim's model of text is \"array of lines\" rather than \"string\" :-( Clangd doesn't care, operations on file F never read F from disk.",
            "created_at": "2022-01-14T21:25:22Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-1013483924",
            "id": 1013483924,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM48aImU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013483924/reactions"
            },
            "updated_at": "2022-01-14T21:25:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013483924",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/548993?v=4",
                "events_url": "https://api.github.com/users/sam-mccall/events{/privacy}",
                "followers_url": "https://api.github.com/users/sam-mccall/followers",
                "following_url": "https://api.github.com/users/sam-mccall/following{/other_user}",
                "gists_url": "https://api.github.com/users/sam-mccall/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sam-mccall",
                "id": 548993,
                "login": "sam-mccall",
                "node_id": "MDQ6VXNlcjU0ODk5Mw==",
                "organizations_url": "https://api.github.com/users/sam-mccall/orgs",
                "received_events_url": "https://api.github.com/users/sam-mccall/received_events",
                "repos_url": "https://api.github.com/users/sam-mccall/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sam-mccall/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sam-mccall/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sam-mccall",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Yes, it's mostly fine but I had to implement special handling for end-of-line, line-endings, etc. I think it's *mostly* correct now, although for synchronization you ran into the case where it is not :( ",
            "created_at": "2022-01-14T21:43:53Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-1013494116",
            "id": 1013494116,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM48aLFk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013494116/reactions"
            },
            "updated_at": "2022-01-14T21:43:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1013494116",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/13316262?v=4",
                "events_url": "https://api.github.com/users/mjlbach/events{/privacy}",
                "followers_url": "https://api.github.com/users/mjlbach/followers",
                "following_url": "https://api.github.com/users/mjlbach/following{/other_user}",
                "gists_url": "https://api.github.com/users/mjlbach/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mjlbach",
                "id": 13316262,
                "login": "mjlbach",
                "node_id": "MDQ6VXNlcjEzMzE2MjYy",
                "organizations_url": "https://api.github.com/users/mjlbach/orgs",
                "received_events_url": "https://api.github.com/users/mjlbach/received_events",
                "repos_url": "https://api.github.com/users/mjlbach/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mjlbach/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mjlbach/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mjlbach",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@sam-mccall I think this was fixed by #17606 and #17610, let me know if this is not the case :)",
            "created_at": "2022-03-08T18:41:20Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-1062088470",
            "id": 1062088470,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM4_Ti8W",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1062088470/reactions"
            },
            "updated_at": "2022-03-08T18:41:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1062088470",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/13316262?v=4",
                "events_url": "https://api.github.com/users/mjlbach/events{/privacy}",
                "followers_url": "https://api.github.com/users/mjlbach/followers",
                "following_url": "https://api.github.com/users/mjlbach/following{/other_user}",
                "gists_url": "https://api.github.com/users/mjlbach/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mjlbach",
                "id": 13316262,
                "login": "mjlbach",
                "node_id": "MDQ6VXNlcjEzMzE2MjYy",
                "organizations_url": "https://api.github.com/users/mjlbach/orgs",
                "received_events_url": "https://api.github.com/users/mjlbach/received_events",
                "repos_url": "https://api.github.com/users/mjlbach/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mjlbach/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mjlbach/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mjlbach",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Oh no, I believe I had verified this was fixed, but it doesn't seem to be now, either in 0.7.0 or at current master. I can't reopen this, can you? Also happy to file a new bug.\r\n\r\nI have a simpler reproducer: open a blank file, insert `x`, then `dd`, then `o`.\r\n(It also works to start with `x` already in the file, but the edits are illustrative)\r\n\r\nThe sequence sent is:\r\n- didOpen: text=\"\\n\"\r\n- didChange: range={start=0:0, end=0:0}, rangeLength=0, text=\"x\" (now file is \"x\\n\")\r\n- didChange: range={start=0:0, end=1:0}, rangeLength=2, text=\"\" (now file is \"\")\r\n- didChange: range={start=0:0, end=1:0}, rangeLength=1, text=\"\\n\\n\" (**invalid**: at 0:0 there is no substring of length 1 to replace)\r\n\r\nIt definitely appears to be the second didChange (`dd`) that is the bug. The original empty file was sent with text=\"\\n\". After `dd` the editor is back in that same state, but instead of telling the server the text is \"\\n\" we say there's no text. Then the next edit tries to replace the newline that isn't there.\r\n\r\nIn case it's interesting, VSCode's behavior is as follows (no trailing newlines):\r\n- didOpen: text=\"\",\r\n- didChange: range={start=0:0, end=0:0}, rangeLength=0, text=\"x\" (now file is \"x\")\r\n- didChange: range={start=0:0, end=0:1}, rangeLength=1, text=\"\" (now file is \"\")\r\n- didChange: range={start=0:0, end=0:0}, rangeLength=0, text=\"\\n\" (now file is \"\\n\")",
            "created_at": "2022-10-06T00:54:44Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-1269162264",
            "id": 1269162264,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM5LpeEY",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1269162264/reactions"
            },
            "updated_at": "2022-10-06T00:54:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1269162264",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/548993?v=4",
                "events_url": "https://api.github.com/users/sam-mccall/events{/privacy}",
                "followers_url": "https://api.github.com/users/sam-mccall/followers",
                "following_url": "https://api.github.com/users/sam-mccall/following{/other_user}",
                "gists_url": "https://api.github.com/users/sam-mccall/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/sam-mccall",
                "id": 548993,
                "login": "sam-mccall",
                "node_id": "MDQ6VXNlcjU0ODk5Mw==",
                "organizations_url": "https://api.github.com/users/sam-mccall/orgs",
                "received_events_url": "https://api.github.com/users/sam-mccall/received_events",
                "repos_url": "https://api.github.com/users/sam-mccall/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/sam-mccall/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/sam-mccall/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/sam-mccall",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@sam-mccall  Not sure if this is related. I recently had the clangd didchange not syncing issue as well. I'll reopen this issue if you still have issues\n\n```log\n[START][2025-05-03 16:48:24] LSP logging initiated\n[INFO][2025-05-03 16:48:24] .../vim/lsp/rpc.lua:597\t\"Starting RPC client\"\t{ cmd = { \"clangd\", \"--log=verbose\" }, extra = {} }\n[ERROR][2025-05-03 16:48:24] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'I[16:48:24.882] Homebrew clangd version 20.1.3\\nI[16:48:24.883] Features: mac+xpc\\nI[16:48:24.883] PID: 15824\\nI[16:48:24.883] Working directory: /Users/mw/workspace/neovim\\nI[16:48:24.883] argv[0]: clangd\\nI[16:48:24.883] argv[1]: --log=verbose\\nV[16:48:24.883] User config file is /Users/mw/Library/Preferences/clangd/config.yaml\\nI[16:48:24.883] Starting LSP over stdin/stdout\\nV[16:48:24.883] <<< {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"initialize\",\"params\":{\"capabilities\":{\"general\":{\"positionEncodings\":[\"utf-8\",\"utf-16\",\"utf-32\"]},\"offsetEncoding\":[\"utf-8\",\"utf-16\"],\"textDocument\":{\"callHierarchy\":{\"dynamicRegistration\":false},\"codeAction\":{\"codeActionLiteralSupport\":{\"codeActionKind\":{\"valueSet\":[\"\",\"quickfix\",\"refactor\",\"refactor.extract\",\"refactor.inline\",\"refactor.rewrite\",\"source\",\"source.organizeImports\"]}},\"dataSupport\":true,\"dynamicRegistration\":true,\"isPreferredSupport\":true,\"resolveSupport\":{\"properties\":[\"edit\",\"command\"]}},\"codeLens\":{\"dynamicRegistration\":false,\"resolveSupport\":{\"properties\":[\"command\"]}},\"colorProvider\":{\"dynamicRegistration\":false},\"completion\":{\"completionItem\":{\"commitCharactersSupport\":false,\"deprecatedSupport\":true,\"documentationFormat\":[\"markdown\",\"plaintext\"],\"preselectSupport\":false,\"resolveSupport\":{\"properties\":[\"additionalTextEdits\",\"command\"]},\"snippetSupport\":true,\"tagSupport\":{\"valueSet\":[1]}},\"completionItemKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]},\"completionList\":{\"itemDefaults\":[\"editRange\",\"insertTextFormat\",\"insertTextMode\",\"data\"]},\"contextSupport\":true,\"dynamicRegistration\":false,\"editsNearCursor\":true},\"declaration\":{\"linkSupport\":true},\"definition\":{\"dynamicRegistration\":true,\"linkSupport\":true},\"diagnostic\":{\"dynamicRegistration\":false},\"documentHighlight\":{\"dynamicRegistration\":false},\"documentSymbol\":{\"dynamicRegistration\":false,\"hierarchicalDocumentSymbolSupport\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"foldingRange\":{\"dynamicRegistration\":false,\"foldingRange\":{\"collapsedText\":true},\"lineFoldingOnly\":true},\"formatting\":{\"dynamicRegistration\":true},\"hover\":{\"contentFormat\":[\"markdown\",\"plaintext\"],\"dynamicRegistration\":true},\"implementation\":{\"linkSupport\":true},\"inlayHint\":{\"dynamicRegistration\":true,\"resolveSupport\":{\"properties\":[\"textEdits\",\"tooltip\",\"location\",\"command\"]}},\"publishDiagnostics\":{\"dataSupport\":true,\"relatedInformation\":true,\"tagSupport\":{\"valueSet\":[1,2]}},\"rangeFormatting\":{\"dynamicRegistration\":true,\"rangesSupport\":true},\"references\":{\"dynamicRegistration\":false},\"rename\":{\"dynamicRegistration\":true,\"prepareSupport\":true},\"semanticTokens\":{\"augmentsSyntaxTokens\":true,\"dynamicRegistration\":false,\"formats\":[\"relative\"],\"multilineTokenSupport\":false,\"overlappingTokenSupport\":true,\"requests\":{\"full\":{\"delta\":true},\"range\":false},\"serverCancelSupport\":false,\"tokenModifiers\":[\"declaration\",\"definition\",\"readonly\",\"static\",\"deprecated\",\"abstract\",\"async\",\"modification\",\"documentation\",\"defaultLibrary\"],\"tokenTypes\":[\"namespace\",\"type\",\"class\",\"enum\",\"interface\",\"struct\",\"typeParameter\",\"parameter\",\"variable\",\"property\",\"enumMember\",\"event\",\"function\",\"method\",\"macro\",\"keyword\",\"modifier\",\"comment\",\"string\",\"number\",\"regexp\",\"operator\",\"decorator\"]},\"signatureHelp\":{\"dynamicRegistration\":false,\"signatureInformation\":{\"activeParameterSupport\":true,\"documentationFormat\":[\"markdown\",\"plaintext\"],\"parameterInformation\":{\"labelOffsetSupport\":true}}},\"synchronization\":{\"didSave\":true,\"dynamicRegistration\":false,\"willSave\":true,\"willSaveWaitUntil\":true},\"typeDefinition\":{\"linkSupport\":true}},\"window\":{\"showDocument\":{\"support\":true},\"showMessage\":{\"messageActionItem\":{\"additionalPropertiesSupport\":true}},\"workDoneProgress\":true},\"workspace\":{\"applyEdit\":true,\"configuration\":true,\"didChangeConfiguration\":{\"dynamicRegistration\":false},\"didChangeWatchedFiles\":{\"dynamicRegistration\":true,\"relativePatternSupport\":true},\"inlayHint\":{\"refreshSupport\":true},\"semanticTokens\":{\"refreshSupport\":true},\"symbol\":{\"dynamicRegistration\":false,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"workspaceEdit\":{\"resourceOperations\":[\"rename\",\"create\",\"delete\"]},\"workspaceFolders\":true}},\"clientInfo\":{\"name\":\"Neovim\",\"version\":\"0.12.0-dev+Homebrew\"},\"processId\":15822,\"rootPath\":\"/Users/mw/workspace/neovim\",\"rootUri\":\"file:///Users/mw/workspace/neovim\",\"trace\":\"off\",\"workDoneToken\":\"1\",\"workspaceFolders\":[{\"name\":\"/Users/mw/workspace/neovim\",\"uri\":\"file:///Users/mw/workspace/neovim\"}]}}\\n\\nI[16:48:24.883] <-- initialize(1)\\nV[16:48:24.883] Invoking /usr/bin/xcrun to find clang installation\\n'\n[ERROR][2025-05-03 16:48:24] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:24.889] Invoking /usr/bin/xcrun to find clang installation\\nI[16:48:24.894] --> reply:initialize(1) 10 ms\\nV[16:48:24.894] >>> {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":{\"capabilities\":{\"astProvider\":true,\"callHierarchyProvider\":true,\"clangdInlayHintsProvider\":true,\"codeActionProvider\":{\"codeActionKinds\":[\"quickfix\",\"refactor\",\"info\"]},\"compilationDatabase\":{\"automaticReload\":true},\"completionProvider\":{\"resolveProvider\":false,\"triggerCharacters\":[\".\",\"<\",\">\",\":\",\"\\\\\"\",\"/\",\"*\"]},\"declarationProvider\":true,\"definitionProvider\":true,\"documentFormattingProvider\":true,\"documentHighlightProvider\":true,\"documentLinkProvider\":{\"resolveProvider\":false},\"documentOnTypeFormattingProvider\":{\"firstTriggerCharacter\":\"\\\\n\",\"moreTriggerCharacter\":[]},\"documentRangeFormattingProvider\":true,\"documentSymbolProvider\":true,\"executeCommandProvider\":{\"commands\":[\"clangd.applyFix\",\"clangd.applyRename\",\"clangd.applyTweak\"]},\"foldingRangeProvider\":true,\"hoverProvider\":true,\"implementationProvider\":true,\"inactiveRegionsProvider\":true,\"inlayHintProvider\":true,\"memoryUsageProvider\":true,\"referencesProvider\":true,\"renameProvider\":{\"prepareProvider\":true},\"selectionRangeProvider\":true,\"semanticTokensProvider\":{\"full\":{\"delta\":true},\"legend\":{\"tokenModifiers\":[\"declaration\",\"definition\",\"deprecated\",\"deduced\",\"readonly\",\"static\",\"abstract\",\"virtual\",\"dependentName\",\"defaultLibrary\",\"usedAsMutableReference\",\"usedAsMutablePointer\",\"constructorOrDestructor\",\"userDefined\",\"functionScope\",\"classScope\",\"fileScope\",\"globalScope\"],\"tokenTypes\":[\"variable\",\"variable\",\"parameter\",\"function\",\"method\",\"function\",\"property\",\"variable\",\"class\",\"interface\",\"enum\",\"enumMember\",\"type\",\"type\",\"unknown\",\"namespace\",\"typeParameter\",\"concept\",\"type\",\"macro\",\"modifier\",\"operator\",\"bracket\",\"label\",\"comment\"]},\"range\":false},\"signatureHelpProvider\":{\"triggerCharacters\":[\"(\",\")\",\"{\",\"}\",\"<\",\">\",\",\"]},\"standardTypeHierarchyProvider\":true,\"textDocumentSync\":{\"change\":2,\"openClose\":true,\"save\":true},\"typeDefinitionProvider\":true,\"typeHierarchyProvider\":true,\"workspaceSymbolProvider\":true},\"offsetEncoding\":\"utf-8\",\"serverInfo\":{\"name\":\"clangd\",\"version\":\"Homebrew clangd version 20.1.3 mac+xpc arm64-apple-darwin24.4.0\"}}}\\n\\n'\n[INFO][2025-05-03 16:48:24] ...m/lsp/client.lua:577\t\"LSP[phoenix]\"\t\"server_capabilities\"\t{ server_capabilities = { completionProvider = { resolveProvider = false, triggerCharacters = { \"/\" } }, textDocumentSync = { change = 1, openClose = true } } }\n[INFO][2025-05-03 16:48:24] ...m/lsp/client.lua:577\t\"LSP[clangd]\"\t\"server_capabilities\"\t{ server_capabilities = { astProvider = true, callHierarchyProvider = true, clangdInlayHintsProvider = true, codeActionProvider = { codeActionKinds = { \"quickfix\", \"refactor\", \"info\" } }, compilationDatabase = { automaticReload = true }, completionProvider = { resolveProvider = false, triggerCharacters = { \".\", \"<\", \">\", \":\", '\"', \"/\", \"*\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\" } }, declarationProvider = true, definitionProvider = true, documentFormattingProvider = true, documentHighlightProvider = true, documentLinkProvider = { resolveProvider = false }, documentOnTypeFormattingProvider = { firstTriggerCharacter = \"\\n\", moreTriggerCharacter = {} }, documentRangeFormattingProvider = true, documentSymbolProvider = true, executeCommandProvider = { commands = { \"clangd.applyFix\", \"clangd.applyRename\", \"clangd.applyTweak\" } }, foldingRangeProvider = true, hoverProvider = true, implementationProvider = true, inactiveRegionsProvider = true, inlayHintProvider = true, memoryUsageProvider = true, referencesProvider = true, renameProvider = { prepareProvider = true }, selectionRangeProvider = true, signatureHelpProvider = { triggerCharacters = { \"(\", \")\", \"{\", \"}\", \"<\", \">\", \",\" } }, standardTypeHierarchyProvider = true, textDocumentSync = { change = 2, openClose = true, save = true }, typeDefinitionProvider = true, typeHierarchyProvider = true, workspaceSymbolProvider = true } }\n[ERROR][2025-05-03 16:48:24] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:24.915] <<< {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"initialized\\\",\\\"params\\\":{}}\\n\\nI[16:48:24.915] <-- initialized\\nV[16:48:24.916] <<< {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"textDocument/didOpen\\\",\\\"params\\\":{\\\"textDocument\\\":{\\\"languageId\\\":\\\"c\\\",\\\"text\\\":\\\"#include <assert.h>\\\\n#include <stdbool.h>\\\\n#include <string.h>\\\\n\\\\n#include \\\\\\\"klib/kvec.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/extmark.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/keysets_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/dispatch.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/helpers.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/win_config.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ascii_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/autocmd.h\\\\\\\"\\\\n#include \\\\\\\"nvim/autocmd_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/buffer.h\\\\\\\"\\\\n#include \\\\\\\"nvim/buffer_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/decoration_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/drawscreen.h\\\\\\\"\\\\n#include \\\\\\\"nvim/errors.h\\\\\\\"\\\\n#include \\\\\\\"nvim/eval/window.h\\\\\\\"\\\\n#include \\\\\\\"nvim/globals.h\\\\\\\"\\\\n#include \\\\\\\"nvim/highlight_group.h\\\\\\\"\\\\n#include \\\\\\\"nvim/macros_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/mbyte.h\\\\\\\"\\\\n#include \\\\\\\"nvim/memory.h\\\\\\\"\\\\n#include \\\\\\\"nvim/memory_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/option.h\\\\\\\"\\\\n#include \\\\\\\"nvim/option_vars.h\\\\\\\"\\\\n#include \\\\\\\"nvim/pos_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/strings.h\\\\\\\"\\\\n#include \\\\\\\"nvim/syntax.h\\\\\\\"\\\\n#include \\\\\\\"nvim/types_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ui.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ui_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/vim_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/window.h\\\\\\\"\\\\n#include \\\\\\\"nvim/winfloat.h\\\\\\\"\\\\n\\\\n#ifdef INCLUDE_GENERATED_DECLARATIONS\\\\n# include \\\\\\\"api/win_config.c.generated.h\\\\\\\"\\\\n#endif\\\\n\\\\n/// Opens a new split window, or a floating window if `relative` is specified,\\\\n/// or an external window (managed by the UI) if `external` is specified.\\\\n///\\\\n/// Floats are windows that are drawn above the split layout, at some anchor\\\\n/// position in some other window. Floats can be drawn internally or by external\\\\n/// GUI with the |ui-multigrid| extension. External windows are only supported\\\\n/// with multigrid GUIs, and are displayed as separate top-level windows.\\\\n///\\\\n/// For a general overview of floats, see |api-floatwin|.\\\\n///\\\\n/// The `width` and `height` of the new window must be specified when opening\\\\n/// a floating window, but are optional for normal windows.\\\\n///\\\\n/// If `relative` and `external` are omitted, a normal \\\\\\\"split\\\\\\\" window is created.\\\\n/// The `win` property determines which window will be split. If no `win` is\\\\n/// provided or `win == 0`, a window will be created adjacent to the current window.\\\\n/// If -1 is provided, a top-level split will be created. `vertical` and `split` are\\\\n/// only valid for normal windows, and are used to control split direction. For `vertical`,\\\\n/// the exact direction is determined by |'splitright'| and |'splitbelow'|.\\\\n/// Split windows cannot have `bufpos`/`row`/`col`/`border`/`title`/`footer`\\\\n/// properties.\\\\n///\\\\n/// With relative=editor (row=0,col=0) refers to the top-left corner of the\\\\n/// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right\\\\n/// corner. Fractional values are allowed, but the builtin implementation\\\\n/// (used by non-multigrid UIs) will always round down to nearest integer.\\\\n///\\\\n/// Out-of-bounds values, and configurations that make the float not fit inside\\\\n/// the main editor, are allowed. The builtin implementation truncates values\\\\n/// so floats are fully within the main screen grid. External GUIs\\\\n/// could let floats hover outside of the main window like a tooltip, but\\\\n/// this should not be used to specify arbitrary WM screen positions.\\\\n///\\\\n/// Example (Lua): window-relative float\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false,\\\\n///   {relative='win', row=3, col=3, width=12, height=3})\\\\n/// ```\\\\n///\\\\n/// Example (Lua): buffer-relative float (travels as buffer is scrolled)\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false,\\\\n///   {relative='win', width=12, height=3, bufpos={100,10}})\\\\n/// ```\\\\n///\\\\n/// Example (Lua): vertical split left of the current window\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false, {\\\\n///   split = 'left',\\\\n///   win = 0\\\\n/// })\\\\n/// ```\\\\n///\\\\n/// @param buffer Buffer to display, or 0 for current buffer\\\\n/// @param enter  Enter the window (make it the current window)\\\\n/// @param config Map defining the window configuration. Keys:\\\\n///   - relative: Sets the window layout to \\\\\\\"floating\\\\\\\", placed at (row,col)\\\\n///                 coordinates relative to:\\\\n///      - \\\\\\\"cursor\\\\\\\"     Cursor position in current window.\\\\n///      - \\\\\\\"editor\\\\\\\"     The global editor grid.\\\\n///      - \\\\\\\"laststatus\\\\\\\" 'laststatus' if present, or last row.\\\\n///      - \\\\\\\"mouse\\\\\\\"      Mouse position.\\\\n///      - \\\\\\\"tabline\\\\\\\"    Tabline if present, or first row.\\\\n///      - \\\\\\\"win\\\\\\\"        Window given by the `win` field, or current window.\\\\n///   - win: |window-ID| window to split, or relative window when creating a\\\\n///      float (relative=\\\\\\\"win\\\\\\\").\\\\n///   - anchor: Decides which corner of the float to place at (row,col):\\\\n///      - \\\\\\\"NW\\\\\\\" northwest (default)\\\\n///      - \\\\\\\"NE\\\\\\\" northeast\\\\n///      - \\\\\\\"SW\\\\\\\" southwest\\\\n///      - \\\\\\\"SE\\\\\\\" southeast\\\\n///   - width: Window width (in character cells). Minimum of 1.\\\\n///   - height: Window height (in character cells). Minimum of 1.\\\\n///   - bufpos: Places float relative to buffer text (only when\\\\n///       relative=\\\\\\\"win\\\\\\\"). Takes a tuple of zero-indexed `[line, column]`.\\\\n///       `row` and `col` if given are applied relative to this\\\\n///       position, else they default to:\\\\n///       - `row=1` and `col=0` if `anchor` is \\\\\\\"NW\\\\\\\" or \\\\\\\"NE\\\\\\\"\\\\n///       - `row=0` and `col=0` if `anchor` is \\\\\\\"SW\\\\\\\" or \\\\\\\"SE\\\\\\\"\\\\n///         (thus like a tooltip near the buffer text).\\\\n///   - row: Row position in units of \\\\\\\"screen cell height\\\\\\\", may be fractional.\\\\n///   - col: Column position in units of screen cell width, may be fractional.\\\\n///   - focusable: Enable focus by user actions (wincmds, mouse events).\\\\n///       Defaults to true. Non-focusable windows can be entered by\\\\n///       |nvim_set_current_win()|, or, when the `mouse` field is set to true,\\\\n///       by mouse events. See |focusable|.\\\\n///   - mouse: Specify how this window interacts with mouse events.\\\\n///       Defaults to `focusable` value.\\\\n///       - If false, mouse events pass through this window.\\\\n///       - If true, mouse events interact with this window normally.\\\\n///   - external: GUI should display the window as an external\\\\n///       top-level window. Currently accepts no other positioning\\\\n///       configuration together with this.\\\\n///   - zindex: Stacking order. floats with higher `zindex` go on top on\\\\n///               floats with lower indices. Must be larger than zero. The\\\\n///               following screen elements have hard-coded z-indices:\\\\n///       - 100: insert completion popupmenu\\\\n///       - 200: message scrollback\\\\n///       - 250: cmdline completion popupmenu (when wildoptions+=pum)\\\\n///     The default value for floats are 50.  In general, values below 100 are\\\\n///     recommended, unless there is a good reason to overshadow builtin\\\\n///     elements.\\\\n///   - style: (optional) Configure the appearance of the window. Currently\\\\n///       only supports one value:\\\\n///       - \\\\\\\"minimal\\\\\\\"  Nvim will display the window with many UI options\\\\n///                    disabled. This is useful when displaying a temporary\\\\n///                    float where the text should not be edited. Disables\\\\n///                    'number', 'relativenumber', 'cursorline', 'cursorcolumn',\\\\n///                    'foldcolumn', 'spell' and 'list' options. 'signcolumn'\\\\n///                    is changed to `auto` and 'colorcolumn' is cleared.\\\\n///                    'statuscolumn' is changed to empty. The end-of-buffer\\\\n///                     region is hidden by setting `eob` flag of\\\\n///                    'fillchars' to a space char, and clearing the\\\\n///                    |hl-EndOfBuffer| region in 'winhighlight'.\\\\n///   - border: (`string|string[]`) (defaults to 'winborder' option) Window border. The string form\\\\n///     accepts the same values as the 'winborder' option. The array form must have a length of\\\\n///     eight or any divisor of eight, specifying the chars that form the border in a clockwise\\\\n///     fashion starting from the top-left corner. For example, the double-box style can be\\\\n///     specified as:\\\\n///     ```\\\\n///     [ \\\\\\\"╔\\\\\\\", \\\\\\\"═\\\\\\\" ,\\\\\\\"╗\\\\\\\", \\\\\\\"║\\\\\\\", \\\\\\\"╝\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╚\\\\\\\", \\\\\\\"║\\\\\\\" ].\\\\n///     ```\\\\n///     If fewer than eight chars are given, they will be repeated. An ASCII border could be\\\\n///     specified as:\\\\n///     ```\\\\n///     [ \\\\\\\"/\\\\\\\", \\\\\\\"-\\\\\\\", \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\"|\\\\\\\" ],\\\\n///     ```\\\\n///     Or one char for all sides:\\\\n///     ```\\\\n///     [ \\\\\\\"x\\\\\\\" ].\\\\n///     ```\\\\n///     Empty string can be used to hide a specific border. This example will show only vertical\\\\n///     borders, not horizontal:\\\\n///     ```\\\\n///     [ \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\">\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"<\\\\\\\" ]\\\\n///     ```\\\\n///     By default, |hl-FloatBorder| highlight is used, which links to |hl-WinSeparator| when not\\\\n///     defined.  Each border side can specify an optional highlight:\\\\n///     ```\\\\n///     [ [\\\\\\\"+\\\\\\\", \\\\\\\"MyCorner\\\\\\\"], [\\\\\\\"x\\\\\\\", \\\\\\\"MyBorder\\\\\\\"] ].\\\\n///     ```\\\\n///   - title: (optional) Title in window border, string or list.\\\\n///     List should consist of `[text, highlight]` tuples.\\\\n///     If string, or a tuple lacks a highlight, the default highlight group is `FloatTitle`.\\\\n///   - title_pos: Title position. Must be set with `title` option.\\\\n///     Value can be one of \\\\\\\"left\\\\\\\", \\\\\\\"center\\\\\\\", or \\\\\\\"right\\\\\\\".\\\\n///     Default is `\\\\\\\"left\\\\\\\"`.\\\\n///   - footer: (optional) Footer in window border, string or list.\\\\n///     List should consist of `[text, highlight]` tuples.\\\\n///     If string, or a tuple lacks a highlight, the default highlight group is `FloatFooter`.\\\\n///   - footer_pos: Footer position. Must be set with `footer` option.\\\\n///     Value can be one of \\\\\\\"left\\\\\\\", \\\\\\\"center\\\\\\\", or \\\\\\\"right\\\\\\\".\\\\n///     Default is `\\\\\\\"left\\\\\\\"`.\\\\n///   - noautocmd: If true then all autocommands are blocked for the duration of\\\\n///     the call.\\\\n///   - fixed: If true when anchor is NW or SW, the float window\\\\n///            would be kept fixed even if the window would be truncated.\\\\n///   - hide: If true the floating window will be hidden and the cursor will be invisible when\\\\n///           focused on it.\\\\n///   - vertical: Split vertically |:vertical|.\\\\n///   - split: Split direction: \\\\\\\"left\\\\\\\", \\\\\\\"right\\\\\\\", \\\\\\\"above\\\\\\\", \\\\\\\"below\\\\\\\".\\\\n///   - _cmdline_offset: (EXPERIMENTAL) When provided, anchor the |cmdline-completion|\\\\n///     popupmenu to this window, with an offset in screen cell width.\\\\n///\\\\n/// @param[out] err Error details, if any\\\\n///\\\\n/// @return |window-ID|, or 0 on error\\\\nWindow nvim_open_win(Buffer buffer, Boolean enter, Dict(win_config) *config, Error *err)\\\\n  FUNC_API_SINCE(6) FUNC_API_TEXTLOCK_ALLOW_CMDWIN\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  buf_T *buf = find_buffer_by_handle(buffer, err);\\\\n  if (!buf) {\\\\n    return 0;\\\\n  }\\\\n  if ((cmdwin_type != 0 && enter) || buf == cmdwin_buf) {\\\\n    api_set_error(err, kErrorTypeException, \\\\\\\"%s\\\\\\\", e_cmdwin);\\\\n    return 0;\\\\n  }\\\\n\\\\n  WinConfig fconfig = WIN_CONFIG_INIT;\\\\n  if (!parse_win_config(NULL, config, &fconfig, false, err)) {\\\\n    return 0;\\\\n  }\\\\n\\\\n  bool is_split = HAS_KEY_X(config, split) || HAS_KEY_X(config, vertical);\\\\n  Window rv = 0;\\\\n  if (fconfig.noautocmd) {\\\\n    block_autocmds();\\\\n  }\\\\n\\\\n  win_T *wp = NULL;\\\\n  tabpage_T *tp = curtab;\\\\n  win_T *parent = NULL;\\\\n  if (config->win != -1) {\\\\n    parent = find_window_by_handle(fconfig.window, err);\\\\n    if (!parent) {\\\\n      // find_window_by_handle has already set the error\\\\n      goto cleanup;\\\\n    } else if (is_split && parent->w_floating) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split a floating window\\\\\\\");\\\\n      goto cleanup;\\\\n    }\\\\n    tp = win_find_tabpage(parent);\\\\n  }\\\\n  if (is_split) {\\\\n    if (!check_split_disallowed_err(parent ? parent : curwin, err)) {\\\\n      goto cleanup;  // error already set\\\\n    }\\\\n\\\\n    if (HAS_KEY_X(config, vertical) && !HAS_KEY_X(config, split)) {\\\\n      if (config->vertical) {\\\\n        fconfig.split = p_spr ? kWinSplitRight : kWinSplitLeft;\\\\n      } else {\\\\n        fconfig.split = p_sb ? kWinSplitBelow : kWinSplitAbove;\\\\n      }\\\\n    }\\\\n    int flags = win_split_flags(fconfig.split, parent == NULL) | WSP_NOENTER;\\\\n\\\\n    TRY_WRAP(err, {\\\\n      int size = (flags & WSP_VERT) ? fconfig.width : fconfig.height;\\\\n      if (parent == NULL || parent == curwin) {\\\\n        wp = win_split_ins(size, flags, NULL, 0, NULL);\\\\n      } else {\\\\n        switchwin_T switchwin;\\\\n        // `parent` is valid in `tp`, so switch_win should not fail.\\\\n        const int result = switch_win(&switchwin, parent, tp, true);\\\\n        assert(result == OK);\\\\n        (void)result;\\\\n        wp = win_split_ins(size, flags, NULL, 0, NULL);\\\\n        restore_win(&switchwin, true);\\\\n      }\\\\n    });\\\\n    if (wp) {\\\\n      wp->w_config = fconfig;\\\\n    }\\\\n  } else {\\\\n    wp = win_new_float(NULL, false, fconfig, err);\\\\n  }\\\\n  if (!wp) {\\\\n    if (!ERROR_SET(err)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Failed to create window\\\\\\\");\\\\n    }\\\\n    goto cleanup;\\\\n  }\\\\n\\\\n  if (fconfig._cmdline_offset < INT_MAX) {\\\\n    cmdline_win = wp;\\\\n  }\\\\n\\\\n  // Autocommands may close `wp` or move it to another tabpage, so update and check `tp` after each\\\\n  // event. In each case, `wp` should already be valid in `tp`, so switch_win should not fail.\\\\n  // Also, autocommands may free the `buf` to switch to, so store a bufref to check.\\\\n  bufref_T bufref;\\\\n  set_bufref(&bufref, buf);\\\\n  if (!fconfig.noautocmd) {\\\\n    switchwin_T switchwin;\\\\n    const int result = switch_win_noblock(&switchwin, wp, tp, true);\\\\n    assert(result == OK);\\\\n    (void)result;\\\\n    if (apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf)) {\\\\n      tp = win_find_tabpage(wp);\\\\n    }\\\\n    restore_win_noblock(&switchwin, true);\\\\n  }\\\\n  if (tp && enter) {\\\\n    goto_tabpage_win(tp, wp);\\\\n    tp = win_find_tabpage(wp);\\\\n  }\\\\n  if (tp && bufref_valid(&bufref) && buf != wp->w_buffer) {\\\\n    // win_set_buf temporarily makes `wp` the curwin to set the buffer.\\\\n    // If not entering `wp`, block Enter and Leave events. (cringe)\\\\n    const bool au_no_enter_leave = curwin != wp && !fconfig.noautocmd;\\\\n    if (au_no_enter_leave) {\\\\n      autocmd_no_enter++;\\\\n      autocmd_no_leave++;\\\\n    }\\\\n    win_set_buf(wp, buf, err);\\\\n    if (!fconfig.noautocmd) {\\\\n      tp = win_find_tabpage(wp);\\\\n    }\\\\n    if (au_no_enter_leave) {\\\\n      autocmd_no_enter--;\\\\n      autocmd_no_leave--;\\\\n    }\\\\n  }\\\\n  if (!tp) {\\\\n    api_set_error(err, kErrorTypeException, \\\\\\\"Window was closed immediately\\\\\\\");\\\\n    goto cleanup;\\\\n  }\\\\n\\\\n  if (fconfig.style == kWinStyleMinimal) {\\\\n    win_set_minimal_style(wp);\\\\n    didset_window_options(wp, true);\\\\n  }\\\\n  rv = wp->handle;\\\\n\\\\ncleanup:\\\\n  if (fconfig.noautocmd) {\\\\n    unblock_autocmds();\\\\n  }\\\\n  return rv;\\\\n#undef HAS_KEY_X\\\\n}\\\\n\\\\nstatic WinSplit win_split_dir(win_T *win)\\\\n{\\\\n  if (win->w_frame == NULL || win->w_frame->fr_parent == NULL) {\\\\n    return kWinSplitLeft;\\\\n  }\\\\n\\\\n  char layout = win->w_frame->fr_parent->fr_layout;\\\\n  if (layout == FR_COL) {\\\\n    return win->w_frame->fr_next ? kWinSplitAbove : kWinSplitBelow;\\\\n  } else {\\\\n    return win->w_frame->fr_next ? kWinSplitLeft : kWinSplitRight;\\\\n  }\\\\n}\\\\n\\\\nstatic int win_split_flags(WinSplit split, bool toplevel)\\\\n{\\\\n  int flags = 0;\\\\n  if (split == kWinSplitAbove || split == kWinSplitBelow) {\\\\n    flags |= WSP_HOR;\\\\n  } else {\\\\n    flags |= WSP_VERT;\\\\n  }\\\\n  if (split == kWinSplitAbove || split == kWinSplitLeft) {\\\\n    flags |= toplevel ? WSP_TOP : WSP_ABOVE;\\\\n  } else {\\\\n    flags |= toplevel ? WSP_BOT : WSP_BELOW;\\\\n  }\\\\n  return flags;\\\\n}\\\\n\\\\n/// Configures window layout. Cannot be used to move the last window in a\\\\n/// tabpage to a different one.\\\\n///\\\\n/// When reconfiguring a window, absent option keys will not be changed.\\\\n/// `row`/`col` and `relative` must be reconfigured together.\\\\n///\\\\n/// @see |nvim_open_win()|\\\\n///\\\\n/// @param      window  |window-ID|, or 0 for current window\\\\n/// @param      config  Map defining the window configuration,\\\\n///                     see |nvim_open_win()|\\\\n/// @param[out] err     Error details, if any\\\\nvoid nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\\\\n  FUNC_API_SINCE(6)\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  win_T *win = find_window_by_handle(window, err);\\\\n  if (!win) {\\\\n    return;\\\\n  }\\\\n\\\\n  tabpage_T *win_tp = win_find_tabpage(win);\\\\n  bool was_split = !win->w_floating;\\\\n  bool has_split = HAS_KEY_X(config, split);\\\\n  bool has_vertical = HAS_KEY_X(config, vertical);\\\\n  // reuse old values, if not overridden\\\\n  WinConfig fconfig = win->w_config;\\\\n\\\\n  bool to_split = config->relative.size == 0\\\\n                  && !(HAS_KEY_X(config, external) ? config->external : fconfig.external)\\\\n                  && (has_split || has_vertical || was_split);\\\\n\\\\n  if (!parse_win_config(win, config, &fconfig, !was_split || to_split, err)) {\\\\n    return;\\\\n  }\\\\n  win_T *parent = NULL;\\\\n  if (config->win != -1) {\\\\n    parent = find_window_by_handle(fconfig.window, err);\\\\n    if (!parent) {\\\\n      return;\\\\n    } else if (to_split && parent->w_floating) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split a floating window\\\\\\\");\\\\n      return;\\\\n    }\\\\n\\\\n    // Prevent autocmd window from being moved into another tabpage\\\\n    if (is_aucmd_win(win) && win_find_tabpage(win) != win_find_tabpage(parent)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot move autocmd win to another tabpage\\\\\\\");\\\\n      return;\\\\n    }\\\\n  }\\\\n  if (was_split && !to_split) {\\\\n    if (!win_new_float(win, false, fconfig, err)) {\\\\n      return;\\\\n    }\\\\n    redraw_later(win, UPD_NOT_VALID);\\\\n  } else if (to_split) {\\\\n    WinSplit old_split = win_split_dir(win);\\\\n    if (has_vertical && !has_split) {\\\\n      if (config->vertical) {\\\\n        if (old_split == kWinSplitRight || p_spr) {\\\\n          fconfig.split = kWinSplitRight;\\\\n        } else {\\\\n          fconfig.split = kWinSplitLeft;\\\\n        }\\\\n      } else {\\\\n        if (old_split == kWinSplitBelow || p_sb) {\\\\n          fconfig.split = kWinSplitBelow;\\\\n        } else {\\\\n          fconfig.split = kWinSplitAbove;\\\\n        }\\\\n      }\\\\n    }\\\\n    merge_win_config(&win->w_config, fconfig);\\\\n\\\\n    // If there's no \\\\\\\"vertical\\\\\\\" or \\\\\\\"split\\\\\\\" set, or if \\\\\\\"split\\\\\\\" is unchanged,\\\\n    // then we can just change the size of the window.\\\\n    if ((!has_vertical && !has_split)\\\\n        || (was_split && !HAS_KEY_X(config, win) && old_split == fconfig.split)) {\\\\n      if (HAS_KEY_X(config, width)) {\\\\n        win_setwidth_win(fconfig.width, win);\\\\n      }\\\\n      if (HAS_KEY_X(config, height)) {\\\\n        win_setheight_win(fconfig.height, win);\\\\n      }\\\\n      redraw_later(win, UPD_NOT_VALID);\\\\n      return;\\\\n    }\\\\n\\\\n    if (!check_split_disallowed_err(win, err)) {\\\\n      return;  // error already set\\\\n    }\\\\n    // Can't move the cmdwin or its old curwin to a different tabpage.\\\\n    if ((win == cmdwin_win || win == cmdwin_old_curwin) && parent != NULL\\\\n        && win_find_tabpage(parent) != win_tp) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"%s\\\\\\\", e_cmdwin);\\\\n      return;\\\\n    }\\\\n\\\\n    bool to_split_ok = false;\\\\n    // If we are moving curwin to another tabpage, switch windows *before* we remove it from the\\\\n    // window list or remove its frame (if non-floating), so it's valid for autocommands.\\\\n    const bool curwin_moving_tp\\\\n      = win == curwin && parent != NULL && win_tp != win_find_tabpage(parent);\\\\n    if (curwin_moving_tp) {\\\\n      if (was_split) {\\\\n        int dir;\\\\n        win_goto(winframe_find_altwin(win, &dir, NULL, NULL));\\\\n      } else {\\\\n        win_goto(win_float_find_altwin(win, NULL));\\\\n      }\\\\n\\\\n      // Autocommands may have been a real nuisance and messed things up...\\\\n      if (curwin == win) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Failed to switch away from window %d\\\\\\\",\\\\n                      win->handle);\\\\n        return;\\\\n      }\\\\n      win_tp = win_find_tabpage(win);\\\\n      if (!win_tp || !win_valid_any_tab(parent)) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Windows to split were closed\\\\\\\");\\\\n        goto restore_curwin;\\\\n      }\\\\n      if (was_split == win->w_floating || parent->w_floating) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Floating state of windows to split changed\\\\\\\");\\\\n        goto restore_curwin;\\\\n      }\\\\n    }\\\\n\\\\n    int dir = 0;\\\\n    frame_T *unflat_altfr = NULL;\\\\n    win_T *altwin = NULL;\\\\n\\\\n    if (was_split) {\\\\n      // If the window is the last in the tabpage or `fconfig.win` is\\\\n      // a handle to itself, we can't split it.\\\\n      if (win->w_frame->fr_parent == NULL) {\\\\n        // FIXME(willothy): if the window is the last in the tabpage but there is another tabpage\\\\n        // and the target window is in that other tabpage, should we move the window to that\\\\n        // tabpage and close the previous one, or just error?\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Cannot move last window\\\\\\\");\\\\n        goto restore_curwin;\\\\n      } else if (parent != NULL && parent->handle == win->handle) {\\\\n        int n_frames = 0;\\\\n        for (frame_T *fr = win->w_frame->fr_parent->fr_child; fr != NULL; fr = fr->fr_next) {\\\\n          n_frames++;\\\\n        }\\\\n\\\\n        win_T *neighbor = NULL;\\\\n\\\\n        if (n_frames > 2) {\\\\n          // There are three or more windows in the frame, we need to split a neighboring window.\\\\n          frame_T *frame = win->w_frame->fr_parent;\\\\n\\\\n          if (frame->fr_parent) {\\\\n            //   ┌──────────────┐\\\\n            //   │      A       │\\\\n            //   ├────┬────┬────┤\\\\n            //   │ B  │ C  │ D  │\\\\n            //   └────┴────┴────┘\\\\n            //          ||\\\\n            //          \\\\\\\\/\\\\n            // ┌───────────────────┐\\\\n            // │         A         │\\\\n            // ├─────────┬─────────┤\\\\n            // │         │    C    │\\\\n            // │    B    ├─────────┤\\\\n            // │         │    D    │\\\\n            // └─────────┴─────────┘\\\\n            if (fconfig.split == kWinSplitAbove || fconfig.split == kWinSplitLeft) {\\\\n              neighbor = win->w_next;\\\\n            } else {\\\\n              neighbor = win->w_prev;\\\\n            }\\\\n          }\\\\n          // If the frame doesn't have a parent, the old frame\\\\n          // was the root frame and we need to create a top-level split.\\\\n          altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n        } else if (n_frames == 2) {\\\\n          // There are two windows in the frame, we can just rotate it.\\\\n          altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n          neighbor = altwin;\\\\n        } else {\\\\n          // There is only one window in the frame, we can't split it.\\\\n          api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split window into itself\\\\\\\");\\\\n          goto restore_curwin;\\\\n        }\\\\n        // Set the parent to whatever the correct neighbor window was determined to be.\\\\n        parent = neighbor;\\\\n      } else {\\\\n        altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n      }\\\\n    } else {\\\\n      altwin = win_float_find_altwin(win, win_tp == curtab ? NULL : win_tp);\\\\n    }\\\\n\\\\n    win_remove(win, win_tp == curtab ? NULL : win_tp);\\\\n    if (win_tp == curtab) {\\\\n      last_status(false);  // may need to remove last status line\\\\n      win_comp_pos();  // recompute window positions\\\\n    }\\\\n\\\\n    int flags = win_split_flags(fconfig.split, parent == NULL) | WSP_NOENTER;\\\\n    tabpage_T *const parent_tp = parent ? win_find_tabpage(parent) : curtab;\\\\n\\\\n    TRY_WRAP(err, {\\\\n      const bool need_switch = parent != NULL && parent != curwin;\\\\n      switchwin_T switchwin;\\\\n      if (need_switch) {\\\\n        // `parent` is valid in its tabpage, so switch_win should not fail.\\\\n        const int result = switch_win(&switchwin, parent, parent_tp, true);\\\\n        (void)result;\\\\n        assert(result == OK);\\\\n      }\\\\n      to_split_ok = win_split_ins(0, flags, win, 0, unflat_altfr) != NULL;\\\\n      if (!to_split_ok) {\\\\n        // Restore `win` to the window list now, so it's valid for restore_win (if used).\\\\n        win_append(win->w_prev, win, win_tp == curtab ? NULL : win_tp);\\\\n      }\\\\n      if (need_switch) {\\\\n        restore_win(&switchwin, true);\\\\n      }\\\\n    });\\\\n    if (!to_split_ok) {\\\\n      if (was_split) {\\\\n        // win_split_ins doesn't change sizes or layout if it fails to insert an existing window, so\\\\n        // just undo winframe_remove.\\\\n        winframe_restore(win, dir, unflat_altfr);\\\\n      }\\\\n      if (!ERROR_SET(err)) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Failed to move window %d into split\\\\\\\", win->handle);\\\\n      }\\\\n\\\\nrestore_curwin:\\\\n      // If `win` was the original curwin, and autocommands didn't move it outside of curtab, be a\\\\n      // good citizen and try to return to it.\\\\n      if (curwin_moving_tp && win_valid(win)) {\\\\n        win_goto(win);\\\\n      }\\\\n      return;\\\\n    }\\\\n\\\\n    // If `win` moved tabpages and was the curwin of its old one, select a new curwin for it.\\\\n    if (win_tp != parent_tp && win_tp->tp_curwin == win) {\\\\n      win_tp->tp_curwin = altwin;\\\\n    }\\\\n\\\\n    if (HAS_KEY_X(config, width)) {\\\\n      win_setwidth_win(fconfig.width, win);\\\\n    }\\\\n    if (HAS_KEY_X(config, height)) {\\\\n      win_setheight_win(fconfig.height, win);\\\\n    }\\\\n  } else {\\\\n    win_config_float(win, fconfig);\\\\n    win->w_pos_changed = true;\\\\n  }\\\\n  if (HAS_KEY_X(config, style)) {\\\\n    if (fconfig.style == kWinStyleMinimal) {\\\\n      win_set_minimal_style(win);\\\\n      didset_window_options(win, true);\\\\n    }\\\\n  }\\\\n  if (fconfig._cmdline_offset < INT_MAX) {\\\\n    cmdline_win = win;\\\\n  } else if (win == cmdline_win && fconfig._cmdline_offset == INT_MAX) {\\\\n    cmdline_win = NULL;\\\\n  }\\\\n#undef HAS_KEY_X\\\\n}\\\\n\\\\n#define PUT_KEY_X(d, key, value) PUT_KEY(d, win_config, key, value)\\\\nstatic void config_put_bordertext(Dict(win_config) *config, WinConfig *fconfig,\\\\n                                  BorderTextType bordertext_type, Arena *arena)\\\\n{\\\\n  VirtText vt;\\\\n  AlignTextPos align;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    vt = fconfig->title_chunks;\\\\n    align = fconfig->title_pos;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    vt = fconfig->footer_chunks;\\\\n    align = fconfig->footer_pos;\\\\n    break;\\\\n  }\\\\n\\\\n  Array bordertext = virt_text_to_array(vt, true, arena);\\\\n\\\\n  char *pos;\\\\n  switch (align) {\\\\n  case kAlignLeft:\\\\n    pos = \\\\\\\"left\\\\\\\";\\\\n    break;\\\\n  case kAlignCenter:\\\\n    pos = \\\\\\\"center\\\\\\\";\\\\n    break;\\\\n  case kAlignRight:\\\\n    pos = \\\\\\\"right\\\\\\\";\\\\n    break;\\\\n  }\\\\n\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    PUT_KEY_X(*config, title, ARRAY_OBJ(bordertext));\\\\n    PUT_KEY_X(*config, title_pos, cstr_as_string(pos));\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    PUT_KEY_X(*config, footer, ARRAY_OBJ(bordertext));\\\\n    PUT_KEY_X(*config, footer_pos, cstr_as_string(pos));\\\\n  }\\\\n}\\\\n\\\\n/// Gets window configuration.\\\\n///\\\\n/// The returned value may be given to |nvim_open_win()|.\\\\n///\\\\n/// `relative` is empty for normal windows.\\\\n///\\\\n/// @param      window |window-ID|, or 0 for current window\\\\n/// @param[out] err Error details, if any\\\\n/// @return     Map defining the window configuration, see |nvim_open_win()|\\\\nDict(win_config) nvim_win_get_config(Window window, Arena *arena, Error *err)\\\\n  FUNC_API_SINCE(6)\\\\n{\\\\n  /// Keep in sync with FloatRelative in buffer_defs.h\\\\n  static const char *const float_relative_str[] = {\\\\n    \\\\\\\"editor\\\\\\\", \\\\\\\"win\\\\\\\", \\\\\\\"cursor\\\\\\\", \\\\\\\"mouse\\\\\\\", \\\\\\\"tabline\\\\\\\", \\\\\\\"laststatus\\\\\\\"\\\\n  };\\\\n\\\\n  /// Keep in sync with WinSplit in buffer_defs.h\\\\n  static const char *const win_split_str[] = { \\\\\\\"left\\\\\\\", \\\\\\\"right\\\\\\\", \\\\\\\"above\\\\\\\", \\\\\\\"below\\\\\\\" };\\\\n\\\\n  Dict(win_config) rv = KEYDICT_INIT;\\\\n\\\\n  win_T *wp = find_window_by_handle(window, err);\\\\n  if (!wp) {\\\\n    return rv;\\\\n  }\\\\n\\\\n  WinConfig *config = &wp->w_config;\\\\n\\\\n  PUT_KEY_X(rv, focusable, config->focusable);\\\\n  PUT_KEY_X(rv, external, config->external);\\\\n  PUT_KEY_X(rv, hide, config->hide);\\\\n  PUT_KEY_X(rv, mouse, config->mouse);\\\\n\\\\n  if (wp->w_floating) {\\\\n    PUT_KEY_X(rv, width, config->width);\\\\n    PUT_KEY_X(rv, height, config->height);\\\\n    if (!config->external) {\\\\n      if (config->relative == kFloatRelativeWindow) {\\\\n        PUT_KEY_X(rv, win, config->window);\\\\n        if (config->bufpos.lnum >= 0) {\\\\n          Array pos = arena_array(arena, 2);\\\\n          ADD_C(pos, INTEGER_OBJ(config->bufpos.lnum));\\\\n          ADD_C(pos, INTEGER_OBJ(config->bufpos.col));\\\\n          PUT_KEY_X(rv, bufpos, pos);\\\\n        }\\\\n      }\\\\n      PUT_KEY_X(rv, anchor, cstr_as_string(float_anchor_str[config->anchor]));\\\\n      PUT_KEY_X(rv, row, config->row);\\\\n      PUT_KEY_X(rv, col, config->col);\\\\n      PUT_KEY_X(rv, zindex, config->zindex);\\\\n    }\\\\n    if (config->border) {\\\\n      Array border = arena_array(arena, 8);\\\\n      for (size_t i = 0; i < 8; i++) {\\\\n        String s = cstrn_as_string(config->border_chars[i], MAX_SCHAR_SIZE);\\\\n\\\\n        int hi_id = config->border_hl_ids[i];\\\\n        char *hi_name = syn_id2name(hi_id);\\\\n        if (hi_name[0]) {\\\\n          Array tuple = arena_array(arena, 2);\\\\n          ADD_C(tuple, STRING_OBJ(s));\\\\n          ADD_C(tuple, CSTR_AS_OBJ(hi_name));\\\\n          ADD_C(border, ARRAY_OBJ(tuple));\\\\n        } else {\\\\n          ADD_C(border, STRING_OBJ(s));\\\\n        }\\\\n      }\\\\n      PUT_KEY_X(rv, border, ARRAY_OBJ(border));\\\\n      if (config->title) {\\\\n        config_put_bordertext(&rv, config, kBorderTextTitle, arena);\\\\n      }\\\\n      if (config->footer) {\\\\n        config_put_bordertext(&rv, config, kBorderTextFooter, arena);\\\\n      }\\\\n    }\\\\n  } else if (!config->external) {\\\\n    PUT_KEY_X(rv, width, wp->w_width);\\\\n    PUT_KEY_X(rv, height, wp->w_height);\\\\n    WinSplit split = win_split_dir(wp);\\\\n    PUT_KEY_X(rv, split, cstr_as_string(win_split_str[split]));\\\\n  }\\\\n\\\\n  const char *rel = (wp->w_floating && !config->external\\\\n                     ? float_relative_str[config->relative] : \\\\\\\"\\\\\\\");\\\\n  PUT_KEY_X(rv, relative, cstr_as_string(rel));\\\\n  if (config->_cmdline_offset < INT_MAX) {\\\\n    PUT_KEY_X(rv, _cmdline_offset, config->_cmdline_offset);\\\\n  }\\\\n\\\\n  return rv;\\\\n}\\\\n\\\\nstatic bool parse_float_anchor(String anchor, FloatAnchor *out)\\\\n{\\\\n  if (anchor.size == 0) {\\\\n    *out = (FloatAnchor)0;\\\\n  }\\\\n  char *str = anchor.data;\\\\n  if (striequal(str, \\\\\\\"NW\\\\\\\")) {\\\\n    *out = 0;  //  NW is the default\\\\n  } else if (striequal(str, \\\\\\\"NE\\\\\\\")) {\\\\n    *out = kFloatAnchorEast;\\\\n  } else if (striequal(str, \\\\\\\"SW\\\\\\\")) {\\\\n    *out = kFloatAnchorSouth;\\\\n  } else if (striequal(str, \\\\\\\"SE\\\\\\\")) {\\\\n    *out = kFloatAnchorSouth | kFloatAnchorEast;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_float_relative(String relative, FloatRelative *out)\\\\n{\\\\n  char *str = relative.data;\\\\n  if (striequal(str, \\\\\\\"editor\\\\\\\")) {\\\\n    *out = kFloatRelativeEditor;\\\\n  } else if (striequal(str, \\\\\\\"win\\\\\\\")) {\\\\n    *out = kFloatRelativeWindow;\\\\n  } else if (striequal(str, \\\\\\\"cursor\\\\\\\")) {\\\\n    *out = kFloatRelativeCursor;\\\\n  } else if (striequal(str, \\\\\\\"mouse\\\\\\\")) {\\\\n    *out = kFloatRelativeMouse;\\\\n  } else if (striequal(str, \\\\\\\"tabline\\\\\\\")) {\\\\n    *out = kFloatRelativeTabline;\\\\n  } else if (striequal(str, \\\\\\\"laststatus\\\\\\\")) {\\\\n    *out = kFloatRelativeLaststatus;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_config_split(String split, WinSplit *out)\\\\n{\\\\n  char *str = split.data;\\\\n  if (striequal(str, \\\\\\\"left\\\\\\\")) {\\\\n    *out = kWinSplitLeft;\\\\n  } else if (striequal(str, \\\\\\\"right\\\\\\\")) {\\\\n    *out = kWinSplitRight;\\\\n  } else if (striequal(str, \\\\\\\"above\\\\\\\")) {\\\\n    *out = kWinSplitAbove;\\\\n  } else if (striequal(str, \\\\\\\"below\\\\\\\")) {\\\\n    *out = kWinSplitBelow;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_float_bufpos(Array bufpos, lpos_T *out)\\\\n{\\\\n  if (bufpos.size != 2 || bufpos.items[0].type != kObjectTypeInteger\\\\n      || bufpos.items[1].type != kObjectTypeInteger) {\\\\n    return false;\\\\n  }\\\\n  out->lnum = (linenr_T)bufpos.items[0].data.integer;\\\\n  out->col = (colnr_T)bufpos.items[1].data.integer;\\\\n  return true;\\\\n}\\\\n\\\\nstatic void parse_bordertext(Object bordertext, BorderTextType bordertext_type, WinConfig *fconfig,\\\\n                             Error *err)\\\\n{\\\\n  if (bordertext.type != kObjectTypeString && bordertext.type != kObjectTypeArray) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"title/footer must be string or array\\\\\\\");\\\\n    return;\\\\n  }\\\\n\\\\n  if (bordertext.type == kObjectTypeArray && bordertext.data.array.size == 0) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"title/footer cannot be an empty array\\\\\\\");\\\\n    return;\\\\n  }\\\\n\\\\n  bool *is_present;\\\\n  VirtText *chunks;\\\\n  int *width;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    is_present = &fconfig->title;\\\\n    chunks = &fconfig->title_chunks;\\\\n    width = &fconfig->title_width;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    is_present = &fconfig->footer;\\\\n    chunks = &fconfig->footer_chunks;\\\\n    width = &fconfig->footer_width;\\\\n    break;\\\\n  }\\\\n\\\\n  if (bordertext.type == kObjectTypeString) {\\\\n    if (bordertext.data.string.size == 0) {\\\\n      *is_present = false;\\\\n      return;\\\\n    }\\\\n    kv_init(*chunks);\\\\n    kv_push(*chunks, ((VirtTextChunk){ .text = xstrdup(bordertext.data.string.data),\\\\n                                       .hl_id = -1 }));\\\\n    *width = (int)mb_string2cells(bordertext.data.string.data);\\\\n    *is_present = true;\\\\n    return;\\\\n  }\\\\n\\\\n  *width = 0;\\\\n  *chunks = parse_virt_text(bordertext.data.array, err, width);\\\\n\\\\n  *is_present = true;\\\\n}\\\\n\\\\nstatic bool parse_bordertext_pos(win_T *wp, String bordertext_pos, BorderTextType bordertext_type,\\\\n                                 WinConfig *fconfig, Error *err)\\\\n{\\\\n  AlignTextPos *align;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    align = &fconfig->title_pos;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    align = &fconfig->footer_pos;\\\\n    break;\\\\n  }\\\\n\\\\n  if (bordertext_pos.size == 0) {\\\\n    if (!wp) {\\\\n      *align = kAlignLeft;\\\\n    }\\\\n    return true;\\\\n  }\\\\n\\\\n  char *pos = bordertext_pos.data;\\\\n\\\\n  if (strequal(pos, \\\\\\\"left\\\\\\\")) {\\\\n    *align = kAlignLeft;\\\\n  } else if (strequal(pos, \\\\\\\"center\\\\\\\")) {\\\\n    *align = kAlignCenter;\\\\n  } else if (strequal(pos, \\\\\\\"right\\\\\\\")) {\\\\n    *align = kAlignRight;\\\\n  } else {\\\\n    switch (bordertext_type) {\\\\n    case kBorderTextTitle:\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid title_pos value\\\\\\\");\\\\n      break;\\\\n    case kBorderTextFooter:\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid footer_pos value\\\\\\\");\\\\n      break;\\\\n    }\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic void parse_border_style(Object style, WinConfig *fconfig, Error *err)\\\\n{\\\\n  struct {\\\\n    const char *name;\\\\n    char chars[8][MAX_SCHAR_SIZE];\\\\n    bool shadow_color;\\\\n  } defaults[] = {\\\\n    { opt_winborder_values[1], { \\\\\\\"╔\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╗\\\\\\\", \\\\\\\"║\\\\\\\", \\\\\\\"╝\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╚\\\\\\\", \\\\\\\"║\\\\\\\" }, false },\\\\n    { opt_winborder_values[2], { \\\\\\\"┌\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"┐\\\\\\\", \\\\\\\"│\\\\\\\", \\\\\\\"┘\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"└\\\\\\\", \\\\\\\"│\\\\\\\" }, false },\\\\n    { opt_winborder_values[3], { \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\"\\\\\\\" }, true },\\\\n    { opt_winborder_values[4], { \\\\\\\"╭\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"╮\\\\\\\", \\\\\\\"│\\\\\\\", \\\\\\\"╯\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"╰\\\\\\\", \\\\\\\"│\\\\\\\" }, false },\\\\n    { opt_winborder_values[5], { \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\" }, false },\\\\n    { opt_winborder_values[6], { \\\\\\\"┏\\\\\\\", \\\\\\\"━\\\\\\\", \\\\\\\"┓\\\\\\\", \\\\\\\"┃\\\\\\\", \\\\\\\"┛\\\\\\\", \\\\\\\"━\\\\\\\", \\\\\\\"┗\\\\\\\", \\\\\\\"┃\\\\\\\" }, false },\\\\n    { NULL, { { NUL } }, false },\\\\n  };\\\\n\\\\n  char(*chars)[MAX_SCHAR_SIZE] = fconfig->border_chars;\\\\n  int *hl_ids = fconfig->border_hl_ids;\\\\n\\\\n  fconfig->border = true;\\\\n\\\\n  if (style.type == kObjectTypeArray) {\\\\n    Array arr = style.data.array;\\\\n    size_t size = arr.size;\\\\n    if (!size || size > 8 || (size & (size - 1))) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid number of border chars\\\\\\\");\\\\n      return;\\\\n    }\\\\n    for (size_t i = 0; i < size; i++) {\\\\n      Object iytem = arr.items[i];\\\\n      String string;\\\\n      int hl_id = 0;\\\\n      if (iytem.type == kObjectTypeArray) {\\\\n        Array iarr = iytem.data.array;\\\\n        if (!iarr.size || iarr.size > 2) {\\\\n          api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n          return;\\\\n        }\\\\n        if (iarr.items[0].type != kObjectTypeString) {\\\\n          api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n          return;\\\\n        }\\\\n        string = iarr.items[0].data.string;\\\\n        if (iarr.size == 2) {\\\\n          hl_id = object_to_hl_id(iarr.items[1], \\\\\\\"border char highlight\\\\\\\", err);\\\\n          if (ERROR_SET(err)) {\\\\n            return;\\\\n          }\\\\n        }\\\\n      } else if (iytem.type == kObjectTypeString) {\\\\n        string = iytem.data.string;\\\\n      } else {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n        return;\\\\n      }\\\\n      if (string.size && mb_string2cells_len(string.data, string.size) > 1) {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"border chars must be one cell\\\\\\\");\\\\n        return;\\\\n      }\\\\n      size_t len = MIN(string.size, sizeof(*chars) - 1);\\\\n      if (len) {\\\\n        memcpy(chars[i], string.data, len);\\\\n      }\\\\n      chars[i][len] = NUL;\\\\n      hl_ids[i] = hl_id;\\\\n    }\\\\n    while (size < 8) {\\\\n      memcpy(chars + size, chars, sizeof(*chars) * size);\\\\n      memcpy(hl_ids + size, hl_ids, sizeof(*hl_ids) * size);\\\\n      size <<= 1;\\\\n    }\\\\n    if ((chars[7][0] && chars[1][0] && !chars[0][0])\\\\n        || (chars[1][0] && chars[3][0] && !chars[2][0])\\\\n        || (chars[3][0] && chars[5][0] && !chars[4][0])\\\\n        || (chars[5][0] && chars[7][0] && !chars[6][0])) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"corner between used edges must be specified\\\\\\\");\\\\n    }\\\\n  } else if (style.type == kObjectTypeString) {\\\\n    String str = style.data.string;\\\\n    if (str.size == 0 || strequal(str.data, \\\\\\\"none\\\\\\\")) {\\\\n      fconfig->border = false;\\\\n      // border text does not work with border equal none\\\\n      fconfig->title = false;\\\\n      fconfig->footer = false;\\\\n      return;\\\\n    }\\\\n    for (size_t i = 0; defaults[i].name; i++) {\\\\n      if (strequal(str.data, defaults[i].name)) {\\\\n        memcpy(chars, defaults[i].chars, sizeof(defaults[i].chars));\\\\n        memset(hl_ids, 0, 8 * sizeof(*hl_ids));\\\\n        if (defaults[i].shadow_color) {\\\\n          int hl_blend = SYN_GROUP_STATIC(\\\\\\\"FloatShadow\\\\\\\");\\\\n          int hl_through = SYN_GROUP_STATIC(\\\\\\\"FloatShadowThrough\\\\\\\");\\\\n          hl_ids[2] = hl_through;\\\\n          hl_ids[3] = hl_blend;\\\\n          hl_ids[4] = hl_blend;\\\\n          hl_ids[5] = hl_blend;\\\\n          hl_ids[6] = hl_through;\\\\n        }\\\\n        return;\\\\n      }\\\\n    }\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border style \\\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\\"\\\\\\\", str.data);\\\\n  }\\\\n}\\\\n\\\\nstatic void generate_api_error(win_T *wp, const char *attribute, Error *err)\\\\n{\\\\n  if (wp != NULL && wp->w_floating) {\\\\n    api_set_error(err, kErrorTypeValidation,\\\\n                  \\\\\\\"Missing 'relative' field when reconfiguring floating window %d\\\\\\\",\\\\n                  wp->handle);\\\\n  } else {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have '%s'\\\\\\\", attribute);\\\\n  }\\\\n}\\\\n\\\\nbool parse_winborder(WinConfig *fconfig, Error *err)\\\\n{\\\\n  if (!fconfig) {\\\\n    return false;\\\\n  }\\\\n  Object style = OBJECT_INIT;\\\\n\\\\n  if (strchr(p_winborder, ',')) {\\\\n    Array border_chars = ARRAY_DICT_INIT;\\\\n    char *p = p_winborder;\\\\n    char part[MAX_SCHAR_SIZE] = { 0 };\\\\n    int count = 0;\\\\n\\\\n    while (*p != NUL) {\\\\n      if (count >= 8) {\\\\n        api_free_array(border_chars);\\\\n        return false;\\\\n      }\\\\n\\\\n      size_t part_len = copy_option_part(&p, part, sizeof(part), \\\\\\\",\\\\\\\");\\\\n      if (part_len == 0 || part[0] == NUL) {\\\\n        api_free_array(border_chars);\\\\n        return false;\\\\n      }\\\\n\\\\n      String str = cstr_to_string(part);\\\\n      ADD(border_chars, STRING_OBJ(str));\\\\n      count++;\\\\n    }\\\\n\\\\n    if (count != 8) {\\\\n      api_free_array(border_chars);\\\\n      return false;\\\\n    }\\\\n\\\\n    style = ARRAY_OBJ(border_chars);\\\\n  } else {\\\\n    style = CSTR_TO_OBJ(p_winborder);\\\\n  }\\\\n\\\\n  parse_border_style(style, fconfig, err);\\\\n\\\\n  if (style.type == kObjectTypeArray) {\\\\n    api_free_array(style.data.array);\\\\n  } else if (style.type == kObjectTypeString) {\\\\n    api_free_string(style.data.string);\\\\n  }\\\\n\\\\n  return !ERROR_SET(err);\\\\n}\\\\n\\\\nstatic bool parse_win_config(win_T *wp, Dict(win_config) *config, WinConfig *fconfig, bool reconf,\\\\n                             Error *err)\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  bool has_relative = false, relative_is_win = false, is_split = false;\\\\n  if (config->relative.size > 0) {\\\\n    if (!parse_float_relative(config->relative, &fconfig->relative)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'relative' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    if (config->relative.size > 0 && !(HAS_KEY_X(config, row) && HAS_KEY_X(config, col))\\\\n        && !HAS_KEY_X(config, bufpos)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'relative' requires 'row'/'col' or 'bufpos'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    has_relative = true;\\\\n    fconfig->external = false;\\\\n    if (fconfig->relative == kFloatRelativeWindow) {\\\\n      relative_is_win = true;\\\\n      fconfig->bufpos.lnum = -1;\\\\n    }\\\\n  } else if (!config->external) {\\\\n    if (HAS_KEY_X(config, vertical) || HAS_KEY_X(config, split)) {\\\\n      is_split = true;\\\\n    } else if (wp == NULL) {  // new win\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"Must specify 'relative' or 'external' when creating a float\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, vertical)) {\\\\n    if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"floating windows cannot have 'vertical'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, split)) {\\\\n    if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"floating windows cannot have 'split'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (!parse_config_split(config->split, &fconfig->split)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'split' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, anchor)) {\\\\n    if (!parse_float_anchor(config->anchor, &fconfig->anchor)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'anchor' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, row)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"row\\\\\\\", err);\\\\n      goto fail;\\\\n    }\\\\n    fconfig->row = config->row;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, col)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"col\\\\\\\", err);\\\\n      goto fail;\\\\n    }\\\\n    fconfig->col = config->col;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, bufpos)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"bufpos\\\\\\\", err);\\\\n      goto fail;\\\\n    } else {\\\\n      if (!parse_float_bufpos(config->bufpos, &fconfig->bufpos)) {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'bufpos' key\\\\\\\");\\\\n        goto fail;\\\\n      }\\\\n\\\\n      if (!HAS_KEY_X(config, row)) {\\\\n        fconfig->row = (fconfig->anchor & kFloatAnchorSouth) ? 0 : 1;\\\\n      }\\\\n      if (!HAS_KEY_X(config, col)) {\\\\n        fconfig->col = 0;\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, width)) {\\\\n    if (config->width > 0) {\\\\n      fconfig->width = (int)config->width;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'width' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  } else if (!reconf && !is_split) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"Must specify 'width'\\\\\\\");\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, height)) {\\\\n    if (config->height > 0) {\\\\n      fconfig->height = (int)config->height;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'height' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  } else if (!reconf && !is_split) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"Must specify 'height'\\\\\\\");\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (relative_is_win || is_split) {\\\\n    if (reconf && relative_is_win) {\\\\n      win_T *target_win = find_window_by_handle(config->win, err);\\\\n      if (!target_win) {\\\\n        goto fail;\\\\n      }\\\\n\\\\n      if (target_win == wp) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"floating window cannot be relative to itself\\\\\\\");\\\\n        goto fail;\\\\n      }\\\\n    }\\\\n    fconfig->window = curwin->handle;\\\\n    if (HAS_KEY_X(config, win)) {\\\\n      if (config->win > 0) {\\\\n        fconfig->window = config->win;\\\\n      }\\\\n    }\\\\n  } else if (HAS_KEY_X(config, win)) {\\\\n    if (has_relative) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"'win' key is only valid with relative='win' and relative=''\\\\\\\");\\\\n      goto fail;\\\\n    } else if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"non-float with 'win' requires at least 'split' or 'vertical'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, external)) {\\\\n    fconfig->external = config->external;\\\\n    if (has_relative && fconfig->external) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"Only one of 'relative' and 'external' must be used\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (fconfig->external && !ui_has(kUIMultigrid)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"UI doesn't support external windows\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, focusable)) {\\\\n    fconfig->focusable = config->focusable;\\\\n    fconfig->mouse = config->focusable;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, mouse)) {\\\\n    fconfig->mouse = config->mouse;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, zindex)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'zindex'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (config->zindex > 0) {\\\\n      fconfig->zindex = (int)config->zindex;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'zindex' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, title)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'title'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    parse_bordertext(config->title, kBorderTextTitle, fconfig, err);\\\\n    if (ERROR_SET(err)) {\\\\n      goto fail;\\\\n    }\\\\n\\\\n    // handles unset 'title_pos' same as empty string\\\\n    if (!parse_bordertext_pos(wp, config->title_pos, kBorderTextTitle, fconfig, err)) {\\\\n      goto fail;\\\\n    }\\\\n  } else {\\\\n    if (HAS_KEY_X(config, title_pos)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"title_pos requires title to be set\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, footer)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'footer'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    parse_bordertext(config->footer, kBorderTextFooter, fconfig, err);\\\\n    if (ERROR_SET(err)) {\\\\n      goto fail;\\\\n    }\\\\n\\\\n    // handles unset 'footer_pos' same as empty string\\\\n    if (!parse_bordertext_pos(wp, config->footer_pos, kBorderTextFooter, fconfig, err)) {\\\\n      goto fail;\\\\n    }\\\\n  } else {\\\\n    if (HAS_KEY_X(config, footer_pos)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"footer_pos requires footer to be set\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  Object border_style = OBJECT_INIT;\\\\n  if (HAS_KEY_X(config, border)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'border'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    border_style = config->border;\\\\n    if (border_style.type != kObjectTypeNil) {\\\\n      parse_border_style(border_style, fconfig, err);\\\\n      if (ERROR_SET(err)) {\\\\n        goto fail;\\\\n      }\\\\n    }\\\\n  } else if (*p_winborder != NUL && (wp == NULL || !wp->w_floating)\\\\n             && !parse_winborder(fconfig, err)) {\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, style)) {\\\\n    if (config->style.data[0] == NUL) {\\\\n      fconfig->style = kWinStyleUnused;\\\\n    } else if (striequal(config->style.data, \\\\\\\"minimal\\\\\\\")) {\\\\n      fconfig->style = kWinStyleMinimal;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'style' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, noautocmd)) {\\\\n    if (wp) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'noautocmd' cannot be used with existing windows\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    fconfig->noautocmd = config->noautocmd;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, fixed)) {\\\\n    fconfig->fixed = config->fixed;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, hide)) {\\\\n    fconfig->hide = config->hide;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, _cmdline_offset)) {\\\\n    fconfig->_cmdline_offset = (int)config->_cmdline_offset;\\\\n  }\\\\n\\\\n  return true;\\\\n\\\\nfail:\\\\n  merge_win_config(fconfig, wp != NULL ? wp->w_config : WIN_CONFIG_INIT);\\\\n  return false;\\\\n#undef HAS_KEY_X\\\\n}\\\\n\\\",\\\"uri\\\":\\\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\\\",\\\"version\\\":0}}}\\n\\nI[16:48:24.916] <-- textDocument/didOpen\\nV[16:48:24.916] config note at /Users/mw/workspace/neovim/.clangd:1:0: Parsing config fragment\\nV[16:48:24.916] config note at /Users/mw/workspace/neovim/.clangd:1:0: Parsed 1 fragments from file\\nV[16:48:24.916] Config fragment: compiling /Users/mw/workspace/neovim/.clangd:1 -> 0x00006000013E80B8 (trusted=false)\\nI[16:48:24.916] --> textDocument/publishDiagnostics\\nV[16:48:24.916] >>> {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"textDocument/publishDiagnostics\\\",\\\"params\\\":{\\\"diagnostics\\\":[],\\\"uri\\\":\\\"file:///Users/mw/workspace/neovim/.clangd\\\"}}\\n\\n\"\n[ERROR][2025-05-03 16:48:24] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"I[16:48:24.917] Loaded compilation database from /Users/mw/workspace/neovim/build/compile_commands.json\\nV[16:48:24.917] Broadcasting compilation database from /Users/mw/workspace/neovim/build\\nI[16:48:24.917] ASTWorker building file /Users/mw/workspace/neovim/src/nvim/api/win_config.c version 0 with command \\n[/Users/mw/workspace/neovim/build]\\n/opt/homebrew/Cellar/llvm/20.1.3/bin/clang -DINCLUDE_GENERATED_DECLARATIONS -DNVIM_LOG_DEBUG -DUNIT_TESTING -DUTF8PROC_STATIC -D_GNU_SOURCE -Dnvim_bin_EXPORTS -I/Users/mw/workspace/neovim/build/src/nvim/auto -I/Users/mw/workspace/neovim/build/include -I/Users/mw/workspace/neovim/build/cmake.config -I/Users/mw/workspace/neovim/src -isystem /Users/mw/workspace/neovim/.deps/usr/include/luajit-2.1 -isystem /Users/mw/workspace/neovim/.deps/usr/include -isystem /opt/homebrew/opt/gettext/include -g -arch arm64 -mmacosx-version-min=15.4.1 -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -Wshadow -Wconversion -Wvla -Wdouble-promotion -Wmissing-noreturn -Wmissing-format-attribute -Wmissing-prototypes -fsigned-char -fstack-protector-strong -Wimplicit-fallthrough -fdiagnostics-color=always -o src/nvim/CMakeFiles/nvim_bin.dir/api/win_config.c.o -c -resource-dir=/opt/homebrew/Cellar/llvm/20.1.3/lib/clang/20 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -- /Users/mw/workspace/neovim/src/nvim/api/win_config.c\\nI[16:48:24.917] --> window/workDoneProgress/create(0)\\nV[16:48:24.917] >>> {\\\"id\\\":0,\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"window/workDoneProgress/create\\\",\\\"params\\\":{\\\"token\\\":\\\"backgroundIndexProgress\\\"}}\\n\\nI[16:48:24.917] Enqueueing 197 commands for indexing\\nV[16:48:24.917] Ignored diagnostic. argument unused during compilation: '-c'\\nV[16:48:24.917] Driver produced command: cc1 -cc1 -triple arm64-apple-macosx15.4.1 -Wundef-prefix=TARGET_OS_ -Werror=undef-prefix -Wdeprecated-objc-isa-usage -Werror=deprecated-objc-isa-usage -fsyntax-only -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name win_config.c -mrelocation-model pic -pic-level 2 -mframe-pointer=non-leaf -ffp-contract=on -fno-rounding-math -funwind-tables=1 -target-sdk-version=15.4 -fcompatibility-qualified-id-block-type-checking -fvisibility-inlines-hidden-static-local-var -fdefine-target-os-macros -fno-modulemap-allow-subdirectory-search -target-cpu apple-m1 -target-feature +zcm -target-feature +zcz -target-feature +v8.4a -target-feature +aes -target-feature +altnzcv -target-feature +ccdp -target-feature +ccpp -target-feature +complxnum -target-feature +crc -target-feature +dotprod -target-feature +flagm -target-feature +fp-armv8 -target-feature +fp16fml -target-feature +fptoint -target-feature +fullfp16 -target-feature +jsconv -target-feature +lse -target-feature +neon -target-feature +pauth -target-feature +perfmon -target-feature +predres -target-feature +ras -target-feature +rcpc -target-feature +rdm -target-feature +sb -target-feature +sha2 -target-feature +sha3 -target-feature +specrestrict -target-feature +ssbs -target-abi darwinpcs -debug-info-kind=standalone -dwarf-version=5 -debugger-tuning=lldb -fdebug-compilation-dir=/Users/mw/workspace/neovim/build -target-linker-version 1115.7.3 -fcoverage-compilation-dir=/Users/mw/workspace/neovim/build -resource-dir /opt/homebrew/Cellar/llvm/20.1.3/lib/clang/20 -isystem /Users/mw/workspace/neovim/.deps/usr/include/luajit-2.1 -isystem /Users/mw/workspace/neovim/.deps/usr/include -isystem /opt/homebrew/opt/gettext/include -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -D INCLUDE_GENERATED_DECLARATIONS -D NVIM_LOG_DEBUG -D UNIT_TESTING -D UTF8PROC_STATIC -D _GNU_SOURCE -D nvim_bin_EXPORTS -I /Users/mw/workspace/neovim/build/src/nvim/auto -I /Users/mw/workspace/neovim/build/include -I /Users/mw/workspace/neovim/build/cmake.config -I /Users/mw/workspace/neovim/src -internal-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/local/include -internal-isystem /opt/homebrew/Cellar/llvm/20.1.3/lib/clang/20/include -internal-externc-isystem /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include -Wall -Wextra -Wno-unused-parameter -Wstrict-prototypes -Wshadow -Wconversion -Wvla -Wdouble-promotion -Wmissing-noreturn -Wmissing-format-attribute -Wmissing-prototypes -Wimplicit-fallthrough -pedantic -std=gnu99 -ferror-limit 19 -stack-protector 2 -fblocks -fencode-extended-block-signature -fregister-global-dtors-with-atexit -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fmax-type-align=16 -no-round-trip-args -D__GCC_HAVE_DWARF2_CFI_ASM=1 -x c /Users/mw/workspace/neovim/src/nvim/api/win_config.c\\nV[16:48:24.917] Building first preamble for /Users/mw/workspace/neovim/src/nvim/api/win_config.c version 0\\n\"\n[ERROR][2025-05-03 16:48:24] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:24.941] <<< {\"id\":0,\"jsonrpc\":\"2.0\",\"result\":null}\\n\\nI[16:48:24.941] <-- reply(0)\\nI[16:48:24.941] --> $/progress\\nV[16:48:24.941] >>> {\"jsonrpc\":\"2.0\",\"method\":\"$/progress\",\"params\":{\"token\":\"backgroundIndexProgress\",\"value\":{\"kind\":\"begin\",\"percentage\":0,\"title\":\"indexing\"}}}\\n\\nI[16:48:24.941] --> $/progress\\nV[16:48:24.941] >>> {\"jsonrpc\":\"2.0\",\"method\":\"$/progress\",\"params\":{\"token\":\"backgroundIndexProgress\",\"value\":{\"kind\":\"report\",\"message\":\"0/1\",\"percentage\":0}}}\\n\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"I[16:48:25.000] Built preamble of size 5162856 for file /Users/mw/workspace/neovim/src/nvim/api/win_config.c version 0 in 0.08 seconds\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"I[16:48:25.000] Indexing c99 standard library in the context of /Users/mw/workspace/neovim/src/nvim/api/win_config.c\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'I[16:48:25.000] --> workspace/semanticTokens/refresh(1)\\nV[16:48:25.000] >>> {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"workspace/semanticTokens/refresh\",\"params\":null}\\n\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:25.000] <<< {\"id\":1,\"jsonrpc\":\"2.0\",\"result\":null}\\n\\nI[16:48:25.000] <-- reply(1)\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"I[16:48:25.025] Indexed c99 standard library: 3963 symbols, 16 filtered\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.033] Build dynamic index for header symbols with estimated memory usage of 3007532 bytes\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.040] Dropped diagnostic: /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_assert.h: declaration uses identifier '__assert_rtn', which is a reserved identifier [bugprone-reserved-identifier]\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.042] indexed file AST for /Users/mw/workspace/neovim/src/nvim/api/win_config.c version 0:\\n  symbol slab: 20 symbols, 17057 bytes\\n  ref slab: 283 symbols, 1273 refs, 57472 bytes\\n  relations slab: 0 relations, 24 bytes\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.042] Build dynamic index for main-file symbols with estimated memory usage of 133217 bytes\\nI[16:48:25.042] --> textDocument/publishDiagnostics\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:25.042] >>> {\"jsonrpc\":\"2.0\",\"method\":\"textDocument/publishDiagnostics\",\"params\":{\"diagnostics\":[],\"uri\":\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\",\"version\":0}}\\n\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.059] BackgroundIndex: building version 1 after loading index from disk\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.068] indexed preamble AST for /Users/mw/workspace/neovim/src/nvim/api/win_config.c version 0:\\n  symbol slab: 22041 symbols, 5900064 bytes\\n  ref slab: 0 symbols, 0 refs, 128 bytes\\n  relations slab: 0 relations, 24 bytes\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.103] Build dynamic index for header symbols with estimated memory usage of 13145696 bytes\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.174] BackgroundIndex: serving version 1 (83200062 bytes)\\n\"\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'I[16:48:25.197] --> $/progress\\nV[16:48:25.197] >>> {\"jsonrpc\":\"2.0\",\"method\":\"$/progress\",\"params\":{\"token\":\"backgroundIndexProgress\",\"value\":{\"kind\":\"report\",\"message\":\"0/1\",\"percentage\":0}}}\\n\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'I[16:48:25.197] --> $/progress\\nV[16:48:25.197] >>> {\"jsonrpc\":\"2.0\",\"method\":\"$/progress\",\"params\":{\"token\":\"backgroundIndexProgress\",\"value\":{\"kind\":\"end\"}}}\\n\\n'\n[ERROR][2025-05-03 16:48:25] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"V[16:48:25.434] <<< {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"textDocument/didChange\\\",\\\"params\\\":{\\\"contentChanges\\\":[{\\\"range\\\":{\\\"end\\\":{\\\"character\\\":0,\\\"line\\\":1395},\\\"start\\\":{\\\"character\\\":19,\\\"line\\\":0}},\\\"rangeLength\\\":46600,\\\"text\\\":\\\"\\\\n#include <stdbool.h>\\\\n#include <string.h>\\\\n\\\\n#include \\\\\\\"klib/kvec.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/extmark.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/keysets_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/dispatch.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/private/helpers.h\\\\\\\"\\\\n#include \\\\\\\"nvim/api/win_config.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ascii_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/autocmd.h\\\\\\\"\\\\n#include \\\\\\\"nvim/autocmd_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/buffer.h\\\\\\\"\\\\n#include \\\\\\\"nvim/buffer_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/decoration_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/drawscreen.h\\\\\\\"\\\\n#include \\\\\\\"nvim/errors.h\\\\\\\"\\\\n#include \\\\\\\"nvim/eval/window.h\\\\\\\"\\\\n#include \\\\\\\"nvim/globals.h\\\\\\\"\\\\n#include \\\\\\\"nvim/highlight_group.h\\\\\\\"\\\\n#include \\\\\\\"nvim/macros_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/mbyte.h\\\\\\\"\\\\n#include \\\\\\\"nvim/memory.h\\\\\\\"\\\\n#include \\\\\\\"nvim/memory_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/option.h\\\\\\\"\\\\n#include \\\\\\\"nvim/option_vars.h\\\\\\\"\\\\n#include \\\\\\\"nvim/pos_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/strings.h\\\\\\\"\\\\n#include \\\\\\\"nvim/syntax.h\\\\\\\"\\\\n#include \\\\\\\"nvim/types_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ui.h\\\\\\\"\\\\n#include \\\\\\\"nvim/ui_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/vim_defs.h\\\\\\\"\\\\n#include \\\\\\\"nvim/window.h\\\\\\\"\\\\n#include \\\\\\\"nvim/winfloat.h\\\\\\\"\\\\n\\\\n#ifdef INCLUDE_GENERATED_DECLARATIONS\\\\n# include \\\\\\\"api/win_config.c.generated.h\\\\\\\"\\\\n#endif\\\\n\\\\n/// Opens a new split window, or a floating window if `relative` is specified,\\\\n/// or an external window (managed by the UI) if `external` is specified.\\\\n///\\\\n/// Floats are windows that are drawn above the split layout, at some anchor\\\\n/// position in some other window. Floats can be drawn internally or by external\\\\n/// GUI with the |ui-multigrid| extension. External windows are only supported\\\\n/// with multigrid GUIs, and are displayed as separate top-level windows.\\\\n///\\\\n/// For a general overview of floats, see |api-floatwin|.\\\\n///\\\\n/// The `width` and `height` of the new window must be specified when opening\\\\n/// a floating window, but are optional for normal windows.\\\\n///\\\\n/// If `relative` and `external` are omitted, a normal \\\\\\\"split\\\\\\\" window is created.\\\\n/// The `win` property determines which window will be split. If no `win` is\\\\n/// provided or `win == 0`, a window will be created adjacent to the current window.\\\\n/// If -1 is provided, a top-level split will be created. `vertical` and `split` are\\\\n/// only valid for normal windows, and are used to control split direction. For `vertical`,\\\\n/// the exact direction is determined by |'splitright'| and |'splitbelow'|.\\\\n/// Split windows cannot have `bufpos`/`row`/`col`/`border`/`title`/`footer`\\\\n/// properties.\\\\n///\\\\n/// With relative=editor (row=0,col=0) refers to the top-left corner of the\\\\n/// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right\\\\n/// corner. Fractional values are allowed, but the builtin implementation\\\\n/// (used by non-multigrid UIs) will always round down to nearest integer.\\\\n///\\\\n/// Out-of-bounds values, and configurations that make the float not fit inside\\\\n/// the main editor, are allowed. The builtin implementation truncates values\\\\n/// so floats are fully within the main screen grid. External GUIs\\\\n/// could let floats hover outside of the main window like a tooltip, but\\\\n/// this should not be used to specify arbitrary WM screen positions.\\\\n///\\\\n/// Example (Lua): window-relative float\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false,\\\\n///   {relative='win', row=3, col=3, width=12, height=3})\\\\n/// ```\\\\n///\\\\n/// Example (Lua): buffer-relative float (travels as buffer is scrolled)\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false,\\\\n///   {relative='win', width=12, height=3, bufpos={100,10}})\\\\n/// ```\\\\n///\\\\n/// Example (Lua): vertical split left of the current window\\\\n///\\\\n/// ```lua\\\\n/// vim.api.nvim_open_win(0, false, {\\\\n///   split = 'left',\\\\n///   win = 0\\\\n/// })\\\\n/// ```\\\\n///\\\\n/// @param buffer Buffer to display, or 0 for current buffer\\\\n/// @param enter  Enter the window (make it the current window)\\\\n/// @param config Map defining the window configuration. Keys:\\\\n///   - relative: Sets the window layout to \\\\\\\"floating\\\\\\\", placed at (row,col)\\\\n///                 coordinates relative to:\\\\n///      - \\\\\\\"cursor\\\\\\\"     Cursor position in current window.\\\\n///      - \\\\\\\"editor\\\\\\\"     The global editor grid.\\\\n///      - \\\\\\\"laststatus\\\\\\\" 'laststatus' if present, or last row.\\\\n///      - \\\\\\\"mouse\\\\\\\"      Mouse position.\\\\n///      - \\\\\\\"tabline\\\\\\\"    Tabline if present, or first row.\\\\n///      - \\\\\\\"win\\\\\\\"        Window given by the `win` field, or current window.\\\\n///   - win: |window-ID| window to split, or relative window when creating a\\\\n///      float (relative=\\\\\\\"win\\\\\\\").\\\\n///   - anchor: Decides which corner of the float to place at (row,col):\\\\n///      - \\\\\\\"NW\\\\\\\" northwest (default)\\\\n///      - \\\\\\\"NE\\\\\\\" northeast\\\\n///      - \\\\\\\"SW\\\\\\\" southwest\\\\n///      - \\\\\\\"SE\\\\\\\" southeast\\\\n///   - width: Window width (in character cells). Minimum of 1.\\\\n///   - height: Window height (in character cells). Minimum of 1.\\\\n///   - bufpos: Places float relative to buffer text (only when\\\\n///       relative=\\\\\\\"win\\\\\\\"). Takes a tuple of zero-indexed `[line, column]`.\\\\n///       `row` and `col` if given are applied relative to this\\\\n///       position, else they default to:\\\\n///       - `row=1` and `col=0` if `anchor` is \\\\\\\"NW\\\\\\\" or \\\\\\\"NE\\\\\\\"\\\\n///       - `row=0` and `col=0` if `anchor` is \\\\\\\"SW\\\\\\\" or \\\\\\\"SE\\\\\\\"\\\\n///         (thus like a tooltip near the buffer text).\\\\n///   - row: Row position in units of \\\\\\\"screen cell height\\\\\\\", may be fractional.\\\\n///   - col: Column position in units of screen cell width, may be fractional.\\\\n///   - focusable: Enable focus by user actions (wincmds, mouse events).\\\\n///       Defaults to true. Non-focusable windows can be entered by\\\\n///       |nvim_set_current_win()|, or, when the `mouse` field is set to true,\\\\n///       by mouse events. See |focusable|.\\\\n///   - mouse: Specify how this window interacts with mouse events.\\\\n///       Defaults to `focusable` value.\\\\n///       - If false, mouse events pass through this window.\\\\n///       - If true, mouse events interact with this window normally.\\\\n///   - external: GUI should display the window as an external\\\\n///       top-level window. Currently accepts no other positioning\\\\n///       configuration together with this.\\\\n///   - zindex: Stacking order. floats with higher `zindex` go on top on\\\\n///               floats with lower indices. Must be larger than zero. The\\\\n///               following screen elements have hard-coded z-indices:\\\\n///       - 100: insert completion popupmenu\\\\n///       - 200: message scrollback\\\\n///       - 250: cmdline completion popupmenu (when wildoptions+=pum)\\\\n///     The default value for floats are 50.  In general, values below 100 are\\\\n///     recommended, unless there is a good reason to overshadow builtin\\\\n///     elements.\\\\n///   - style: (optional) Configure the appearance of the window. Currently\\\\n///       only supports one value:\\\\n///       - \\\\\\\"minimal\\\\\\\"  Nvim will display the window with many UI options\\\\n///                    disabled. This is useful when displaying a temporary\\\\n///                    float where the text should not be edited. Disables\\\\n///                    'number', 'relativenumber', 'cursorline', 'cursorcolumn',\\\\n///                    'foldcolumn', 'spell' and 'list' options. 'signcolumn'\\\\n///                    is changed to `auto` and 'colorcolumn' is cleared.\\\\n///                    'statuscolumn' is changed to empty. The end-of-buffer\\\\n///                     region is hidden by setting `eob` flag of\\\\n///                    'fillchars' to a space char, and clearing the\\\\n///                    |hl-EndOfBuffer| region in 'winhighlight'.\\\\n///   - border: (`string|string[]`) (defaults to 'winborder' option) Window border. The string form\\\\n///     accepts the same values as the 'winborder' option. The array form must have a length of\\\\n///     eight or any divisor of eight, specifying the chars that form the border in a clockwise\\\\n///     fashion starting from the top-left corner. For example, the double-box style can be\\\\n///     specified as:\\\\n///     ```\\\\n///     [ \\\\\\\"╔\\\\\\\", \\\\\\\"═\\\\\\\" ,\\\\\\\"╗\\\\\\\", \\\\\\\"║\\\\\\\", \\\\\\\"╝\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╚\\\\\\\", \\\\\\\"║\\\\\\\" ].\\\\n///     ```\\\\n///     If fewer than eight chars are given, they will be repeated. An ASCII border could be\\\\n///     specified as:\\\\n///     ```\\\\n///     [ \\\\\\\"/\\\\\\\", \\\\\\\"-\\\\\\\", \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\"|\\\\\\\" ],\\\\n///     ```\\\\n///     Or one char for all sides:\\\\n///     ```\\\\n///     [ \\\\\\\"x\\\\\\\" ].\\\\n///     ```\\\\n///     Empty string can be used to hide a specific border. This example will show only vertical\\\\n///     borders, not horizontal:\\\\n///     ```\\\\n///     [ \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\">\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\"<\\\\\\\" ]\\\\n///     ```\\\\n///     By default, |hl-FloatBorder| highlight is used, which links to |hl-WinSeparator| when not\\\\n///     defined.  Each border side can specify an optional highlight:\\\\n///     ```\\\\n///     [ [\\\\\\\"+\\\\\\\", \\\\\\\"MyCorner\\\\\\\"], [\\\\\\\"x\\\\\\\", \\\\\\\"MyBorder\\\\\\\"] ].\\\\n///     ```\\\\n///   - title: (optional) Title in window border, string or list.\\\\n///     List should consist of `[text, highlight]` tuples.\\\\n///     If string, or a tuple lacks a highlight, the default highlight group is `FloatTitle`.\\\\n///   - title_pos: Title position. Must be set with `title` option.\\\\n///     Value can be one of \\\\\\\"left\\\\\\\", \\\\\\\"center\\\\\\\", or \\\\\\\"right\\\\\\\".\\\\n///     Default is `\\\\\\\"left\\\\\\\"`.\\\\n///   - footer: (optional) Footer in window border, string or list.\\\\n///     List should consist of `[text, highlight]` tuples.\\\\n///     If string, or a tuple lacks a highlight, the default highlight group is `FloatFooter`.\\\\n///   - footer_pos: Footer position. Must be set with `footer` option.\\\\n///     Value can be one of \\\\\\\"left\\\\\\\", \\\\\\\"center\\\\\\\", or \\\\\\\"right\\\\\\\".\\\\n///     Default is `\\\\\\\"left\\\\\\\"`.\\\\n///   - noautocmd: If true then all autocommands are blocked for the duration of\\\\n///     the call.\\\\n///   - fixed: If true when anchor is NW or SW, the float window\\\\n///            would be kept fixed even if the window would be truncated.\\\\n///   - hide: If true the floating window will be hidden and the cursor will be invisible when\\\\n///           focused on it.\\\\n///   - vertical: Split vertically |:vertical|.\\\\n///   - split: Split direction: \\\\\\\"left\\\\\\\", \\\\\\\"right\\\\\\\", \\\\\\\"above\\\\\\\", \\\\\\\"below\\\\\\\".\\\\n///   - _cmdline_offset: (EXPERIMENTAL) When provided, anchor the |cmdline-completion|\\\\n///     popupmenu to this window, with an offset in screen cell width.\\\\n///\\\\n/// @param[out] err Error details, if any\\\\n///\\\\n/// @return |window-ID|, or 0 on error\\\\nWindow nvim_open_win(Buffer buffer, Boolean enter, Dict(win_config) *config, Error *err)\\\\n  FUNC_API_SINCE(6) FUNC_API_TEXTLOCK_ALLOW_CMDWIN\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  buf_T *buf = find_buffer_by_handle(buffer, err);\\\\n  if (!buf) {\\\\n    return 0;\\\\n  }\\\\n  if ((cmdwin_type != 0 && enter) || buf == cmdwin_buf) {\\\\n    api_set_error(err, kErrorTypeException, \\\\\\\"%s\\\\\\\", e_cmdwin);\\\\n    return 0;\\\\n  }\\\\n\\\\n  WinConfig fconfig = WIN_CONFIG_INIT;\\\\n  if (!parse_win_config(NULL, config, &fconfig, false, err)) {\\\\n    return 0;\\\\n  }\\\\n\\\\n  bool is_split = HAS_KEY_X(config, split) || HAS_KEY_X(config, vertical);\\\\n  Window rv = 0;\\\\n  if (fconfig.noautocmd) {\\\\n    block_autocmds();\\\\n  }\\\\n\\\\n  win_T *wp = NULL;\\\\n  tabpage_T *tp = curtab;\\\\n  win_T *parent = NULL;\\\\n  if (config->win != -1) {\\\\n    parent = find_window_by_handle(fconfig.window, err);\\\\n    if (!parent) {\\\\n      // find_window_by_handle has already set the error\\\\n      goto cleanup;\\\\n    } else if (is_split && parent->w_floating) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split a floating window\\\\\\\");\\\\n      goto cleanup;\\\\n    }\\\\n    tp = win_find_tabpage(parent);\\\\n  }\\\\n  if (is_split) {\\\\n    if (!check_split_disallowed_err(parent ? parent : curwin, err)) {\\\\n      goto cleanup;  // error already set\\\\n    }\\\\n\\\\n    if (HAS_KEY_X(config, vertical) && !HAS_KEY_X(config, split)) {\\\\n      if (config->vertical) {\\\\n        fconfig.split = p_spr ? kWinSplitRight : kWinSplitLeft;\\\\n      } else {\\\\n        fconfig.split = p_sb ? kWinSplitBelow : kWinSplitAbove;\\\\n      }\\\\n    }\\\\n    int flags = win_split_flags(fconfig.split, parent == NULL) | WSP_NOENTER;\\\\n\\\\n    TRY_WRAP(err, {\\\\n      int size = (flags & WSP_VERT) ? fconfig.width : fconfig.height;\\\\n      if (parent == NULL || parent == curwin) {\\\\n        wp = win_split_ins(size, flags, NULL, 0, NULL);\\\\n      } else {\\\\n        switchwin_T switchwin;\\\\n        // `parent` is valid in `tp`, so switch_win should not fail.\\\\n        const int result = switch_win(&switchwin, parent, tp, true);\\\\n        assert(result == OK);\\\\n        (void)result;\\\\n        wp = win_split_ins(size, flags, NULL, 0, NULL);\\\\n        restore_win(&switchwin, true);\\\\n      }\\\\n    });\\\\n    if (wp) {\\\\n      wp->w_config = fconfig;\\\\n    }\\\\n  } else {\\\\n    wp = win_new_float(NULL, false, fconfig, err);\\\\n  }\\\\n  if (!wp) {\\\\n    if (!ERROR_SET(err)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Failed to create window\\\\\\\");\\\\n    }\\\\n    goto cleanup;\\\\n  }\\\\n\\\\n  if (fconfig._cmdline_offset < INT_MAX) {\\\\n    cmdline_win = wp;\\\\n  }\\\\n\\\\n  // Autocommands may close `wp` or move it to another tabpage, so update and check `tp` after each\\\\n  // event. In each case, `wp` should already be valid in `tp`, so switch_win should not fail.\\\\n  // Also, autocommands may free the `buf` to switch to, so store a bufref to check.\\\\n  bufref_T bufref;\\\\n  set_bufref(&bufref, buf);\\\\n  if (!fconfig.noautocmd) {\\\\n    switchwin_T switchwin;\\\\n    const int result = switch_win_noblock(&switchwin, wp, tp, true);\\\\n    assert(result == OK);\\\\n    (void)result;\\\\n    if (apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf)) {\\\\n      tp = win_find_tabpage(wp);\\\\n    }\\\\n    restore_win_noblock(&switchwin, true);\\\\n  }\\\\n  if (tp && enter) {\\\\n    goto_tabpage_win(tp, wp);\\\\n    tp = win_find_tabpage(wp);\\\\n  }\\\\n  if (tp && bufref_valid(&bufref) && buf != wp->w_buffer) {\\\\n    // win_set_buf temporarily makes `wp` the curwin to set the buffer.\\\\n    // If not entering `wp`, block Enter and Leave events. (cringe)\\\\n    const bool au_no_enter_leave = curwin != wp && !fconfig.noautocmd;\\\\n    if (au_no_enter_leave) {\\\\n      autocmd_no_enter++;\\\\n      autocmd_no_leave++;\\\\n    }\\\\n    win_set_buf(wp, buf, err);\\\\n    if (!fconfig.noautocmd) {\\\\n      tp = win_find_tabpage(wp);\\\\n    }\\\\n    if (au_no_enter_leave) {\\\\n      autocmd_no_enter--;\\\\n      autocmd_no_leave--;\\\\n    }\\\\n  }\\\\n  if (!tp) {\\\\n    api_set_error(err, kErrorTypeException, \\\\\\\"Window was closed immediately\\\\\\\");\\\\n    goto cleanup;\\\\n  }\\\\n\\\\n  if (fconfig.style == kWinStyleMinimal) {\\\\n    win_set_minimal_style(wp);\\\\n    didset_window_options(wp, true);\\\\n  }\\\\n  rv = wp->handle;\\\\n\\\\ncleanup:\\\\n  if (fconfig.noautocmd) {\\\\n    unblock_autocmds();\\\\n  }\\\\n  return rv;\\\\n#undef HAS_KEY_X\\\\n}\\\\n\\\\nstatic WinSplit win_split_dir(win_T *win)\\\\n{\\\\n  if (win->w_frame == NULL || win->w_frame->fr_parent == NULL) {\\\\n    return kWinSplitLeft;\\\\n  }\\\\n\\\\n  char layout = win->w_frame->fr_parent->fr_layout;\\\\n  if (layout == FR_COL) {\\\\n    return win->w_frame->fr_next ? kWinSplitAbove : kWinSplitBelow;\\\\n  } else {\\\\n    return win->w_frame->fr_next ? kWinSplitLeft : kWinSplitRight;\\\\n  }\\\\n}\\\\n\\\\nstatic int win_split_flags(WinSplit split, bool toplevel)\\\\n{\\\\n  int flags = 0;\\\\n  if (split == kWinSplitAbove || split == kWinSplitBelow) {\\\\n    flags |= WSP_HOR;\\\\n  } else {\\\\n    flags |= WSP_VERT;\\\\n  }\\\\n  if (split == kWinSplitAbove || split == kWinSplitLeft) {\\\\n    flags |= toplevel ? WSP_TOP : WSP_ABOVE;\\\\n  } else {\\\\n    flags |= toplevel ? WSP_BOT : WSP_BELOW;\\\\n  }\\\\n  return flags;\\\\n}\\\\n\\\\n/// Configures window layout. Cannot be used to move the last window in a\\\\n/// tabpage to a different one.\\\\n///\\\\n/// When reconfiguring a window, absent option keys will not be changed.\\\\n/// `row`/`col` and `relative` must be reconfigured together.\\\\n///\\\\n/// @see |nvim_open_win()|\\\\n///\\\\n/// @param      window  |window-ID|, or 0 for current window\\\\n/// @param      config  Map defining the window configuration,\\\\n///                     see |nvim_open_win()|\\\\n/// @param[out] err     Error details, if any\\\\nvoid nvim_win_set_config(Window window, Dict(win_config) *config, Error *err)\\\\n  FUNC_API_SINCE(6)\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  win_T *win = find_window_by_handle(window, err);\\\\n  if (!win) {\\\\n    return;\\\\n  }\\\\n\\\\n  tabpage_T *win_tp = win_find_tabpage(win);\\\\n  bool was_split = !win->w_floating;\\\\n  bool has_split = HAS_KEY_X(config, split);\\\\n  bool has_vertical = HAS_KEY_X(config, vertical);\\\\n  // reuse old values, if not overridden\\\\n  WinConfig fconfig = win->w_config;\\\\n\\\\n  bool to_split = config->relative.size == 0\\\\n                  && !(HAS_KEY_X(config, external) ? config->external : fconfig.external)\\\\n                  && (has_split || has_vertical || was_split);\\\\n\\\\n  if (!parse_win_config(win, config, &fconfig, !was_split || to_split, err)) {\\\\n    return;\\\\n  }\\\\n  win_T *parent = NULL;\\\\n  if (config->win != -1) {\\\\n    parent = find_window_by_handle(fconfig.window, err);\\\\n    if (!parent) {\\\\n      return;\\\\n    } else if (to_split && parent->w_floating) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split a floating window\\\\\\\");\\\\n      return;\\\\n    }\\\\n\\\\n    // Prevent autocmd window from being moved into another tabpage\\\\n    if (is_aucmd_win(win) && win_find_tabpage(win) != win_find_tabpage(parent)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"Cannot move autocmd win to another tabpage\\\\\\\");\\\\n      return;\\\\n    }\\\\n  }\\\\n  if (was_split && !to_split) {\\\\n    if (!win_new_float(win, false, fconfig, err)) {\\\\n      return;\\\\n    }\\\\n    redraw_later(win, UPD_NOT_VALID);\\\\n  } else if (to_split) {\\\\n    WinSplit old_split = win_split_dir(win);\\\\n    if (has_vertical && !has_split) {\\\\n      if (config->vertical) {\\\\n        if (old_split == kWinSplitRight || p_spr) {\\\\n          fconfig.split = kWinSplitRight;\\\\n        } else {\\\\n          fconfig.split = kWinSplitLeft;\\\\n        }\\\\n      } else {\\\\n        if (old_split == kWinSplitBelow || p_sb) {\\\\n          fconfig.split = kWinSplitBelow;\\\\n        } else {\\\\n          fconfig.split = kWinSplitAbove;\\\\n        }\\\\n      }\\\\n    }\\\\n    merge_win_config(&win->w_config, fconfig);\\\\n\\\\n    // If there's no \\\\\\\"vertical\\\\\\\" or \\\\\\\"split\\\\\\\" set, or if \\\\\\\"split\\\\\\\" is unchanged,\\\\n    // then we can just change the size of the window.\\\\n    if ((!has_vertical && !has_split)\\\\n        || (was_split && !HAS_KEY_X(config, win) && old_split == fconfig.split)) {\\\\n      if (HAS_KEY_X(config, width)) {\\\\n        win_setwidth_win(fconfig.width, win);\\\\n      }\\\\n      if (HAS_KEY_X(config, height)) {\\\\n        win_setheight_win(fconfig.height, win);\\\\n      }\\\\n      redraw_later(win, UPD_NOT_VALID);\\\\n      return;\\\\n    }\\\\n\\\\n    if (!check_split_disallowed_err(win, err)) {\\\\n      return;  // error already set\\\\n    }\\\\n    // Can't move the cmdwin or its old curwin to a different tabpage.\\\\n    if ((win == cmdwin_win || win == cmdwin_old_curwin) && parent != NULL\\\\n        && win_find_tabpage(parent) != win_tp) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"%s\\\\\\\", e_cmdwin);\\\\n      return;\\\\n    }\\\\n\\\\n    bool to_split_ok = false;\\\\n    // If we are moving curwin to another tabpage, switch windows *before* we remove it from the\\\\n    // window list or remove its frame (if non-floating), so it's valid for autocommands.\\\\n    const bool curwin_moving_tp\\\\n      = win == curwin && parent != NULL && win_tp != win_find_tabpage(parent);\\\\n    if (curwin_moving_tp) {\\\\n      if (was_split) {\\\\n        int dir;\\\\n        win_goto(winframe_find_altwin(win, &dir, NULL, NULL));\\\\n      } else {\\\\n        win_goto(win_float_find_altwin(win, NULL));\\\\n      }\\\\n\\\\n      // Autocommands may have been a real nuisance and messed things up...\\\\n      if (curwin == win) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Failed to switch away from window %d\\\\\\\",\\\\n                      win->handle);\\\\n        return;\\\\n      }\\\\n      win_tp = win_find_tabpage(win);\\\\n      if (!win_tp || !win_valid_any_tab(parent)) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Windows to split were closed\\\\\\\");\\\\n        goto restore_curwin;\\\\n      }\\\\n      if (was_split == win->w_floating || parent->w_floating) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Floating state of windows to split changed\\\\\\\");\\\\n        goto restore_curwin;\\\\n      }\\\\n    }\\\\n\\\\n    int dir = 0;\\\\n    frame_T *unflat_altfr = NULL;\\\\n    win_T *altwin = NULL;\\\\n\\\\n    if (was_split) {\\\\n      // If the window is the last in the tabpage or `fconfig.win` is\\\\n      // a handle to itself, we can't split it.\\\\n      if (win->w_frame->fr_parent == NULL) {\\\\n        // FIXME(willothy): if the window is the last in the tabpage but there is another tabpage\\\\n        // and the target window is in that other tabpage, should we move the window to that\\\\n        // tabpage and close the previous one, or just error?\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Cannot move last window\\\\\\\");\\\\n        goto restore_curwin;\\\\n      } else if (parent != NULL && parent->handle == win->handle) {\\\\n        int n_frames = 0;\\\\n        for (frame_T *fr = win->w_frame->fr_parent->fr_child; fr != NULL; fr = fr->fr_next) {\\\\n          n_frames++;\\\\n        }\\\\n\\\\n        win_T *neighbor = NULL;\\\\n\\\\n        if (n_frames > 2) {\\\\n          // There are three or more windows in the frame, we need to split a neighboring window.\\\\n          frame_T *frame = win->w_frame->fr_parent;\\\\n\\\\n          if (frame->fr_parent) {\\\\n            //   ┌──────────────┐\\\\n            //   │      A       │\\\\n            //   ├────┬────┬────┤\\\\n            //   │ B  │ C  │ D  │\\\\n            //   └────┴────┴────┘\\\\n            //          ||\\\\n            //          \\\\\\\\/\\\\n            // ┌───────────────────┐\\\\n            // │         A         │\\\\n            // ├─────────┬─────────┤\\\\n            // │         │    C    │\\\\n            // │    B    ├─────────┤\\\\n            // │         │    D    │\\\\n            // └─────────┴─────────┘\\\\n            if (fconfig.split == kWinSplitAbove || fconfig.split == kWinSplitLeft) {\\\\n              neighbor = win->w_next;\\\\n            } else {\\\\n              neighbor = win->w_prev;\\\\n            }\\\\n          }\\\\n          // If the frame doesn't have a parent, the old frame\\\\n          // was the root frame and we need to create a top-level split.\\\\n          altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n        } else if (n_frames == 2) {\\\\n          // There are two windows in the frame, we can just rotate it.\\\\n          altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n          neighbor = altwin;\\\\n        } else {\\\\n          // There is only one window in the frame, we can't split it.\\\\n          api_set_error(err, kErrorTypeException, \\\\\\\"Cannot split window into itself\\\\\\\");\\\\n          goto restore_curwin;\\\\n        }\\\\n        // Set the parent to whatever the correct neighbor window was determined to be.\\\\n        parent = neighbor;\\\\n      } else {\\\\n        altwin = winframe_remove(win, &dir, win_tp == curtab ? NULL : win_tp, &unflat_altfr);\\\\n      }\\\\n    } else {\\\\n      altwin = win_float_find_altwin(win, win_tp == curtab ? NULL : win_tp);\\\\n    }\\\\n\\\\n    win_remove(win, win_tp == curtab ? NULL : win_tp);\\\\n    if (win_tp == curtab) {\\\\n      last_status(false);  // may need to remove last status line\\\\n      win_comp_pos();  // recompute window positions\\\\n    }\\\\n\\\\n    int flags = win_split_flags(fconfig.split, parent == NULL) | WSP_NOENTER;\\\\n    tabpage_T *const parent_tp = parent ? win_find_tabpage(parent) : curtab;\\\\n\\\\n    TRY_WRAP(err, {\\\\n      const bool need_switch = parent != NULL && parent != curwin;\\\\n      switchwin_T switchwin;\\\\n      if (need_switch) {\\\\n        // `parent` is valid in its tabpage, so switch_win should not fail.\\\\n        const int result = switch_win(&switchwin, parent, parent_tp, true);\\\\n        (void)result;\\\\n        assert(result == OK);\\\\n      }\\\\n      to_split_ok = win_split_ins(0, flags, win, 0, unflat_altfr) != NULL;\\\\n      if (!to_split_ok) {\\\\n        // Restore `win` to the window list now, so it's valid for restore_win (if used).\\\\n        win_append(win->w_prev, win, win_tp == curtab ? NULL : win_tp);\\\\n      }\\\\n      if (need_switch) {\\\\n        restore_win(&switchwin, true);\\\\n      }\\\\n    });\\\\n    if (!to_split_ok) {\\\\n      if (was_split) {\\\\n        // win_split_ins doesn't change sizes or layout if it fails to insert an existing window, so\\\\n        // just undo winframe_remove.\\\\n        winframe_restore(win, dir, unflat_altfr);\\\\n      }\\\\n      if (!ERROR_SET(err)) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"Failed to move window %d into split\\\\\\\", win->handle);\\\\n      }\\\\n\\\\nrestore_curwin:\\\\n      // If `win` was the original curwin, and autocommands didn't move it outside of curtab, be a\\\\n      // good citizen and try to return to it.\\\\n      if (curwin_moving_tp && win_valid(win)) {\\\\n        win_goto(win);\\\\n      }\\\\n      return;\\\\n    }\\\\n\\\\n    // If `win` moved tabpages and was the curwin of its old one, select a new curwin for it.\\\\n    if (win_tp != parent_tp && win_tp->tp_curwin == win) {\\\\n      win_tp->tp_curwin = altwin;\\\\n    }\\\\n\\\\n    if (HAS_KEY_X(config, width)) {\\\\n      win_setwidth_win(fconfig.width, win);\\\\n    }\\\\n    if (HAS_KEY_X(config, height)) {\\\\n      win_setheight_win(fconfig.height, win);\\\\n    }\\\\n  } else {\\\\n    win_config_float(win, fconfig);\\\\n    win->w_pos_changed = true;\\\\n  }\\\\n  if (HAS_KEY_X(config, style)) {\\\\n    if (fconfig.style == kWinStyleMinimal) {\\\\n      win_set_minimal_style(win);\\\\n      didset_window_options(win, true);\\\\n    }\\\\n  }\\\\n  if (fconfig._cmdline_offset < INT_MAX) {\\\\n    cmdline_win = win;\\\\n  } else if (win == cmdline_win && fconfig._cmdline_offset == INT_MAX) {\\\\n    cmdline_win = NULL;\\\\n  }\\\\n#undef HAS_KEY_X\\\\n}\\\\n\\\\n#define PUT_KEY_X(d, key, value) PUT_KEY(d, win_config, key, value)\\\\nstatic void config_put_bordertext(Dict(win_config) *config, WinConfig *fconfig,\\\\n                                  BorderTextType bordertext_type, Arena *arena)\\\\n{\\\\n  VirtText vt;\\\\n  AlignTextPos align;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    vt = fconfig->title_chunks;\\\\n    align = fconfig->title_pos;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    vt = fconfig->footer_chunks;\\\\n    align = fconfig->footer_pos;\\\\n    break;\\\\n  }\\\\n\\\\n  Array bordertext = virt_text_to_array(vt, true, arena);\\\\n\\\\n  char *pos;\\\\n  switch (align) {\\\\n  case kAlignLeft:\\\\n    pos = \\\\\\\"left\\\\\\\";\\\\n    break;\\\\n  case kAlignCenter:\\\\n    pos = \\\\\\\"center\\\\\\\";\\\\n    break;\\\\n  case kAlignRight:\\\\n    pos = \\\\\\\"right\\\\\\\";\\\\n    break;\\\\n  }\\\\n\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    PUT_KEY_X(*config, title, ARRAY_OBJ(bordertext));\\\\n    PUT_KEY_X(*config, title_pos, cstr_as_string(pos));\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    PUT_KEY_X(*config, footer, ARRAY_OBJ(bordertext));\\\\n    PUT_KEY_X(*config, footer_pos, cstr_as_string(pos));\\\\n  }\\\\n}\\\\n\\\\n/// Gets window configuration.\\\\n///\\\\n/// The returned value may be given to |nvim_open_win()|.\\\\n///\\\\n/// `relative` is empty for normal windows.\\\\n///\\\\n/// @param      window |window-ID|, or 0 for current window\\\\n/// @param[out] err Error details, if any\\\\n/// @return     Map defining the window configuration, see |nvim_open_win()|\\\\nDict(win_config) nvim_win_get_config(Window window, Arena *arena, Error *err)\\\\n  FUNC_API_SINCE(6)\\\\n{\\\\n  /// Keep in sync with FloatRelative in buffer_defs.h\\\\n  static const char *const float_relative_str[] = {\\\\n    \\\\\\\"editor\\\\\\\", \\\\\\\"win\\\\\\\", \\\\\\\"cursor\\\\\\\", \\\\\\\"mouse\\\\\\\", \\\\\\\"tabline\\\\\\\", \\\\\\\"laststatus\\\\\\\"\\\\n  };\\\\n\\\\n  /// Keep in sync with WinSplit in buffer_defs.h\\\\n  static const char *const win_split_str[] = { \\\\\\\"left\\\\\\\", \\\\\\\"right\\\\\\\", \\\\\\\"above\\\\\\\", \\\\\\\"below\\\\\\\" };\\\\n\\\\n  Dict(win_config) rv = KEYDICT_INIT;\\\\n\\\\n  win_T *wp = find_window_by_handle(window, err);\\\\n  if (!wp) {\\\\n    return rv;\\\\n  }\\\\n\\\\n  WinConfig *config = &wp->w_config;\\\\n\\\\n  PUT_KEY_X(rv, focusable, config->focusable);\\\\n  PUT_KEY_X(rv, external, config->external);\\\\n  PUT_KEY_X(rv, hide, config->hide);\\\\n  PUT_KEY_X(rv, mouse, config->mouse);\\\\n\\\\n  if (wp->w_floating) {\\\\n    PUT_KEY_X(rv, width, config->width);\\\\n    PUT_KEY_X(rv, height, config->height);\\\\n    if (!config->external) {\\\\n      if (config->relative == kFloatRelativeWindow) {\\\\n        PUT_KEY_X(rv, win, config->window);\\\\n        if (config->bufpos.lnum >= 0) {\\\\n          Array pos = arena_array(arena, 2);\\\\n          ADD_C(pos, INTEGER_OBJ(config->bufpos.lnum));\\\\n          ADD_C(pos, INTEGER_OBJ(config->bufpos.col));\\\\n          PUT_KEY_X(rv, bufpos, pos);\\\\n        }\\\\n      }\\\\n      PUT_KEY_X(rv, anchor, cstr_as_string(float_anchor_str[config->anchor]));\\\\n      PUT_KEY_X(rv, row, config->row);\\\\n      PUT_KEY_X(rv, col, config->col);\\\\n      PUT_KEY_X(rv, zindex, config->zindex);\\\\n    }\\\\n    if (config->border) {\\\\n      Array border = arena_array(arena, 8);\\\\n      for (size_t i = 0; i < 8; i++) {\\\\n        String s = cstrn_as_string(config->border_chars[i], MAX_SCHAR_SIZE);\\\\n\\\\n        int hi_id = config->border_hl_ids[i];\\\\n        char *hi_name = syn_id2name(hi_id);\\\\n        if (hi_name[0]) {\\\\n          Array tuple = arena_array(arena, 2);\\\\n          ADD_C(tuple, STRING_OBJ(s));\\\\n          ADD_C(tuple, CSTR_AS_OBJ(hi_name));\\\\n          ADD_C(border, ARRAY_OBJ(tuple));\\\\n        } else {\\\\n          ADD_C(border, STRING_OBJ(s));\\\\n        }\\\\n      }\\\\n      PUT_KEY_X(rv, border, ARRAY_OBJ(border));\\\\n      if (config->title) {\\\\n        config_put_bordertext(&rv, config, kBorderTextTitle, arena);\\\\n      }\\\\n      if (config->footer) {\\\\n        config_put_bordertext(&rv, config, kBorderTextFooter, arena);\\\\n      }\\\\n    }\\\\n  } else if (!config->external) {\\\\n    PUT_KEY_X(rv, width, wp->w_width);\\\\n    PUT_KEY_X(rv, height, wp->w_height);\\\\n    WinSplit split = win_split_dir(wp);\\\\n    PUT_KEY_X(rv, split, cstr_as_string(win_split_str[split]));\\\\n  }\\\\n\\\\n  const char *rel = (wp->w_floating && !config->external\\\\n                     ? float_relative_str[config->relative] : \\\\\\\"\\\\\\\");\\\\n  PUT_KEY_X(rv, relative, cstr_as_string(rel));\\\\n  if (config->_cmdline_offset < INT_MAX) {\\\\n    PUT_KEY_X(rv, _cmdline_offset, config->_cmdline_offset);\\\\n  }\\\\n\\\\n  return rv;\\\\n}\\\\n\\\\nstatic bool parse_float_anchor(String anchor, FloatAnchor *out)\\\\n{\\\\n  if (anchor.size == 0) {\\\\n    *out = (FloatAnchor)0;\\\\n  }\\\\n  char *str = anchor.data;\\\\n  if (striequal(str, \\\\\\\"NW\\\\\\\")) {\\\\n    *out = 0;  //  NW is the default\\\\n  } else if (striequal(str, \\\\\\\"NE\\\\\\\")) {\\\\n    *out = kFloatAnchorEast;\\\\n  } else if (striequal(str, \\\\\\\"SW\\\\\\\")) {\\\\n    *out = kFloatAnchorSouth;\\\\n  } else if (striequal(str, \\\\\\\"SE\\\\\\\")) {\\\\n    *out = kFloatAnchorSouth | kFloatAnchorEast;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_float_relative(String relative, FloatRelative *out)\\\\n{\\\\n  char *str = relative.data;\\\\n  if (striequal(str, \\\\\\\"editor\\\\\\\")) {\\\\n    *out = kFloatRelativeEditor;\\\\n  } else if (striequal(str, \\\\\\\"win\\\\\\\")) {\\\\n    *out = kFloatRelativeWindow;\\\\n  } else if (striequal(str, \\\\\\\"cursor\\\\\\\")) {\\\\n    *out = kFloatRelativeCursor;\\\\n  } else if (striequal(str, \\\\\\\"mouse\\\\\\\")) {\\\\n    *out = kFloatRelativeMouse;\\\\n  } else if (striequal(str, \\\\\\\"tabline\\\\\\\")) {\\\\n    *out = kFloatRelativeTabline;\\\\n  } else if (striequal(str, \\\\\\\"laststatus\\\\\\\")) {\\\\n    *out = kFloatRelativeLaststatus;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_config_split(String split, WinSplit *out)\\\\n{\\\\n  char *str = split.data;\\\\n  if (striequal(str, \\\\\\\"left\\\\\\\")) {\\\\n    *out = kWinSplitLeft;\\\\n  } else if (striequal(str, \\\\\\\"right\\\\\\\")) {\\\\n    *out = kWinSplitRight;\\\\n  } else if (striequal(str, \\\\\\\"above\\\\\\\")) {\\\\n    *out = kWinSplitAbove;\\\\n  } else if (striequal(str, \\\\\\\"below\\\\\\\")) {\\\\n    *out = kWinSplitBelow;\\\\n  } else {\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic bool parse_float_bufpos(Array bufpos, lpos_T *out)\\\\n{\\\\n  if (bufpos.size != 2 || bufpos.items[0].type != kObjectTypeInteger\\\\n      || bufpos.items[1].type != kObjectTypeInteger) {\\\\n    return false;\\\\n  }\\\\n  out->lnum = (linenr_T)bufpos.items[0].data.integer;\\\\n  out->col = (colnr_T)bufpos.items[1].data.integer;\\\\n  return true;\\\\n}\\\\n\\\\nstatic void parse_bordertext(Object bordertext, BorderTextType bordertext_type, WinConfig *fconfig,\\\\n                             Error *err)\\\\n{\\\\n  if (bordertext.type != kObjectTypeString && bordertext.type != kObjectTypeArray) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"title/footer must be string or array\\\\\\\");\\\\n    return;\\\\n  }\\\\n\\\\n  if (bordertext.type == kObjectTypeArray && bordertext.data.array.size == 0) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"title/footer cannot be an empty array\\\\\\\");\\\\n    return;\\\\n  }\\\\n\\\\n  bool *is_present;\\\\n  VirtText *chunks;\\\\n  int *width;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    is_present = &fconfig->title;\\\\n    chunks = &fconfig->title_chunks;\\\\n    width = &fconfig->title_width;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    is_present = &fconfig->footer;\\\\n    chunks = &fconfig->footer_chunks;\\\\n    width = &fconfig->footer_width;\\\\n    break;\\\\n  }\\\\n\\\\n  if (bordertext.type == kObjectTypeString) {\\\\n    if (bordertext.data.string.size == 0) {\\\\n      *is_present = false;\\\\n      return;\\\\n    }\\\\n    kv_init(*chunks);\\\\n    kv_push(*chunks, ((VirtTextChunk){ .text = xstrdup(bordertext.data.string.data),\\\\n                                       .hl_id = -1 }));\\\\n    *width = (int)mb_string2cells(bordertext.data.string.data);\\\\n    *is_present = true;\\\\n    return;\\\\n  }\\\\n\\\\n  *width = 0;\\\\n  *chunks = parse_virt_text(bordertext.data.array, err, width);\\\\n\\\\n  *is_present = true;\\\\n}\\\\n\\\\nstatic bool parse_bordertext_pos(win_T *wp, String bordertext_pos, BorderTextType bordertext_type,\\\\n                                 WinConfig *fconfig, Error *err)\\\\n{\\\\n  AlignTextPos *align;\\\\n  switch (bordertext_type) {\\\\n  case kBorderTextTitle:\\\\n    align = &fconfig->title_pos;\\\\n    break;\\\\n  case kBorderTextFooter:\\\\n    align = &fconfig->footer_pos;\\\\n    break;\\\\n  }\\\\n\\\\n  if (bordertext_pos.size == 0) {\\\\n    if (!wp) {\\\\n      *align = kAlignLeft;\\\\n    }\\\\n    return true;\\\\n  }\\\\n\\\\n  char *pos = bordertext_pos.data;\\\\n\\\\n  if (strequal(pos, \\\\\\\"left\\\\\\\")) {\\\\n    *align = kAlignLeft;\\\\n  } else if (strequal(pos, \\\\\\\"center\\\\\\\")) {\\\\n    *align = kAlignCenter;\\\\n  } else if (strequal(pos, \\\\\\\"right\\\\\\\")) {\\\\n    *align = kAlignRight;\\\\n  } else {\\\\n    switch (bordertext_type) {\\\\n    case kBorderTextTitle:\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid title_pos value\\\\\\\");\\\\n      break;\\\\n    case kBorderTextFooter:\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid footer_pos value\\\\\\\");\\\\n      break;\\\\n    }\\\\n    return false;\\\\n  }\\\\n  return true;\\\\n}\\\\n\\\\nstatic void parse_border_style(Object style, WinConfig *fconfig, Error *err)\\\\n{\\\\n  struct {\\\\n    const char *name;\\\\n    char chars[8][MAX_SCHAR_SIZE];\\\\n    bool shadow_color;\\\\n  } defaults[] = {\\\\n    { opt_winborder_values[1], { \\\\\\\"╔\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╗\\\\\\\", \\\\\\\"║\\\\\\\", \\\\\\\"╝\\\\\\\", \\\\\\\"═\\\\\\\", \\\\\\\"╚\\\\\\\", \\\\\\\"║\\\\\\\" }, false },\\\\n    { opt_winborder_values[2], { \\\\\\\"┌\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"┐\\\\\\\", \\\\\\\"│\\\\\\\", \\\\\\\"┘\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"└\\\\\\\", \\\\\\\"│\\\\\\\" }, false },\\\\n    { opt_winborder_values[3], { \\\\\\\"\\\\\\\", \\\\\\\"\\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\"\\\\\\\" }, true },\\\\n    { opt_winborder_values[4], { \\\\\\\"╭\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"╮\\\\\\\", \\\\\\\"│\\\\\\\", \\\\\\\"╯\\\\\\\", \\\\\\\"─\\\\\\\", \\\\\\\"╰\\\\\\\", \\\\\\\"│\\\\\\\" }, false },\\\\n    { opt_winborder_values[5], { \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\", \\\\\\\" \\\\\\\" }, false },\\\\n    { opt_winborder_values[6], { \\\\\\\"┏\\\\\\\", \\\\\\\"━\\\\\\\", \\\\\\\"┓\\\\\\\", \\\\\\\"┃\\\\\\\", \\\\\\\"┛\\\\\\\", \\\\\\\"━\\\\\\\", \\\\\\\"┗\\\\\\\", \\\\\\\"┃\\\\\\\" }, false },\\\\n    { NULL, { { NUL } }, false },\\\\n  };\\\\n\\\\n  char(*chars)[MAX_SCHAR_SIZE] = fconfig->border_chars;\\\\n  int *hl_ids = fconfig->border_hl_ids;\\\\n\\\\n  fconfig->border = true;\\\\n\\\\n  if (style.type == kObjectTypeArray) {\\\\n    Array arr = style.data.array;\\\\n    size_t size = arr.size;\\\\n    if (!size || size > 8 || (size & (size - 1))) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid number of border chars\\\\\\\");\\\\n      return;\\\\n    }\\\\n    for (size_t i = 0; i < size; i++) {\\\\n      Object iytem = arr.items[i];\\\\n      String string;\\\\n      int hl_id = 0;\\\\n      if (iytem.type == kObjectTypeArray) {\\\\n        Array iarr = iytem.data.array;\\\\n        if (!iarr.size || iarr.size > 2) {\\\\n          api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n          return;\\\\n        }\\\\n        if (iarr.items[0].type != kObjectTypeString) {\\\\n          api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n          return;\\\\n        }\\\\n        string = iarr.items[0].data.string;\\\\n        if (iarr.size == 2) {\\\\n          hl_id = object_to_hl_id(iarr.items[1], \\\\\\\"border char highlight\\\\\\\", err);\\\\n          if (ERROR_SET(err)) {\\\\n            return;\\\\n          }\\\\n        }\\\\n      } else if (iytem.type == kObjectTypeString) {\\\\n        string = iytem.data.string;\\\\n      } else {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border char\\\\\\\");\\\\n        return;\\\\n      }\\\\n      if (string.size && mb_string2cells_len(string.data, string.size) > 1) {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"border chars must be one cell\\\\\\\");\\\\n        return;\\\\n      }\\\\n      size_t len = MIN(string.size, sizeof(*chars) - 1);\\\\n      if (len) {\\\\n        memcpy(chars[i], string.data, len);\\\\n      }\\\\n      chars[i][len] = NUL;\\\\n      hl_ids[i] = hl_id;\\\\n    }\\\\n    while (size < 8) {\\\\n      memcpy(chars + size, chars, sizeof(*chars) * size);\\\\n      memcpy(hl_ids + size, hl_ids, sizeof(*hl_ids) * size);\\\\n      size <<= 1;\\\\n    }\\\\n    if ((chars[7][0] && chars[1][0] && !chars[0][0])\\\\n        || (chars[1][0] && chars[3][0] && !chars[2][0])\\\\n        || (chars[3][0] && chars[5][0] && !chars[4][0])\\\\n        || (chars[5][0] && chars[7][0] && !chars[6][0])) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"corner between used edges must be specified\\\\\\\");\\\\n    }\\\\n  } else if (style.type == kObjectTypeString) {\\\\n    String str = style.data.string;\\\\n    if (str.size == 0 || strequal(str.data, \\\\\\\"none\\\\\\\")) {\\\\n      fconfig->border = false;\\\\n      // border text does not work with border equal none\\\\n      fconfig->title = false;\\\\n      fconfig->footer = false;\\\\n      return;\\\\n    }\\\\n    for (size_t i = 0; defaults[i].name; i++) {\\\\n      if (strequal(str.data, defaults[i].name)) {\\\\n        memcpy(chars, defaults[i].chars, sizeof(defaults[i].chars));\\\\n        memset(hl_ids, 0, 8 * sizeof(*hl_ids));\\\\n        if (defaults[i].shadow_color) {\\\\n          int hl_blend = SYN_GROUP_STATIC(\\\\\\\"FloatShadow\\\\\\\");\\\\n          int hl_through = SYN_GROUP_STATIC(\\\\\\\"FloatShadowThrough\\\\\\\");\\\\n          hl_ids[2] = hl_through;\\\\n          hl_ids[3] = hl_blend;\\\\n          hl_ids[4] = hl_blend;\\\\n          hl_ids[5] = hl_blend;\\\\n          hl_ids[6] = hl_through;\\\\n        }\\\\n        return;\\\\n      }\\\\n    }\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"invalid border style \\\\\\\\\\\\\\\"%s\\\\\\\\\\\\\\\"\\\\\\\", str.data);\\\\n  }\\\\n}\\\\n\\\\nstatic void generate_api_error(win_T *wp, const char *attribute, Error *err)\\\\n{\\\\n  if (wp != NULL && wp->w_floating) {\\\\n    api_set_error(err, kErrorTypeValidation,\\\\n                  \\\\\\\"Missing 'relative' field when reconfiguring floating window %d\\\\\\\",\\\\n                  wp->handle);\\\\n  } else {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have '%s'\\\\\\\", attribute);\\\\n  }\\\\n}\\\\n\\\\nbool parse_winborder(WinConfig *fconfig, Error *err)\\\\n{\\\\n  if (!fconfig) {\\\\n    return false;\\\\n  }\\\\n  Object style = OBJECT_INIT;\\\\n\\\\n  if (strchr(p_winborder, ',')) {\\\\n    Array border_chars = ARRAY_DICT_INIT;\\\\n    char *p = p_winborder;\\\\n    char part[MAX_SCHAR_SIZE] = { 0 };\\\\n    int count = 0;\\\\n\\\\n    while (*p != NUL) {\\\\n      if (count >= 8) {\\\\n        api_free_array(border_chars);\\\\n        return false;\\\\n      }\\\\n\\\\n      size_t part_len = copy_option_part(&p, part, sizeof(part), \\\\\\\",\\\\\\\");\\\\n      if (part_len == 0 || part[0] == NUL) {\\\\n        api_free_array(border_chars);\\\\n        return false;\\\\n      }\\\\n\\\\n      String str = cstr_to_string(part);\\\\n      ADD(border_chars, STRING_OBJ(str));\\\\n      count++;\\\\n    }\\\\n\\\\n    if (count != 8) {\\\\n      api_free_array(border_chars);\\\\n      return false;\\\\n    }\\\\n\\\\n    style = ARRAY_OBJ(border_chars);\\\\n  } else {\\\\n    style = CSTR_TO_OBJ(p_winborder);\\\\n  }\\\\n\\\\n  parse_border_style(style, fconfig, err);\\\\n\\\\n  if (style.type == kObjectTypeArray) {\\\\n    api_free_array(style.data.array);\\\\n  } else if (style.type == kObjectTypeString) {\\\\n    api_free_string(style.data.string);\\\\n  }\\\\n\\\\n  return !ERROR_SET(err);\\\\n}\\\\n\\\\nstatic bool parse_win_config(win_T *wp, Dict(win_config) *config, WinConfig *fconfig, bool reconf,\\\\n                             Error *err)\\\\n{\\\\n#define HAS_KEY_X(d, key) HAS_KEY(d, win_config, key)\\\\n  bool has_relative = false, relative_is_win = false, is_split = false;\\\\n  if (config->relative.size > 0) {\\\\n    if (!parse_float_relative(config->relative, &fconfig->relative)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'relative' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    if (config->relative.size > 0 && !(HAS_KEY_X(config, row) && HAS_KEY_X(config, col))\\\\n        && !HAS_KEY_X(config, bufpos)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'relative' requires 'row'/'col' or 'bufpos'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    has_relative = true;\\\\n    fconfig->external = false;\\\\n    if (fconfig->relative == kFloatRelativeWindow) {\\\\n      relative_is_win = true;\\\\n      fconfig->bufpos.lnum = -1;\\\\n    }\\\\n  } else if (!config->external) {\\\\n    if (HAS_KEY_X(config, vertical) || HAS_KEY_X(config, split)) {\\\\n      is_split = true;\\\\n    } else if (wp == NULL) {  // new win\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"Must specify 'relative' or 'external' when creating a float\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, vertical)) {\\\\n    if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"floating windows cannot have 'vertical'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, split)) {\\\\n    if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"floating windows cannot have 'split'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (!parse_config_split(config->split, &fconfig->split)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'split' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, anchor)) {\\\\n    if (!parse_float_anchor(config->anchor, &fconfig->anchor)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'anchor' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, row)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"row\\\\\\\", err);\\\\n      goto fail;\\\\n    }\\\\n    fconfig->row = config->row;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, col)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"col\\\\\\\", err);\\\\n      goto fail;\\\\n    }\\\\n    fconfig->col = config->col;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, bufpos)) {\\\\n    if (!has_relative || is_split) {\\\\n      generate_api_error(wp, \\\\\\\"bufpos\\\\\\\", err);\\\\n      goto fail;\\\\n    } else {\\\\n      if (!parse_float_bufpos(config->bufpos, &fconfig->bufpos)) {\\\\n        api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'bufpos' key\\\\\\\");\\\\n        goto fail;\\\\n      }\\\\n\\\\n      if (!HAS_KEY_X(config, row)) {\\\\n        fconfig->row = (fconfig->anchor & kFloatAnchorSouth) ? 0 : 1;\\\\n      }\\\\n      if (!HAS_KEY_X(config, col)) {\\\\n        fconfig->col = 0;\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, width)) {\\\\n    if (config->width > 0) {\\\\n      fconfig->width = (int)config->width;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'width' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  } else if (!reconf && !is_split) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"Must specify 'width'\\\\\\\");\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, height)) {\\\\n    if (config->height > 0) {\\\\n      fconfig->height = (int)config->height;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'height' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  } else if (!reconf && !is_split) {\\\\n    api_set_error(err, kErrorTypeValidation, \\\\\\\"Must specify 'height'\\\\\\\");\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (relative_is_win || is_split) {\\\\n    if (reconf && relative_is_win) {\\\\n      win_T *target_win = find_window_by_handle(config->win, err);\\\\n      if (!target_win) {\\\\n        goto fail;\\\\n      }\\\\n\\\\n      if (target_win == wp) {\\\\n        api_set_error(err, kErrorTypeException, \\\\\\\"floating window cannot be relative to itself\\\\\\\");\\\\n        goto fail;\\\\n      }\\\\n    }\\\\n    fconfig->window = curwin->handle;\\\\n    if (HAS_KEY_X(config, win)) {\\\\n      if (config->win > 0) {\\\\n        fconfig->window = config->win;\\\\n      }\\\\n    }\\\\n  } else if (HAS_KEY_X(config, win)) {\\\\n    if (has_relative) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"'win' key is only valid with relative='win' and relative=''\\\\\\\");\\\\n      goto fail;\\\\n    } else if (!is_split) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"non-float with 'win' requires at least 'split' or 'vertical'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, external)) {\\\\n    fconfig->external = config->external;\\\\n    if (has_relative && fconfig->external) {\\\\n      api_set_error(err, kErrorTypeValidation,\\\\n                    \\\\\\\"Only one of 'relative' and 'external' must be used\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (fconfig->external && !ui_has(kUIMultigrid)) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"UI doesn't support external windows\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, focusable)) {\\\\n    fconfig->focusable = config->focusable;\\\\n    fconfig->mouse = config->focusable;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, mouse)) {\\\\n    fconfig->mouse = config->mouse;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, zindex)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'zindex'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    if (config->zindex > 0) {\\\\n      fconfig->zindex = (int)config->zindex;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'zindex' key must be a positive Integer\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, title)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'title'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    parse_bordertext(config->title, kBorderTextTitle, fconfig, err);\\\\n    if (ERROR_SET(err)) {\\\\n      goto fail;\\\\n    }\\\\n\\\\n    // handles unset 'title_pos' same as empty string\\\\n    if (!parse_bordertext_pos(wp, config->title_pos, kBorderTextTitle, fconfig, err)) {\\\\n      goto fail;\\\\n    }\\\\n  } else {\\\\n    if (HAS_KEY_X(config, title_pos)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"title_pos requires title to be set\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, footer)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'footer'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n\\\\n    parse_bordertext(config->footer, kBorderTextFooter, fconfig, err);\\\\n    if (ERROR_SET(err)) {\\\\n      goto fail;\\\\n    }\\\\n\\\\n    // handles unset 'footer_pos' same as empty string\\\\n    if (!parse_bordertext_pos(wp, config->footer_pos, kBorderTextFooter, fconfig, err)) {\\\\n      goto fail;\\\\n    }\\\\n  } else {\\\\n    if (HAS_KEY_X(config, footer_pos)) {\\\\n      api_set_error(err, kErrorTypeException, \\\\\\\"footer_pos requires footer to be set\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  Object border_style = OBJECT_INIT;\\\\n  if (HAS_KEY_X(config, border)) {\\\\n    if (is_split) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"non-float cannot have 'border'\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    border_style = config->border;\\\\n    if (border_style.type != kObjectTypeNil) {\\\\n      parse_border_style(border_style, fconfig, err);\\\\n      if (ERROR_SET(err)) {\\\\n        goto fail;\\\\n      }\\\\n    }\\\\n  } else if (*p_winborder != NUL && (wp == NULL || !wp->w_floating)\\\\n             && !parse_winborder(fconfig, err)) {\\\\n    goto fail;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, style)) {\\\\n    if (config->style.data[0] == NUL) {\\\\n      fconfig->style = kWinStyleUnused;\\\\n    } else if (striequal(config->style.data, \\\\\\\"minimal\\\\\\\")) {\\\\n      fconfig->style = kWinStyleMinimal;\\\\n    } else {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"Invalid value of 'style' key\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, noautocmd)) {\\\\n    if (wp) {\\\\n      api_set_error(err, kErrorTypeValidation, \\\\\\\"'noautocmd' cannot be used with existing windows\\\\\\\");\\\\n      goto fail;\\\\n    }\\\\n    fconfig->noautocmd = config->noautocmd;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, fixed)) {\\\\n    fconfig->fixed = config->fixed;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, hide)) {\\\\n    fconfig->hide = config->hide;\\\\n  }\\\\n\\\\n  if (HAS_KEY_X(config, _cmdline_offset)) {\\\\n    fconfig->_cmdline_offset = (int)config->_cmdline_offset;\\\\n  }\\\\n\\\\n  return true;\\\\n\\\\nfail:\\\\n  merge_win_config(fconfig, wp != NULL ? wp->w_config : WIN_CONFIG_INIT);\\\\n  return false;\\\\n#undef HAS_KEY_X\\\\n\\\"}],\\\"textDocument\\\":{\\\"uri\\\":\\\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\\\",\\\"version\\\":3}}}\\n\\nI[16:48:25.434] <-- textDocument/didChange\\nE[16:48:25.434] Failed to update /Users/mw/workspace/neovim/src/nvim/api/win_config.c: Change's rangeLength (46600) doesn't match the computed range length (46954).\\n\"\n[ERROR][2025-05-03 16:48:28] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:28.305] <<< {\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didChange\",\"params\":{\"contentChanges\":[{\"range\":{\"end\":{\"character\":0,\"line\":1109},\"start\":{\"character\":39,\"line\":1108}},\"rangeLength\":1,\"text\":\"\\\\n    \\\\n\"}],\"textDocument\":{\"uri\":\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\",\"version\":5}}}\\n\\nI[16:48:28.305] <-- textDocument/didChange\\nI[16:48:28.305] Trying to incrementally change non-added document: /Users/mw/workspace/neovim/src/nvim/api/win_config.c\\n'\n[ERROR][2025-05-03 16:48:28] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:28.661] <<< {\"jsonrpc\":\"2.0\",\"method\":\"textDocument/didChange\",\"params\":{\"contentChanges\":[{\"range\":{\"end\":{\"character\":4,\"line\":1109},\"start\":{\"character\":4,\"line\":1109}},\"rangeLength\":0,\"text\":\"a\"}],\"textDocument\":{\"uri\":\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\",\"version\":6}}}\\n\\nI[16:48:28.661] <-- textDocument/didChange\\nI[16:48:28.661] Trying to incrementally change non-added document: /Users/mw/workspace/neovim/src/nvim/api/win_config.c\\n'\n[ERROR][2025-05-03 16:48:28] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:28.688] <<< {\"id\":2,\"jsonrpc\":\"2.0\",\"method\":\"textDocument/completion\",\"params\":{\"context\":{\"triggerCharacter\":\"a\",\"triggerKind\":2},\"position\":{\"character\":5,\"line\":1109},\"textDocument\":{\"uri\":\"file:///Users/mw/workspace/neovim/src/nvim/api/win_config.c\"}}}\\n\\nI[16:48:28.688] <-- textDocument/completion(2)\\n'\n[ERROR][2025-05-03 16:48:28] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t\"I[16:48:28.689] --> reply:textDocument/completion(2) 1 ms, error: -32602: trying to get preamble for non-added document\\n\"\n[ERROR][2025-05-03 16:48:28] ...p/_transport.lua:36\t\"rpc\"\t\"clangd\"\t\"stderr\"\t'V[16:48:28.689] >>> {\"error\":{\"code\":-32602,\"message\":\"trying to get preamble for non-added document\"},\"id\":2,\"jsonrpc\":\"2.0\"}\\n\\n'\n``",
            "created_at": "2025-05-08T11:20:17Z",
            "html_url": "https://github.com/neovim/neovim/issues/17085#issuecomment-2862692826",
            "id": 2862692826,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/17085",
            "node_id": "IC_kwDOAPphoM6qoTna",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862692826/reactions"
            },
            "updated_at": "2025-05-08T11:20:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862692826",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 6,
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/17085/comments",
    "created_at": "2022-01-13T22:33:42Z",
    "events_url": "https://api.github.com/repos/neovim/neovim/issues/17085/events",
    "html_url": "https://github.com/neovim/neovim/issues/17085",
    "id": 1102500218,
    "labels": [
        {
            "color": "f9d0c4",
            "default": true,
            "description": "issues reporting wrong behavior",
            "id": 77997474,
            "name": "bug",
            "node_id": "MDU6TGFiZWw3Nzk5NzQ3NA==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/bug"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "labels_url": "https://api.github.com/repos/neovim/neovim/issues/17085/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "I_kwDOAPphoM5BttF6",
    "number": 17085,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 0,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 0,
        "url": "https://api.github.com/repos/neovim/neovim/issues/17085/reactions"
    },
    "repository_url": "https://api.github.com/repos/neovim/neovim",
    "state": "closed",
    "state_reason": "completed",
    "sub_issues_summary": {
        "completed": 0,
        "percent_completed": 0,
        "total": 0
    },
    "timeline_url": "https://api.github.com/repos/neovim/neovim/issues/17085/timeline",
    "title": "incremental textDocument/didChange sequence after `o` when all lines are deleted => desync",
    "type": null,
    "updated_at": "2025-05-08T11:20:18Z",
    "url": "https://api.github.com/repos/neovim/neovim/issues/17085",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/548993?v=4",
        "events_url": "https://api.github.com/users/sam-mccall/events{/privacy}",
        "followers_url": "https://api.github.com/users/sam-mccall/followers",
        "following_url": "https://api.github.com/users/sam-mccall/following{/other_user}",
        "gists_url": "https://api.github.com/users/sam-mccall/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/sam-mccall",
        "id": 548993,
        "login": "sam-mccall",
        "node_id": "MDQ6VXNlcjU0ODk5Mw==",
        "organizations_url": "https://api.github.com/users/sam-mccall/orgs",
        "received_events_url": "https://api.github.com/users/sam-mccall/received_events",
        "repos_url": "https://api.github.com/users/sam-mccall/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/sam-mccall/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/sam-mccall/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/sam-mccall",
        "user_view_type": "public"
    }
}