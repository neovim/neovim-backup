{
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "body": "### Problem\r\n\r\nIt seems that at the moment displaying documentation for LSP completion does not work. If I'm wrong please close this issue. \r\n\r\nWe probably need to call [completionItem/resolve](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem_resolve) for each item. The only such call seems to be made for single submitted item. \r\n\r\n### Expected behavior\r\n\r\nDisplay documentation attached to an item - maybe by the user choice with some new option on `vim.lsp.completion.BufferOpts`.\r\n\r\nI have created a simple [example](https://gist.github.com/przepompownia/0690ebe28a24bd10b45118fceb980dfd) containing autocommand on `CompleteChanged` that shows that it's not difficult but not sure how it should like as a built-in functionality so I didn't create PR. \r\n \r\n```lua\r\nvim.api.nvim_create_autocmd('FileType', {\r\n  pattern = 'lua',\r\n  callback = function (args)\r\n    vim.treesitter.start(args.buf, 'lua')\r\n    vim.lsp.start({\r\n      name = 'lua-ls',\r\n      cmd = {'lua-language-server'},\r\n      root_dir = vim.fs.root(args.buf, 'init.lua'),\r\n    })\r\n  end,\r\n})\r\n\r\nvim.api.nvim_create_autocmd('LspAttach', {\r\n  callback = function (args)\r\n    local client = vim.lsp.get_client_by_id(args.data.client_id)\r\n\r\n    vim.lsp.completion.enable(true, args.data.client_id, args.buf, {autotrigger = true})\r\n\r\n    vim.keymap.set({'i'}, '<C-Space>', function ()\r\n      vim.lsp.completion.trigger()\r\n    end, {buffer = args.buf})\r\n\r\n    vim.api.nvim_create_autocmd('CompleteChanged', {\r\n      buffer = args.buf,\r\n      callback = function ()\r\n        local info = vim.fn.complete_info({'selected'})\r\n        local completionItem = vim.tbl_get(vim.v.completed_item, 'user_data', 'nvim', 'lsp', 'completion_item')\r\n        if nil == completionItem then\r\n          return\r\n        end\r\n\r\n        client.request(vim.lsp.protocol.Methods.completionItem_resolve, completionItem, function (_err, result)\r\n          if nil == result then\r\n            return\r\n          end\r\n\r\n          local winData = vim.api.nvim__complete_set(info['selected'], {info = result.documentation.value})\r\n          if not vim.api.nvim_win_is_valid(winData.winid) then\r\n            return\r\n          end\r\n          vim.api.nvim_win_set_config(winData.winid, {border = 'rounded'})\r\n          vim.treesitter.start(winData.bufnr, 'markdown')\r\n          vim.wo[winData.winid].conceallevel = 3\r\n        end, args.buf)\r\n\r\n        vim.api.nvim_create_autocmd({'TextChangedI'}, {\r\n          buffer = args.buf,\r\n          callback = function ()\r\n            vim.lsp.completion.trigger()\r\n          end\r\n        })\r\n      end\r\n    })\r\n  end\r\n})\r\n\r\nvim.go.completeopt = 'menu,noselect,menuone,popup'\r\n\r\nlocal pumMaps = {\r\n  ['<Tab>'] = '<C-n>',\r\n  ['<Down>'] = '<C-n>',\r\n  ['<S-Tab>'] = '<C-p>',\r\n  ['<Up>'] = '<C-p>',\r\n  ['<CR>'] = '<C-y>',\r\n}\r\n\r\nfor insertKmap, pumKmap in pairs(pumMaps) do\r\n  vim.keymap.set(\r\n    {'i'},\r\n    insertKmap,\r\n    function ()\r\n      return vim.fn.pumvisible() == 1 and pumKmap or insertKmap\r\n    end,\r\n    {expr = true}\r\n  )\r\nend\r\n```\r\n\r\n![Screenshot](https://github.com/neovim/neovim/assets/11404453/8ba8f9b0-9c15-454d-8e9f-2ebefebfbd79)\r\n",
    "closed_at": null,
    "closed_by": null,
    "comment_data": [
        {
            "author_association": "MEMBER",
            "body": "Tips: request is asynchronous, it is best to use a timer to ensure that selected is the same before you invoke nvim__set_complete. and when no result  you also need close exist info window.",
            "created_at": "2024-06-07T05:56:20Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2154135840",
            "id": 2154135840,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6AZYEg",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2154135840/reactions"
            },
            "updated_at": "2024-06-07T07:42:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2154135840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I then have updated the example to\r\n```lua\r\nvim.api.nvim_create_autocmd('FileType', {\r\n  pattern = 'lua',\r\n  callback = function (args)\r\n    vim.treesitter.start(args.buf, 'lua')\r\n    vim.lsp.start({\r\n      name = 'lua-ls',\r\n      cmd = {'lua-language-server'},\r\n      root_dir = vim.fs.root(args.buf, 'init.lua'),\r\n    })\r\n  end,\r\n})\r\n\r\nvim.api.nvim_create_autocmd('LspAttach', {\r\n  callback = function (args)\r\n    vim.lsp.completion.enable(true, args.data.client_id, args.buf, {autotrigger = true})\r\n\r\n    vim.keymap.set({'i'}, '<C-Space>', function ()\r\n      vim.lsp.completion.trigger()\r\n    end, {buffer = args.buf})\r\n\r\n    vim.api.nvim_create_autocmd('CompleteChanged', {\r\n      buffer = args.buf,\r\n      callback = function ()\r\n        local info = vim.fn.complete_info({'selected'})\r\n        local completionItem = vim.tbl_get(vim.v.completed_item, 'user_data', 'nvim', 'lsp', 'completion_item')\r\n        if nil == completionItem then\r\n          return\r\n        end\r\n\r\n        local resolvedItem = vim.lsp.buf_request_sync(\r\n          args.buf,\r\n          vim.lsp.protocol.Methods.completionItem_resolve,\r\n          completionItem,\r\n          500\r\n        )\r\n\r\n        local docs = vim.tbl_get(resolvedItem[args.data.client_id], 'result', 'documentation', 'value')\r\n        if nil == docs then\r\n          return\r\n        end\r\n\r\n        local winData = vim.api.nvim__complete_set(info['selected'], {info = docs})\r\n        if not winData.winid or not vim.api.nvim_win_is_valid(winData.winid) then\r\n          return\r\n        end\r\n\r\n        vim.api.nvim_win_set_config(winData.winid, {border = 'rounded'})\r\n        vim.treesitter.start(winData.bufnr, 'markdown')\r\n        vim.wo[winData.winid].conceallevel = 3\r\n\r\n        vim.api.nvim_create_autocmd({'TextChangedI'}, {\r\n          buffer = args.buf,\r\n          callback = function ()\r\n            vim.lsp.completion.trigger()\r\n          end\r\n        })\r\n      end\r\n    })\r\n  end\r\n})\r\n\r\nvim.go.completeopt = 'menu,noselect,menuone,popup'\r\n\r\nlocal pumMaps = {\r\n  ['<Tab>'] = '<C-n>',\r\n  ['<Down>'] = '<C-n>',\r\n  ['<S-Tab>'] = '<C-p>',\r\n  ['<Up>'] = '<C-p>',\r\n  ['<CR>'] = '<C-y>',\r\n}\r\n\r\nfor insertKmap, pumKmap in pairs(pumMaps) do\r\n  vim.keymap.set(\r\n    {'i'},\r\n    insertKmap,\r\n    function ()\r\n      return vim.fn.pumvisible() == 1 and pumKmap or insertKmap\r\n    end,\r\n    {expr = true}\r\n  )\r\nend\r\n```",
            "created_at": "2024-06-10T22:40:00Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2159428607",
            "id": 2159428607,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6AtkP_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2159428607/reactions"
            },
            "updated_at": "2024-06-10T22:40:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2159428607",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
                "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
                "followers_url": "https://api.github.com/users/przepompownia/followers",
                "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
                "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/przepompownia",
                "id": 11404453,
                "login": "przepompownia",
                "node_id": "MDQ6VXNlcjExNDA0NDUz",
                "organizations_url": "https://api.github.com/users/przepompownia/orgs",
                "received_events_url": "https://api.github.com/users/przepompownia/received_events",
                "repos_url": "https://api.github.com/users/przepompownia/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/przepompownia",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Not sure if it's required for the core. But you can definitely use it as a plugin.",
            "created_at": "2024-06-19T10:07:03Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2178288508",
            "id": 2178288508,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6B1gt8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2178288508/reactions"
            },
            "updated_at": "2024-06-19T10:07:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2178288508",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Not sure if it's required for the core. But you can definitely use it as a plugin.\r\n\r\nOf course, but if so, I need an explanation why we would like to end with delivering `vim.lsp.completion` in its current form, which is useful, but only partially (and especially why its implementation landed here instead in some modern plugin). Have we discussed this somewhere?",
            "created_at": "2024-06-19T16:59:34Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2179132114",
            "id": 2179132114,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6B4urS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 7,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 7,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2179132114/reactions"
            },
            "updated_at": "2024-06-19T16:59:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2179132114",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
                "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
                "followers_url": "https://api.github.com/users/przepompownia/followers",
                "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
                "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/przepompownia",
                "id": 11404453,
                "login": "przepompownia",
                "node_id": "MDQ6VXNlcjExNDA0NDUz",
                "organizations_url": "https://api.github.com/users/przepompownia/orgs",
                "received_events_url": "https://api.github.com/users/przepompownia/received_events",
                "repos_url": "https://api.github.com/users/przepompownia/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/przepompownia",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "I agree that this should be added in core. I think that directly sending LSP requests is not the level of abstraction that a user should touch to get basic functionality.\n\nThe current LSP completion API provides an abstraction on top of LSP requests which is usable out of the box, and if you need to change the completion items, or write custom trigger logic, you can do all of that with simple Lua code, without messing with underlying LSP requests.\n\nHowever, the only way to get completion documentation is to manually envoke an LSP request, which is, in my opinion, too low level for something that is generally considered a basic part of the autocompletion experience.\n\nI think the default LSP completion, while being basic, should still be fully usable out of the box, and it mostly is. Here's my configuration:\n\nhttps://github.com/flexagoon/init.lua/blob/main/lua/config/completion.lua\n\nMost of that code is just me defining custom trigger behavior since I don't like the default one, but the completion is perfectly usable even without that.",
            "created_at": "2024-10-21T20:04:21Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2427612854",
            "id": 2427612854,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6Qsm62",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2427612854/reactions"
            },
            "updated_at": "2024-10-21T20:04:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2427612854",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/66178592?v=4",
                "events_url": "https://api.github.com/users/flexagoon/events{/privacy}",
                "followers_url": "https://api.github.com/users/flexagoon/followers",
                "following_url": "https://api.github.com/users/flexagoon/following{/other_user}",
                "gists_url": "https://api.github.com/users/flexagoon/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/flexagoon",
                "id": 66178592,
                "login": "flexagoon",
                "node_id": "MDQ6VXNlcjY2MTc4NTky",
                "organizations_url": "https://api.github.com/users/flexagoon/orgs",
                "received_events_url": "https://api.github.com/users/flexagoon/received_events",
                "repos_url": "https://api.github.com/users/flexagoon/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/flexagoon/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/flexagoon/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/flexagoon",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "In my config, I have implemented `completionItem.resolveSupport` lsp client capability for the documentation field and markdown `completionItem.documentationFormat` client capability. I was going to create new issue but found this issue already exists. I would be willing to work on a PR to implement it in neovim. However, I want to get some feedback on my approach and discuss several bugs/missing features that resulted in a more complicated implementation. I will create issues where needed for those bugs/features requests and reference them to this issue in a day or so.\n\nMy intent with this comment is to:\n\n1. Define specific feature requirements (to govern at least my proposed implementation)\n2. Show it is at least possible to implement these requirements without any C code changes\n3. Highlight pain-points by showing the lua workarounds\n4. Propose potential solutions to those pain-points that could be solved with changes to the C code. When appropriate, I will create seperate issues for them and link back to this issue\n\nBecause there is a lot of name collisions in the documentation/API for these features,\nI try to adhere to the following terminology:\n\n- Preview window/buffer: the normal vim preview window/buffer that can be open with `:pedit`\n- Preview documention window/buffer: the preview window/buffer when it displays completion documentation\n- Floating documentation window/buffer: the floating window/buffer that displays the completion documentation (I have seen at least three different ways to refer to this but they all have name collisions with other things)\n- Documentation window/buffer: either the preview documentation window/buffer or the floating documention window/buffer depending on what the user has their vim.bo.completeopt set to. I will use this when I need a collective term to refer to them.\n- Documentation: the contents that is or could be (depending on context) displayed in the documentation buffer\n- Documentation field: the documentation field of the completion item defined in the lsp spec\n- Completion menu: the popup listing completion items\n\nRequirements:\n\n- Must respect `vim.bo.completopt` settings of `popup`, `preview`, or neither\n  - If `popup`, use the floating documention window\n  - If `preview`, use the preview documetion window\n  - If both `popup` and `preview`, use the floating documention window to match current behavior\n  - If neither `popup` or `preview`, do not display any documention window\n- Must set documentation buffer filetype set to `markdown` if lsp documentation kind is markdown\n- Must clear the documentation buffer filetype when lsp completion item documentation kind is not markdown\n- Must display the correct tressiter highlights in the documentation buffer for the filetype\n- Must fetch the documentation with a `completionItem/resolve` request and display the results in the documetion window when the lsp for the completion item supports `completionItem/resolve`, and the info field is missing from completion item.\n- Must show the previously displayed documentation when the active completion changes to an item without documention (this is how it currently functions and my implementation should not change it despite not being my preference)\n- Must follow project conventions (this is the one requirement my init.lua will ignore since it's purpose differs from an actual PR)\n\nPain Points:\n\n- Getting the preview winid and preview bufnr is significantly more work when `completeopt` is set to `preview`\n- Treesitter bugs result in hacks where I always close the preview/popup buffer and reopen it (there is an active PR that will fix these issues)\n- Having to use the experimental api `nvim__complete_set` is concerning but likely could be refactored out whenever an official way of updating the displayed documentation is settled on.\n- Needing to manually create a preview window to display the documentation in when `completeopt` is set to `preview` feels bad compared to the floating documention window which is displayed on a simple call to `nvim__complete_set`\n- Not having a field in the vim completion item for the documentation filetype results in always having to checking the `user_data.nvim.lsp.completion_item.documentation` field. Between that and the my workarounds for the Treesitter issues it was just easier/simpler to display the documentation from the `user_data.nvim.lsp.completion_item.documentation` field rather then the `info` field which is an awkward [desire path](https://en.wikipedia.org/wiki/Desire_path).\n- The help docs has a lot of name collisions for the completion documentation making looking up information and discussing it difficult.\n\n## Implementation and Tests\n\nBelow is my implementation of those requirements in lua and a dummy lsp server to test it. The documentation window will say what feature I was testing for that displayed completion item.\nNote: I did not go out of my way to test and prevent race conditions. That's a future problem for future me.\n\n1. Copy the below code to an init.lua file\n2. Make sure escaped backticks are unescaped (using the copy button on the codeblock should properly unescape the backticks)\n3. Run `nvim --clean -u init.lua init.lua`\n4. Go into insert mode with `i`\n5. Type `test`\n6. Open completion menu with `<c-x><c-o>`\n7. Navigate up or down the list of with either the arrow keys or `<c-n>`\n8. Retest with different completopt values by uncommenting the one you want to test\n\n```lua\n-------------------------------------------------------------------------------\n---Setup options (you can swap between the three different versions)\n\n-- Shows documentation floating window\nvim.o.completeopt = \"menu,menuone,noinsert,noselect,popup\"\n\n-- Shows documentation preview window\n-- vim.o.completeopt = \"menu,menuone,noinsert,noselect,preview\"\n\n-- Does not show documentation window\n-- vim.o.completeopt = \"menu,menuone,noinsert,noselect\"\n\n-------------------------------------------------------------------------------\n--- My implementation of documentation completionItem/resolve\n\nlocal function is_documentation_disabled()\n\tlocal options = vim.opt.completeopt:get()\n\tfor _, option in ipairs(options) do\n\t\tif option == \"popup\" then\n\t\t\treturn false\n\t\tend\n\t\tif option == \"preview\" then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend\n\nlocal function get_preview_type()\n\tlocal type = nil\n\tlocal options = vim.opt.completeopt:get()\n\tfor _, option in ipairs(options) do\n\t\tif option == \"popup\" then\n\t\t\treturn \"popup\"\n\t\tend\n\t\tif option == \"preview\" then\n\t\t\ttype = \"preview\"\n\t\tend\n\tend\n\treturn type\nend\n\n---@class PreviewCompleteInfo\n---@field selected integer\n---@field preview_bufnr? integer\n---@field preview_winid? integer\n\n---@return PreviewCompleteInfo\nlocal function get_preview_info()\n\tlocal complete_info = vim.fn.complete_info({\n\t\t\"selected\",\n\t\t\"preview_winid\",\n\t\t\"preview_bufnr\",\n\t})\n\n\tif get_preview_type() == \"preview\" then\n\t\tfor _, winid in ipairs(vim.api.nvim_tabpage_list_wins(0)) do\n\t\t\tlocal wininfo = vim.fn.getwininfo(winid)[1]\n\t\t\tlocal window_type = vim.fn.win_gettype(wininfo.winnr)\n\t\t\tif window_type == \"preview\" then\n\t\t\t\tcomplete_info.preview_winid = winid\n\t\t\t\tcomplete_info.preview_bufnr = wininfo.bufnr\n\t\t\t\treturn complete_info\n\t\t\tend\n\t\tend\n\tend\n\treturn complete_info\nend\n\n---@param documentation string|lsp.MarkupContent|nil\nlocal function is_lsp_completion_documention_empty(documentation)\n\treturn documentation == nil\n\t\tor documentation == \"\"\n\t\tor (type(documentation) == table and documentation.value == \"\")\n\t\tor (type(documentation) == table and documentation.value == nil)\nend\n\n---@param lsp_documentation string|lsp.MarkupContent\n---@param selected integer index of selected completion item 0-indexed\nlocal function display_documentation_popup(lsp_documentation, selected)\n\tlocal kind = lsp_documentation and lsp_documentation.kind\n\tlocal filetype = kind == \"markdown\" and \"markdown\" or \"\"\n\tlocal documentation_value = type(lsp_documentation) == \"string\" and lsp_documentation or lsp_documentation.value\n\tlocal preview_info = vim.api.nvim__complete_set(selected, {\n\t\tinfo = documentation_value,\n\t})\n\tif preview_info.bufnr ~= nil then\n\t\tvim.bo[preview_info.bufnr].filetype = filetype\n\t\tif filetype == \"markdown\" then\n\t\t\tvim.treesitter.start(preview_info.bufnr)\n\t\tend\n\tend\nend\n\n---@param lsp_documentation string|lsp.MarkupContent\nlocal function display_documentation_preview(lsp_documentation)\n\tlocal kind = lsp_documentation and lsp_documentation.kind\n\tlocal filetype = kind == \"markdown\" and \"markdown\" or \"\"\n\tlocal documentation_value = type(lsp_documentation) == \"string\" and lsp_documentation or lsp_documentation.value\n\n\tlocal preview_buf_name = \"Documentation\\\\ Preview\"\n\tvim.cmd(\n\t\t\"silent! pedit! +setlocal\\\\ buftype=nofile\\\\ nobuflisted\\\\ noswapfile\\\\ filetype=\"\n\t\t\t.. filetype\n\t\t\t.. \" \"\n\t\t\t.. preview_buf_name\n\t)\n\tlocal preview_info = get_preview_info()\n\tif preview_info.preview_bufnr ~= nil then\n\t\tlocal lines = vim.split(documentation_value, \"\\n\")\n\t\tvim.api.nvim_buf_set_lines(preview_info.preview_bufnr, 0, -1, false, lines)\n\t\tvim.bo[preview_info.preview_bufnr].filetype = filetype\n\t\tif filetype == \"markdown\" then\n\t\t\tvim.treesitter.start(preview_info.preview_bufnr)\n\t\tend\n\tend\nend\n\n---@param lsp_documentation string|lsp.MarkupContent\nlocal function refresh_documentation(lsp_documentation)\n\tlocal complete_info = get_preview_info()\n\t--we do this check here so that we don't close the completion window\n\t--if we are not going to replace it.\n\tif is_lsp_completion_documention_empty(lsp_documentation) then\n\t\treturn\n\telseif complete_info.preview_bufnr == nil and get_preview_type() ~= \"preview\" then\n\t\t--If the documentation buffer is already closed and does not need to be\n\t\t--a \"preview\" window we can just create a new one without needing to schedule it\n\t\tdisplay_documentation_popup(lsp_documentation, complete_info.selected)\n\telse\n\t\t--Since the preview buffer is already open we need to close it and reopen a new\n\t\t--one so that the treesitter highlights refresh. (I at least couldn't figure out a\n\t\t--better way to achieve this. I tried a lot things)\n\t\tvim.schedule(function()\n\t\t\tif get_preview_type() == \"preview\" then\n\t\t\t\tdisplay_documentation_preview(lsp_documentation)\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\tlocal current_complete_info = vim.fn.complete_info({\n\t\t\t\t\"selected\",\n\t\t\t\t\"preview_winid\",\n\t\t\t\t\"preview_bufnr\",\n\t\t\t})\n\t\t\tif current_complete_info.preview_winid ~= nil then\n\t\t\t\t--HACK: nvim_win_hide will cause a whole new\n\t\t\t\t--buffer and window to be generated when I call nvim__complete_set\n\t\t\t\t--Since it is a new buffer, it will recalculate\n\t\t\t\t--the the treesitter highlights correctly. Without this\n\t\t\t\t--the treessiter highlights won't refresh\n\t\t\t\tvim.api.nvim_win_hide(current_complete_info.preview_winid)\n\t\t\tend\n\t\t\tdisplay_documentation_popup(lsp_documentation, current_complete_info.selected)\n\t\tend)\n\tend\nend\n\nlocal function set_documentation(completion_item)\n\tif completion_item == nil then\n\t\treturn\n\tend\n\n\tlocal lsp_completion_item = vim.tbl_get(completion_item, \"user_data\", \"nvim\", \"lsp\", \"completion_item\")\n\tlocal complete_info = get_preview_info()\n\n\tlocal preview_bufnr = complete_info.preview_bufnr\n\tif lsp_completion_item == nil then\n\t\t--Handle non-lsp completion items\n\t\tif preview_bufnr ~= nil and completion_item.word ~= nil and completion_item.word ~= \"\" then\n\t\t\tvim.bo[preview_bufnr].filetype = \"\"\n\t\tend\n\t\treturn\n\tend\n\n\t---@type string|lsp.MarkupContent\n\tlocal lsp_documentation = lsp_completion_item.documentation\n\tif lsp_documentation ~= nil then\n\t\t--Handle lsp completion items with documentation already supplied\n\t\trefresh_documentation(lsp_documentation)\n\t\treturn\n\tend\n\n\t--Handle lsp completion items that need documentation resolved\n\tlocal client_id = vim.tbl_get(completion_item, \"user_data\", \"nvim\", \"lsp\", \"client_id\")\n\tlocal client = vim.lsp.get_client_by_id(client_id)\n\tif client == nil then\n\t\treturn\n\tend\n\n\tlocal is_resolve_support = true --TODO actually check for resolve support\n\tif not is_resolve_support then\n\t\treturn\n\tend\n\tclient.request(vim.lsp.protocol.Methods.completionItem_resolve, lsp_completion_item, function(err, result, _)\n\t\tif err ~= nil then\n\t\t\tvim.print(err)\n\t\t\treturn\n\t\tend\n\t\tlocal documentation = result and result.documentation\n\t\trefresh_documentation(documentation)\n\tend)\nend\n\nlocal function enable_completion_resolve_documentation(bufnr)\n\tvim.api.nvim_create_autocmd(\"CompleteChanged\", {\n\t\tgroup = vim.api.nvim_create_augroup(\"completion.documentation\" .. bufnr, { clear = true }),\n\t\tbuffer = bufnr,\n\t\tcallback = function(_)\n\t\t\tif tonumber(vim.fn.pumvisible()) == 0 or is_documentation_disabled() then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tlocal event = vim.v.event --need to grab from vim.v.event\n\t\t\tset_documentation(event.completed_item)\n\t\tend,\n\t})\nend\n\n-------------------------------------------------------------------------------\n---Setup autocmd that provides completion resolve support\nvim.api.nvim_create_autocmd(\"LspAttach\", {\n\tgroup = vim.api.nvim_create_augroup(\"lsp_attach\", { clear = true }),\n\tdesc = \"lsp on_attach\",\n\tcallback = function(event)\n\t\tlocal client = vim.lsp.get_client_by_id(event.data.client_id)\n\t\tif client == nil then\n\t\t\treturn\n\t\tend\n\n\t\tvim.lsp.completion.enable(true, client.id, event.buf, {\n\t\t\tautotrigger = true,\n\t\t})\n\n\t\tenable_completion_resolve_documentation(event.buf)\n\tend,\n})\n\n-------------------------------------------------------------------------------\n---Setup dummy language server used for testing\n\n---@alias LspServer.Handler fun(params: table?, callback: fun(err: lsp.ResponseError|nil, result: any), notify_reply_callback: fun(message_id: integer)|nil)\n\n---@type {string: LspServer.Handler}\nlocal handlers = {\n\n\t---@type LspServer.Handler\n\t[vim.lsp.protocol.Methods.initialize] = function(_, callback, _)\n\t\tlocal initializeResult = {\n\t\t\tcapabilities = {\n\t\t\t\tcompletionProvider = {\n\t\t\t\t\tresolveProvider = true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tserverInfo = {\n\t\t\t\tname = \"dummy-lsp-server\",\n\t\t\t\tversion = \"0.0.1\",\n\t\t\t},\n\t\t}\n\n\t\tcallback(nil, initializeResult)\n\tend,\n\n\t---@type LspServer.Handler\n\t[vim.lsp.protocol.Methods.textDocument_completion] = function(_, callback, _)\n\t\t---@type lsp.CompletionItem[]\n\t\tlocal completion_items_result = {\n\n\t\t\t{\n\t\t\t\tlabel = \"test01\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = \"test01: with single line `` `filetype=markdown` ``. Item not resolved.\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tlabel = \"test02\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = \"test02: with single line `` `filetype=markdown` ``. Item not resolved. Navigating up from test03 will error, but in theory should be fixed by PR #30246\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test03\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test04\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\ntest04: this should stay up when you navigate to test05\nsince test05 has no documentation in its completion item or resolve results\n\nThis item was not resolved.\n\nsome code to see treesitter highlights\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing injected lua treesitter highlights are working\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test05\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test06\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\ntest06: this should replace test04 documentation when navigated down from test04\n\nThis item was not resolved.\n\nsome code to see treesitter highlights\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing injected lua treesitter highlights are working\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test07\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.PlainText,\n\t\t\t\t\tvalue = [[\ntest07: this documentation is plain text so should not have treesitter highlights\n\nThis item was not resolved.\n\nsome code to see treesitter highlights are disabled\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing that treesitter highlights are disabled since this documentation is set to be plaintext\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test08\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\ntest08: switching back to markdown documentation\n\nThis item was not resolved.\n\nsome code to see treesitter highlights\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing injected lua treesitter highlights are working\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test09\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\t--testing resolve request for plaintext documentation where documentation field is an object\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test10\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\t--testing resolve request for plaintext documentation where documentation field is a string\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tlabel = \"test11\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\t-- documentation will be resolved\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test12\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\t-- no documentation will be resolved\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel = \"test13\",\n\t\t\t\tkind = vim.lsp.protocol.CompletionItemKind.Text,\n\t\t\t\t-- documentation will be resolved\n\t\t\t},\n\t\t}\n\n\t\t---Side Note: I schedule the callback because there seems to be a bug.\n                ---If a lua-defined lsp like this is the only lsp with completion results, the\n\t\t---callback will error. The workaround is to schedule the callback.\n\t\t---I need to do more testing to verify this isn't user error like\n\t\t---not implementing the lsp spec correctly.\n\t\t---\n\t\t---I was getting the following stacktrace:\n\t\t---\n\t\t---E5108: Error executing lua Vim:E565: Not allowed to change text or change window\n\t\t-- stack traceback:\n\t\t-- [C]: in function 'complete'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:464: in function 'callback'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:389: in function 'handler'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/client.lua:681: in function 'callback'\n\t\t-- ...uments\\poc\\debug-neovim\\issue-29225-my-init-lua\\init.lua:128: in function <...uments\\poc\\debug-neovim\\issue-29225-my-init-lua\\init.lua:98>\n\t\t-- ...uments\\poc\\debug-neovim\\issue-29225-my-init-lua\\init.lua:168: in function 'request'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/client.lua:673: in function 'request'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:385: in function 'request'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:424: in function 'trigger'\n\t\t-- C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:735: in function <C:\\nvim-win64\\share\\nvim\\runtime/lua/vim/lsp/completion.lua:725>\n\t\tvim.schedule(function()\n\t\t\tcallback(nil, completion_items_result)\n\t\tend)\n\tend,\n\n\t---@type LspServer.Handler\n\t[vim.lsp.protocol.Methods.completionItem_resolve] = function(request, callback, _)\n\t\tif request.label == \"test03\" then\n\t\t\tlocal item = vim.tbl_deep_extend(\"force\", request, {\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\n# test03: `` `completionItem/resolve` ``\n\nThis item was resolved.\n\nimplements [spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem_resolve)\n]],\n\t\t\t\t},\n\t\t\t})\n\t\t\tcallback(nil, item)\n\t\telseif request.label == \"test09\" then\n\t\t\tlocal item = vim.tbl_deep_extend(\"force\", request, {\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.PlainText,\n\t\t\t\t\tvalue = [[\n# test09: `` `completionItem/resolve` `` with plaintext documentation kind so there should be no treesitter highlights\n\nimplements [spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem_resolve)\n\nThis item was resolved.\n\nsome code to see treesitter highlights are disabled\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing that treesitter highlights are disabled since this documentation is set to be plaintext\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t})\n\t\t\tcallback(nil, item)\n\t\telseif request.label == \"test10\" then\n\t\t\tlocal item = vim.tbl_deep_extend(\"force\", request, {\n\t\t\t\tdocumentation = [[\n# test10: `` `completionItem/resolve` `` with plaintext documentation where documentation is a string and not an object\n\nimplements [spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#completionItem_resolve)\n\nThis item was resolved.\n\nsome code to see treesitter highlights are disabled\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing that treesitter highlights are disabled since this documentation is set to be plaintext\")\nend\n\\`\\`\\`\n]],\n\t\t\t})\n\t\t\tcallback(nil, item)\n\n\t\t----\n\t\telseif request.label == \"test11\" then\n\t\t\tlocal item = vim.tbl_deep_extend(\"force\", request, {\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\ntest11: this should stay up when you navigate to test12\nsince test12 has no documentation in its completion item or resolve results\n\nThis item was resolved.\n\nsome code to see treesitter highlights\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing injected lua treesitter highlights are working\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t})\n\t\t\tcallback(nil, item)\n\t\telseif request.label == \"test13\" then\n\t\t\tlocal item = vim.tbl_deep_extend(\"force\", request, {\n\t\t\t\tdocumentation = {\n\t\t\t\t\tkind = vim.lsp.protocol.MarkupKind.Markdown,\n\t\t\t\t\tvalue = [[\ntest13: this should replace test11 documentation when navigated down from test11 and test 12\n\nThis item was resolved.\n\nsome code to see treesitter highlights\n\\`\\`\\`lua\nlocal function test()\n    vim.print(\"Testing injected lua treesitter highlights are working\")\nend\n\\`\\`\\`\n]],\n\t\t\t\t},\n\t\t\t})\n\t\t\tcallback(nil, item)\n\t\tend\n\t\tcallback(nil, nil)\n\tend,\n}\n\nvim.api.nvim_create_autocmd(\"FileType\", {\n\tpattern = { \"lua\" },\n\tgroup = vim.api.nvim_create_augroup(\"start_dummy_lsp\", {}),\n\tcallback = function()\n\t\tvim.lsp.start({\n\t\t\tname = \"dummylsp\",\n\t\t\troot_dir = vim.fn.getcwd(),\n\t\t\t---@type fun(dispatchers: vim.lsp.rpc.Dispatchers): vim.lsp.rpc.PublicClient\n\t\t\tcmd = function(_)\n\t\t\t\t---@type vim.lsp.rpc.PublicClient\n\t\t\t\treturn {\n\n\t\t\t\t\t---@type fun(method: string, params: table?, callback: fun(err: lsp.ResponseError|nil, result: any), notify_reply_callback: fun(message_id: integer)|nil):boolean,integer?\n\t\t\t\t\trequest = function(method, params, callback, notify_reply_callback)\n\t\t\t\t\t\tif handlers[method] then\n\t\t\t\t\t\t\thandlers[method](params, callback, notify_reply_callback)\n\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\tend\n\t\t\t\t\tend,\n\t\t\t\t\tnotify = function(_, _)\n\t\t\t\t\t\treturn false\n\t\t\t\t\tend,\n\t\t\t\t\tis_closing = function()\n\t\t\t\t\t\treturn false\n\t\t\t\t\tend,\n\t\t\t\t\tterminate = function() end,\n\t\t\t\t}\n\t\t\tend,\n\t\t})\n\tend,\n})\n\n\n```\n\n## Feature Requests:\n\n- Calling `vim.fn.complete_info({ 'preview_winid', 'preview_bufnr', })` should return back the preview_winid and preview_bufnr. Currently, complete_info only returns those values if the `selected` field is also fetched is also fetched with `vim.fn.complete_info({ 'selected', 'preview_winid', 'preview_bufnr', })`. \n  (I will create in issue for this soon)\n  See https://github.com/neovim/neovim/blob/5a86360400691e55fae66d60485b61360a1d3d6c/src/nvim/insexpand.c#L2928C1-L2935C6\n  Note: This may have been intentional functionality, but I don't see any documentation indicating it should behave this way. For context, these fields were implemented in [feat(complete): completeopt support popup like vim #24723](https://github.com/neovim/neovim/pull/24723).\n- Modify `vim.fn.complete_info({ 'selected', 'preview_winid', 'preview_bufnr', })` to return back the winid and bufnr of the documentation window regardless of if it is the floating documentation window or preview documentation window\n  (I will create an issue for this soon)\n  Note: the help documentation clearly says that preview_winid and preview_bufnr will be the of the \"floating preview window\" so changing this may be a minor breaking. The one other concern with implementing this is how to handle the situation where the preview window's contents no longer contains the documentation. I think initial implementation should err on simplicity and just return the bufnr and winid without any fancy validation. For context, these fields were originally implemented in [feat(complete): completeopt support popup like vim #24723](https://github.com/neovim/neovim/pull/24723)\n- Add an `infotype` field to completion item that would contain the filetype that the documentation buffer should be set to. Imo, this would be really nice because of the awkward desire path I described in the pain points section. My init.lua implementation doesn't use the completion info field other than to check it is empty. Since I already have to dig into the lsp results to get the filetype, it is just more convenent to grab the documentation contents from the same place. Side-Note: After the tresitter bugs are fixed, I might refactor my init.lua to see if that desire path is still there since I can imagine that making a difference.\n\n## Bugs:\n\n- [treesitter: Invalid 'end_row': out of range on CompleteChanged #30610](https://github.com/neovim/neovim/issues/30610) This is the one bug that I was not able to work around in my init.lua implementation but this will be fixed as soon as glepnir's PR [fix(popup): wrong extmark data sync when lines changed in popup preview #30246](https://github.com/neovim/neovim/pull/30246) is merged.\n- Treesitter highlighter would not redraw highlights in the documentation popup window when the contents changed. The only work around I could find was closing popup window with `vim.api.nvim_win_hide` and recreating it with `vim.api.nvim__complete_set` I suspect that glepnir's PR [fix(popup): wrong extmark data sync when lines changed in popup preview #30246](https://github.com/neovim/neovim/pull/30246) may also fix this so I will test that before creating a separate issue.\n- My init.lua would throw an error if I did not schedule the completion result callback when no secondary lsp was attached. I need do some more testing and make sure this is not an user error before I create an issue for it.\n\n## `nvim__complete_set` Bugs and Features:\n\nI found some bugs with `vim.api.nvim__complete_set`, but since it was demoted to an experimental API in [fix(api): mark nvim\\_\\_complete_set as experimental #28579](https://github.com/neovim/neovim/pull/28579) I would like feedback as to whether or not I should create issues for these. I saw glepnir [commented](https://github.com/neovim/neovim/pull/28579#issuecomment-2085164965) that `nvim__complete_set` won't be needed after [Completion API: completion handlers, Lua callbacks on completion events #16488](https://github.com/neovim/neovim/issues/16488), but I couldn't figure out which part would be the replacement for `nvim__complete_set`. Since that issue is still open and seems to be a larger design initiative, my preference would be to do small bug fixes and improvements to `vim.api.nvim__complete_set` for the time being. Then refactor whenever a replacement is implemented.\n\n- Bug: `nvim__complete_set` does not respect `vim.o.completeopt` and will always use the popup window even when completopt has the preview option. Fixing this would significantly simplify my `completionItem/resolve` implementation.\n- Bug: `nvim__complete_set` will crash after several calls when completeopt has preview option.\n- Feature: Add an infotype option to `nvim__complete_set` options (imo, `vim.bo[preview_bufnr].filetype` would probably be sufficient. However, if we still have issues with treesitter highlights, we may want this field so that we can reuse the fixes from [fix(popup): wrong extmark data sync when lines changed in popup preview #30246](https://github.com/neovim/neovim/pull/30246))\n\n## Possible Alternative Features:\n\nThere are other features that would simplify my `completionItem/resolve` implementation that I considered as possibilities but decided that I prefer my other suggestions. I won't be creating issues for these unless someone with more insight on the vision thinks I should.\n\n- Add a better way to lazily determine the completion item's info field. This could be an alternative to using `nvim__complete_set`. Possibilities include:\n  - vim.bo.omnidocfunc\n  - Allow info field to be a lua function\n  - Add a CompleteChangedPre event that gives the user a chance to modify completed_item before the documentation is displayed (may not be that useful as it sounds since running the lsp request asynchronously would defeat the purpose of this autocmd)\n\n## Conclusion\n\nThe C code for most of the changes I proposed (excluding the \"Possible Alternative Features\" section) would not be difficult to implement. The existing code is fairly easy to read and has good tests. If they are in line with the vision, I feel comfortable creating PRs for these.\n\nTLDR: I created a possible lua only implementation for LSP `completionItem/resolve` support for completion documentation. However, it could be simplified with changes to the C code. I would like feedback on if this approach and my suggestions are in line with the vision.\n\nLastly, thanks for all the great work on the LSP completion. It's been exciting playing around with it.\n",
            "created_at": "2024-11-11T20:16:31Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2468953172",
            "id": 2468953172,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6TKTxU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 2,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2468953172/reactions"
            },
            "updated_at": "2024-11-11T20:16:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2468953172",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/51029315?v=4",
                "events_url": "https://api.github.com/users/crwebb85/events{/privacy}",
                "followers_url": "https://api.github.com/users/crwebb85/followers",
                "following_url": "https://api.github.com/users/crwebb85/following{/other_user}",
                "gists_url": "https://api.github.com/users/crwebb85/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/crwebb85",
                "id": 51029315,
                "login": "crwebb85",
                "node_id": "MDQ6VXNlcjUxMDI5MzE1",
                "organizations_url": "https://api.github.com/users/crwebb85/orgs",
                "received_events_url": "https://api.github.com/users/crwebb85/received_events",
                "repos_url": "https://api.github.com/users/crwebb85/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/crwebb85/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/crwebb85/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/crwebb85",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "hmm #30246 fixes most of the crashes related and @przepompownia already got these bug and test that fix pr . Secondly, nvim__complete_info only works for popup. preview is not supported. As far as I know, vim also does not support you setting info in a callback and then creating a normal preview window about filetype of preview buffer. https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#markupContent it can be plain text or markdown or other string value which defined by server  ..so i think there better use something like `if api.nvim_buf_is_valid(preview_bufnr) then vim.bo[preview_bufnr].filetype = result.documentation` ",
            "created_at": "2024-11-12T09:10:23Z",
            "html_url": "https://github.com/neovim/neovim/issues/29225#issuecomment-2469976099",
            "id": 2469976099,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29225",
            "node_id": "IC_kwDOAPphoM6TONgj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2469976099/reactions"
            },
            "updated_at": "2024-11-12T10:17:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2469976099",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        }
    ],
    "comments": 7,
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/29225/comments",
    "created_at": "2024-06-06T21:43:42Z",
    "events_url": "https://api.github.com/repos/neovim/neovim/issues/29225/events",
    "html_url": "https://github.com/neovim/neovim/issues/29225",
    "id": 2339200419,
    "labels": [
        {
            "color": "c2e0c6",
            "default": true,
            "description": "feature request",
            "id": 77997476,
            "name": "enhancement",
            "node_id": "MDU6TGFiZWw3Nzk5NzQ3Ng==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/enhancement"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        },
        {
            "color": "C5DEF5",
            "default": false,
            "description": "Nvim built-in (omni)completion",
            "id": 3214348835,
            "name": "completion",
            "node_id": "MDU6TGFiZWwzMjE0MzQ4ODM1",
            "url": "https://api.github.com/repos/neovim/neovim/labels/completion"
        },
        {
            "color": "C5DEF5",
            "default": false,
            "description": "floating windows, popups, hover",
            "id": 3234818716,
            "name": "floatwin",
            "node_id": "MDU6TGFiZWwzMjM0ODE4NzE2",
            "url": "https://api.github.com/repos/neovim/neovim/labels/floatwin"
        }
    ],
    "labels_url": "https://api.github.com/repos/neovim/neovim/issues/29225/labels{/name}",
    "locked": false,
    "milestone": null,
    "node_id": "I_kwDOAPphoM6LbV2j",
    "number": 29225,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 2,
        "-1": 0,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 2,
        "url": "https://api.github.com/repos/neovim/neovim/issues/29225/reactions"
    },
    "repository_url": "https://api.github.com/repos/neovim/neovim",
    "state": "open",
    "state_reason": null,
    "sub_issues_summary": {
        "completed": 0,
        "percent_completed": 0,
        "total": 0
    },
    "timeline_url": "https://api.github.com/repos/neovim/neovim/issues/29225/timeline",
    "title": "LSP completion: display documentation if exists for an item",
    "updated_at": "2025-01-17T15:26:53Z",
    "url": "https://api.github.com/repos/neovim/neovim/issues/29225",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/11404453?v=4",
        "events_url": "https://api.github.com/users/przepompownia/events{/privacy}",
        "followers_url": "https://api.github.com/users/przepompownia/followers",
        "following_url": "https://api.github.com/users/przepompownia/following{/other_user}",
        "gists_url": "https://api.github.com/users/przepompownia/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/przepompownia",
        "id": 11404453,
        "login": "przepompownia",
        "node_id": "MDQ6VXNlcjExNDA0NDUz",
        "organizations_url": "https://api.github.com/users/przepompownia/orgs",
        "received_events_url": "https://api.github.com/users/przepompownia/received_events",
        "repos_url": "https://api.github.com/users/przepompownia/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/przepompownia/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/przepompownia/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/przepompownia",
        "user_view_type": "public"
    }
}